<?php
declare(strict_types=1);
namespace Nebule\Library;
// ----------------------------------------------------------------------------------------
$nebuleName = 'library';
$nebuleSurname = 'nebule/library';
$nebuleDescription = 'Library of functions for nebule in php object-oriented.';
$nebuleAuthor = 'Projet nebule';
$nebuleLibVersion = '02021128';
$nebuleLicence = 'GNU GPL 2010-2021';
$nebuleWebsite = 'www.nebule.org';
// ----------------------------------------------------------------------------------------


/*
------------------------------------------------------------------------------------------
 /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING ///
------------------------------------------------------------------------------------------

 [FR] Toute modification de ce code entrainera une modification de son empreinte
      et entrainera donc automatiquement son invalidation !
 [EN] Any changes to this code will cause a change in its footprint and therefore
      automatically result in its invalidation!
 [ES] Cualquier cambio en el código causarán un cambio en su presencia y por lo
      tanto lugar automáticamente a su anulación!

------------------------------------------------------------------------------------------
*/


// Initialisation des logs de la librairie.
closelog();
openlog($nebuleName . '/' . $loggerSessionID, LOG_NDELAY, LOG_USER);
syslog(LOG_INFO, 'LogT=0 LogTabs=' . (microtime(true)) . ' Loading nebule library');


// Paramètres de l'application par défaut.
$applicationName = 'defolt';
$applicationSurname = 'nebule/defolt';
$applicationDescription = 'Default web page for servers without interactive application.';
$applicationVersion = $nebuleLibVersion;
$applicationLicence = $nebuleLicence;
$applicationAuthor = $nebuleAuthor;
$applicationWebsite = $nebuleWebsite;


/**
 * ------------------------------------------------------------------------------------------
 * La classe nebule.
 * ------------------------------------------------------------------------------------------
 *
 * Le coeur de la librairie nebule.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 */
class nebule
{
    // Définition des constantes.
    const NEBULE_LICENCE_NAME = 'nebule';
    const NEBULE_LICENCE_LINK = 'http://www.nebule.org/';
    const NEBULE_LICENCE_DATE = '2010-2020';
    const NEBULE_ENVIRONMENT_FILE = 'nebule.env';
    const NEBULE_BOOTSTRAP_FILE = 'index.php';
    const NEBULE_MINIMUM_ID_SIZE = 6;
    const NEBULE_LOCAL_ENTITY_FILE = 'e';
    const NEBULE_LOCAL_OBJECTS_FOLDER = 'o';
    const NEBULE_LOCAL_LINKS_FOLDER = 'l';
    const NEBULE_LOCAL_HISTORY_FILE = 'f';    // Dans le dossier /l/
    const PUPPETMASTER_URL = 'http://puppetmaster.nebule.org';
    const SECURITY_MASTER_URL = 'http://security.master.nebule.org';
    const CODE_MASTER_URL = 'http://code.master.nebule.org';

    // Les valeurs par défaut des options.
    const DEFAULT_PUPPETMASTER = '88848d09edc416e443ce1491753c75d75d7d8790c1253becf9a2191ac369f4ea.sha2.256';
    const DEFAULT_HOST_URL = 'localhost';
    const DEFAULT_PERMIT_WRITE = true;
    const DEFAULT_PERMIT_WRITE_OBJECT = true;
    const DEFAULT_PERMIT_CREATE_OBJECT = true;
    const DEFAULT_PERMIT_SYNCHRONIZE_OBJECT = false;
    const DEFAULT_PERMIT_PROTECTED_OBJECT = true;
    const DEFAULT_PERMIT_WRITE_LINK = true;
    const DEFAULT_PERMIT_CREATE_LINK = true;
    const DEFAULT_PERMIT_SYNCHRONIZE_LINK = false;
    const DEFAULT_PERMIT_UPLOAD_LINK = false;
    const DEFAULT_PERMIT_PUBLIC_UPLOAD_LINK = false;
    const DEFAULT_PERMIT_PUBLIC_UPLOAD_CODE_MASTER_LINK = true;
    const DEFAULT_PERMIT_OBFUSCATED_LINK = true;
    const DEFAULT_PERMIT_WRITE_ENTITY = true;
    const DEFAULT_PERMIT_WRITE_GROUP = true;
    const DEFAULT_PERMIT_WRITE_CONVERSATION = true;
    const DEFAULT_PERMIT_CURRENCY = true;
    const DEFAULT_PERMIT_WRITE_CURRENCY = true;
    const DEFAULT_PERMIT_CREATE_CURRENCY = false;
    const DEFAULT_PERMIT_WRITE_TRANSACTION = true;
    const DEFAULT_PERMIT_OBFUSCATED_TRANSACTION = false;
    const DEFAULT_PERMIT_SYNCHRONIZE_APPLICATIONS = false;
    const DEFAULT_PERMIT_PUBLIC_SYNCHRONIZE_APPLICATIONS = false;
    const DEFAULT_PERMIT_PUBLIC_CREATE_ENTITY = false;
    const DEFAULT_PERMIT_DELETE_OBJECT_ON_UNKNOW_HASH = true;
    const DEFAULT_PERMIT_CHECK_SIGN_ON_VERIFY = true;
    const DEFAULT_PERMIT_CHECK_SIGN_ON_LIST = true;
    const DEFAULT_PERMIT_CHECK_OBJECT_HASH = true;
    const DEFAULT_PERMIT_LIST_INVALID_LINKS = false;
    const DEFAULT_PERMIT_HISTORY_LINKS_SIGN = false;
    const DEFAULT_PERMIT_INSTANCE_ENTITY_AS_AUTHORITY = false;
    const DEFAULT_PERMIT_DEFAULT_ENTITY_AS_AUTHORITY = false;
    const DEFAULT_PERMIT_LOCAL_SECONDARY_AUTHORITY = true;
    const DEFAULT_PERMIT_RECOVERY_ENTITIES = false;
    const DEFAULT_PERMIT_RECOVERY_REMOVE_ENTITY = false;
    const DEFAULT_PERMIT_INSTANCE_ENTITY_AS_RECOVERY = false;
    const DEFAULT_PERMIT_DEFAULT_ENTITY_AS_RECOVERY = false;
    const DEFAULT_PERMIT_ADD_LINK_TO_SIGNER = true;
    const DEFAULT_PERMIT_LIST_OTHER_HASH = false;
    const DEFAULT_PERMIT_LOCALISATION_STATS = true;
    const DEFAULT_PERMIT_FOLLOW_UPDATES = true;
    const DEFAULT_PERMIT_ONLINE_RESCUE = false;
    const DEFAULT_PERMIT_LOGS = false;
    const DEFAULT_PERMIT_JAVASCRIPT = true;
    const DEFAULT_LOGS_LEVEL = 'NORMAL';
    const DEFAULT_MODE_RESCUE = false;
    const DEFAULT_CRYPTO_LIBRARY = 'openssl';
    const DEFAULT_CRYPTO_HASH_ALGORITHM = 'sha2.256';
    const DEFAULT_CRYPTO_SYMETRIC_ALGORITHM = 'aes-256-ctr';
    const DEFAULT_CRYPTO_ASYMETRIC_ALGORITHM = 'rsa.2048';
    const DEFAULT_SOCIAL_LIBRARY = 'strict';
    const DEFAULT_IO = 'ioFileSystem';
    const DEFAULT_IO_READ_MAX_LINKS = 2000;
    const DEFAULT_IO_READ_MAX_DATA = 10000;
    const DEFAULT_IO_READ_MAX_UPLOAD = 2000000;
    const DEFAULT_IO_TIMEOUT = 1;
    const DEFAULT_DISPLAY_UNSECURE_URL = true;
    const DEFAULT_DISPLAY_NAME_SIZE = 128;
    const DEFAULT_DISPLAY_EMOTIONS = true;
    const DEFAULT_FORCE_DISPLAY_ENTITY_ON_TITLE = false;
    const DEFAULT_MAX_FOLLOWED_UPDATES = 100;
    const DEFAULT_PERMIT_SESSION_OPTIONS = true;
    const DEFAULT_PERMIT_SESSION_BUFFER = true;
    const DEFAULT_PERMIT_BUFFER_IO = true;
    const DEFAULT_SESSION_BUFFER_SIZE = 1000;
    const DEFAULT_APPLICATION = '0';
    const DEFAULT_OBFUSCATE_LINKS = false;
    const DEFAULT_LINKS_VERSION = '2.0';
    const DEFAULT_SUBORDINATION_TO_ENTITY = '';

    // Les commandes.
    const COMMAND_SWITCH_APPLICATION = 'a';
    const COMMAND_BREAK_BOOTSTRAP = 'b';
    const COMMAND_FLUSH = 'f';
    const COMMAND_INLINE = 'i';
    const COMMAND_RESCUE = 'r';
    const COMMAND_UPDATE = 'u';
    const COMMAND_LOGOUT_ENTITY = 'logout';
    const COMMAND_SWITCH_TO_ENTITY = 'switch';
    const COMMAND_SELECT_OBJECT = 'obj';
    const COMMAND_SELECT_LINK = 'lnk';
    const COMMAND_SELECT_ENTITY = 'ent';
    const COMMAND_SELECT_GROUP = 'grp';
    const COMMAND_SELECT_CONVERSATION = 'cvt';
    const COMMAND_SELECT_CURRENCY = 'cur';
    const COMMAND_SELECT_TOKENPOOL = 'tkp';
    const COMMAND_SELECT_TOKEN = 'tkn';
    const COMMAND_SELECT_WALLET = 'wal';
    const COMMAND_SELECT_TRANSACTION = 'trs';
    const COMMAND_SELECT_PASSWORD = 'pwd';
    const COMMAND_SELECT_TICKET = 'tkt';

    // Les références.
    const REFERENCE_OBJECT_TEXT = 'text/plain';
    const REFERENCE_OBJECT_HTML = 'text/html';
    const REFERENCE_OBJECT_CSS = 'text/css';
    const REFERENCE_OBJECT_PHP = 'text/x-php';
    const REFERENCE_OBJECT_APP_PHP = 'application/x-php';
    const REFERENCE_OBJECT_PNG = 'image/png';
    const REFERENCE_OBJECT_JPEG = 'image/jpeg';
    const REFERENCE_OBJECT_MP3 = 'audio/mpeg';
    const REFERENCE_OBJECT_OGG = 'audio/x-vorbis+ogg';
    const REFERENCE_OBJECT_CRYPT_RSA = 'application/x-encrypted/rsa';
    const REFERENCE_OBJECT_ENTITY = 'application/x-pem-file';
    const REFERENCE_ENTITY_HEADER = '-----BEGIN PUBLIC KEY-----';
    const REFERENCE_CRYPTO_HASH_ALGORITHM = 'sha2.256';

    // Les objets références de nebule.
    const REFERENCE_NEBULE_OBJET = 'nebule/objet';
    const REFERENCE_NEBULE_OBJET_HASH = 'nebule/objet/hash';
    const REFERENCE_NEBULE_OBJET_HOMOMORPHE = 'nebule/objet/homomorphe';
    const REFERENCE_NEBULE_OBJET_TYPE = 'nebule/objet/type';
    const REFERENCE_NEBULE_OBJET_LOCALISATION = 'nebule/objet/localisation';
    const REFERENCE_NEBULE_OBJET_TAILLE = 'nebule/objet/taille';
    const REFERENCE_NEBULE_OBJET_PRENOM = 'nebule/objet/prenom';
    const REFERENCE_NEBULE_OBJET_NOM = 'nebule/objet/nom';
    const REFERENCE_NEBULE_OBJET_SURNOM = 'nebule/objet/surnom';
    const REFERENCE_NEBULE_OBJET_PREFIX = 'nebule/objet/prefix';
    const REFERENCE_NEBULE_OBJET_SUFFIX = 'nebule/objet/suffix';
    const REFERENCE_NEBULE_OBJET_LIEN = 'nebule/objet/lien';
    const REFERENCE_NEBULE_OBJET_DATE = 'nebule/objet/date';
    const REFERENCE_NEBULE_OBJET_DATE_ANNEE = 'nebule/objet/date/annee';
    const REFERENCE_NEBULE_OBJET_DATE_MOIS = 'nebule/objet/date/mois';
    const REFERENCE_NEBULE_OBJET_DATE_JOUR = 'nebule/objet/date/jour';
    const REFERENCE_NEBULE_OBJET_DATE_HEURE = 'nebule/objet/date/heure';
    const REFERENCE_NEBULE_OBJET_DATE_MINUTE = 'nebule/objet/date/minute';
    const REFERENCE_NEBULE_OBJET_DATE_SECONDE = 'nebule/objet/date/seconde';
    const REFERENCE_NEBULE_OBJET_DATE_ZONE = 'nebule/objet/date/zone';
    const REFERENCE_NEBULE_OBJET_ENTITE = 'nebule/objet/entite';
    const REFERENCE_NEBULE_OBJET_ENTITE_TYPE = 'nebule/objet/entite/type';
    const REFERENCE_NEBULE_OBJET_ENTITE_LOCALISATION = 'nebule/objet/entite/localisation';
    const REFERENCE_NEBULE_OBJET_ENTITE_SUIVI = 'nebule/objet/entite/suivi';
    const REFERENCE_NEBULE_OBJET_ENTITE_SUIVI_SECONDE = 'nebule/objet/entite/suivi/seconde';
    const REFERENCE_NEBULE_OBJET_ENTITE_SUIVI_MINUTE = 'nebule/objet/entite/suivi/minute';
    const REFERENCE_NEBULE_OBJET_ENTITE_SUIVI_HEURE = 'nebule/objet/entite/suivi/heure';
    const REFERENCE_NEBULE_OBJET_ENTITE_SUIVI_JOUR = 'nebule/objet/entite/suivi/jour';
    const REFERENCE_NEBULE_OBJET_ENTITE_SUIVI_SEMAINE = 'nebule/objet/entite/suivi/semaine';
    const REFERENCE_NEBULE_OBJET_ENTITE_SUIVI_MOIS = 'nebule/objet/entite/suivi/mois';
    const REFERENCE_NEBULE_OBJET_ENTITE_SUIVI_ANNEE = 'nebule/objet/entite/suivi/annee';
    const REFERENCE_NEBULE_OBJET_ENTITE_MAITRE = 'nebule/objet/entite/maitre';
    const REFERENCE_NEBULE_OBJET_ENTITE_MAITRE_SECURITE = 'nebule/objet/entite/maitre/securite';
    const REFERENCE_NEBULE_OBJET_ENTITE_MAITRE_CODE = 'nebule/objet/entite/maitre/code';
    const REFERENCE_NEBULE_OBJET_ENTITE_MAITRE_ANNUAIRE = 'nebule/objet/entite/maitre/annuaire';
    const REFERENCE_NEBULE_OBJET_ENTITE_MAITRE_TEMPS = 'nebule/objet/entite/maitre/temps';
    const REFERENCE_NEBULE_OBJET_ENTITE_AUTORITE_LOCALE = 'nebule/objet/entite/autorite/locale';
    const REFERENCE_NEBULE_OBJET_ENTITE_RECOUVREMENT = 'nebule/objet/entite/recouvrement';
    const REFERENCE_NEBULE_OBJET_INTERFACE_BOOTSTRAP = 'nebule/objet/interface/web/php/bootstrap';
    const REFERENCE_NEBULE_OBJET_INTERFACE_BIBLIOTHEQUE = 'nebule/objet/interface/web/php/bibliotheque';
    const REFERENCE_NEBULE_OBJET_INTERFACE_APPLICATIONS = 'nebule/objet/interface/web/php/applications';
    const REFERENCE_NEBULE_OBJET_INTERFACE_APP_DIRECT = 'nebule/objet/interface/web/php/applications/direct';
    const REFERENCE_NEBULE_OBJET_INTERFACE_APP_ACTIVE = 'nebule/objet/interface/web/php/applications/active';
    const REFERENCE_NEBULE_OBJET_INTERFACE_APP_MODULES = 'nebule/objet/interface/web/php/applications/modules';
    const REFERENCE_NEBULE_OBJET_INTERFACE_APP_MOD_ACTIVE = 'nebule/objet/interface/web/php/applications/modules/active';
    const REFERENCE_NEBULE_OBJET_NOEUD = 'nebule/objet/noeud';
    const REFERENCE_NEBULE_OBJET_IMAGE_REFERENCE = 'nebule/objet/image/reference';
    const REFERENCE_NEBULE_OBJET_EMOTION = 'nebule/objet/emotion';
    const REFERENCE_NEBULE_OBJET_EMOTION_JOIE = 'nebule/objet/emotion/joie';
    const REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE = 'nebule/objet/emotion/confiance';
    const REFERENCE_NEBULE_OBJET_EMOTION_PEUR = 'nebule/objet/emotion/peur';
    const REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE = 'nebule/objet/emotion/surprise';
    const REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE = 'nebule/objet/emotion/tristesse';
    const REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT = 'nebule/objet/emotion/degout';
    const REFERENCE_NEBULE_OBJET_EMOTION_COLERE = 'nebule/objet/emotion/colere';
    const REFERENCE_NEBULE_OBJET_EMOTION_INTERET = 'nebule/objet/emotion/interet';
    const REFERENCE_NEBULE_OBJET_GROUPE = 'nebule/objet/groupe';
    const REFERENCE_NEBULE_OBJET_GROUPE_SUIVI = 'nebule/objet/groupe/suivi';
    const REFERENCE_NEBULE_OBJET_GROUPE_FERME = 'nebule/objet/groupe/ferme';
    const REFERENCE_NEBULE_OBJET_GROUPE_PROTEGE = 'nebule/objet/groupe/protege';
    const REFERENCE_NEBULE_OBJET_GROUPE_DISSIMULE = 'nebule/objet/groupe/dissimule';
    const REFERENCE_NEBULE_OBJET_CONVERSATION = 'nebule/objet/conversation';
    const REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE = 'nebule/objet/conversation/suivie';
    const REFERENCE_NEBULE_OBJET_CONVERSATION_FERMEE = 'nebule/objet/conversation/fermee';
    const REFERENCE_NEBULE_OBJET_CONVERSATION_PROTEGEE = 'nebule/objet/conversation/protegee';
    const REFERENCE_NEBULE_OBJET_CONVERSATION_DISSIMULEE = 'nebule/objet/conversation/dissimulee';
    const REFERENCE_NEBULE_OBJET_ARBORESCENCE = 'nebule/objet/arborescence';
    const REFERENCE_NEBULE_OBJET_MONNAIE = 'nebule/objet/monnaie';
    const REFERENCE_NEBULE_OBJET_MONNAIE_JETON = 'nebule/objet/monnaie/jeton';
    const REFERENCE_NEBULE_OBJET_MONNAIE_SAC = 'nebule/objet/monnaie/sac';
    const REFERENCE_NEBULE_OBJET_MONNAIE_PORTEFEUILLE = 'nebule/objet/monnaie/portefeuille';
    const REFERENCE_NEBULE_OBJET_MONNAIE_TRANSACTION = 'nebule/objet/monnaie/transaction';
    const REFERENCE_NEBULE_OPTION = 'nebule/option';
    const REFERENCE_NEBULE_DANGER = 'nebule/danger';
    const REFERENCE_NEBULE_WARNING = 'nebule/warning';
    const REFERENCE_NEBULE_REFERENCE = 'nebule/reference';

    const ACTIVE_APPLICATIONS_WHITELIST = array(
        '2121510000000000006e6562756c65206170706c69636174696f6e73000000000000212151.non.296',
    );

    /**
     * Liste des objets à usage réservé.
     */
    static public $RESERVED_OBJECTS_LIST = array(
        'nebule/objet',
        'nebule/objet/hash',
        'nebule/objet/homomorphe',
        'nebule/objet/type',
        'nebule/objet/localisation',
        'nebule/objet/taille',
        'nebule/objet/prenom',
        'nebule/objet/nom',
        'nebule/objet/surnom',
        'nebule/objet/prefix',
        'nebule/objet/suffix',
        'nebule/objet/lien',
        'nebule/objet/date',
        'nebule/objet/date/annee',
        'nebule/objet/date/mois',
        'nebule/objet/date/jour',
        'nebule/objet/date/heure',
        'nebule/objet/date/minute',
        'nebule/objet/date/seconde',
        'nebule/objet/date/zone',
        'nebule/objet/entite',
        'nebule/objet/entite/type',
        'nebule/objet/entite/localisation',
        'nebule/objet/entite/suivi',
        'nebule/objet/entite/suivi/seconde',
        'nebule/objet/entite/suivi/minute',
        'nebule/objet/entite/suivi/heure',
        'nebule/objet/entite/suivi/jour',
        'nebule/objet/entite/suivi/mois',
        'nebule/objet/entite/suivi/annee',
        'nebule/objet/entite/maitre',
        'nebule/objet/entite/maitre/securite',
        'nebule/objet/entite/maitre/code',
        'nebule/objet/entite/maitre/annuaire',
        'nebule/objet/entite/maitre/temps',
        'nebule/objet/entite/autorite/locale',
        'nebule/objet/entite/recouvrement',
        'nebule/objet/interface/web/php/bootstrap',
        'nebule/objet/interface/web/php/bibliotheque',
        'nebule/objet/interface/web/php/applications',
        'nebule/objet/interface/web/php/applications/direct',
        'nebule/objet/interface/web/php/applications/active',
        'nebule/objet/interface/web/php/applications/modules',
        'nebule/objet/interface/web/php/applications/modules/active',
        'nebule/objet/noeud',
        'nebule/objet/image/reference',
        'nebule/objet/emotion',
        'nebule/objet/emotion/joie',
        'nebule/objet/emotion/confiance',
        'nebule/objet/emotion/peur',
        'nebule/objet/emotion/surprise',
        'nebule/objet/emotion/tristesse',
        'nebule/objet/emotion/degout',
        'nebule/objet/emotion/colere',
        'nebule/objet/emotion/interet',
        'nebule/objet/groupe',
        'nebule/objet/groupe/suivi',
        'nebule/objet/groupe/ferme',
        'nebule/objet/groupe/protege',
        'nebule/objet/groupe/dissimule',
        'nebule/objet/conversation',
        'nebule/objet/conversation/suivie',
        'nebule/objet/conversation/fermee',
        'nebule/objet/conversation/protegee',
        'nebule/objet/conversation/dissimulee',
        'nebule/objet/arborescence',
        'nebule/objet/monnaie',
        'nebule/objet/monnaie/jeton',
        'nebule/objet/monnaie/sac',
        'nebule/objet/monnaie/portefeuille',
        'nebule/objet/monnaie/transaction',
        'nebule/option',
        'nebule/danger',
        'nebule/warning',
        'nebule/reference',
    );

    // Définition des variables.
    /**
     * Auto-référence de l'instance de la bibliothèque nebule.
     *
     * @var nebule
     */
    private $_nebuleInstance;

    /**
     * Instance des entrées/sorties.
     *
     * @var ioInterface
     */
    private $_io;

    /**
     * Instance de gestion de la cryptographie.
     *
     * @var CryptoInterface
     */
    private $_crypto;

    /**
     * Instance de gestion des relations sociales des liens.
     *
     * @var SocialInterface
     */
    private $_social;

    /**
     * Instance de gestion de la métrologie, des journaux et des statistiques internes.
     *
     * @var Metrology
     */
    private $_metrology;

    private $_ioDefaultPrefix = '';

    /**
     * Le tableau de mise en cache des liens.
     *
     * @var array
     */
    private $_cacheLinks = array();

    /**
     * Le tableau de mise en cache des objets.
     *
     * @var array
     */
    private $_cacheObjects = array();

    /**
     * Le tableau de mise en cache des entités.
     *
     * @var array
     */
    private $_cacheEntities = array();

    /**
     * Le tableau de mise en cache des groupes.
     *
     * @var array
     */
    private $_cacheGroups = array();

    /**
     * Le tableau de mise en cache des conversations.
     *
     * @var array
     */
    private $_cacheConversations = array();

    /**
     * Le tableau de mise en cache des monnaies.
     *
     * @var array
     */
    private $_cacheCurrencies = array();

    /**
     * Le tableau de mise en cache des sacs de jetons.
     *
     * @var array
     */
    private $_cacheTokenPools = array();

    /**
     * Le tableau de mise en cache des jetons.
     *
     * @var array
     */
    private $_cacheTokens = array();

    /**
     * Le tableau de mise en cache des portefeuille.
     *
     * @var array
     */
    private $_cacheWallets = array();

    /**
     * Le tableau de mise en cache des transactions.
     *
     * @var array
     */
    private $_cacheTransactions = array();

    /**
     * Le tableau de mémorisation de la date de mise en cache des objets/entités/groupes/conversations/liens.
     *
     * @var array
     */
    private $_cacheDateInsertion = array();

    /**
     * Taille du cache.
     *
     * @var double
     */
    private $_sessionBufferLimit = self::DEFAULT_SESSION_BUFFER_SIZE;

    private $_flushCache = false;

    /**
     * Marque la fin de l'initialisation.
     * C'est nécessaire pour certaines parties qui nécessitent l'accès à la journalisation mais trop tôt.
     * C'est le cas dans la lecture des options dans les liens.
     *
     * @var boolean
     */
    private $_permitOptionsByLinks = false;


    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;

        // S'auto-référence pour être capable de se transmettre aux objets.
        $this->_nebuleInstance = $this;
        $nebuleInstance = $this;

        // Détecte le mode rescue.
        $this->_findModeRescue();

        // Vérifie le minimum vital.
        if (!$this->_nebuleCheckEnvironment()) {
            $this->_nebuleInitEnvironment();
        }

        // Initialise les IO et la crypto.
        $this->_io = new io();
        $this->_crypto = new CryptoOpenssl($this->_nebuleInstance);
        $this->_social = new Social();
        $this->_metrology = new Metrology($this->_nebuleInstance);
        $this->_ioDefaultPrefix = $this->_io->getDefaultLocalisation();

        $this->_metrology->addLog('First step init nebule instance', Metrology::LOG_LEVEL_NORMAL); // Log

        // Activation des options par liens. Vide le cache.
        $this->_permitOptionsByLinks = true;
        $this->_optionCache = array();

        // Détermine si la session utilisateur doit être effacée.
        $this->_findFlushCache();

        // Restaure les instances depuis le cache de session.
        $this->_sessionBufferLimit = $this->getOption('sessionBufferSize');
        $this->_readCacheOnSessionBuffer();

        // Vérifie le ticket. Doit être après après la détection du flush cache.
        $this->_findActionTicket();

        // Vérifie les options importantes.
        $this->_getsubordinationEntity();
        $this->_checkWriteableIO();
        $this->_checkReadOnlyOptions();

        // Recherche les entités.
        $this->_findPuppetmaster();
        $this->_findSecurityMaster();
        $this->_findCodeMaster();
        $this->_findDirectoryMaster();
        $this->_findTimeMaster();
        $this->_findLocalAuthorities();
        $this->_findInstanceEntity();
        $this->_findDefaultEntity();
        $this->_addInstanceEntityAsAuthorities();
        $this->_addDefaultEntityAsAuthorities();
        $this->_findCurrentEntity();
        $this->_addLocalAuthorities();
        $this->_findRecoveryEntities();
        $this->_addInstanceEntityAsRecovery();
        $this->_addDefaultEntityAsRecovery();

        $this->_findCurrentObjet();
        $this->_findCurrentEntityPrivateKey();
        $this->_findCurrentEntityPassword();
        $this->_findCurrentGroup();
        $this->_findCurrentConversation();
        $this->_findCurrentCurrency();
        $this->_findCurrentTokenPool();
        $this->_findCurrentToken();

        // Modifie la taille de fichier maximum dans PHP en chargement.
        $this->_changeIoUploadMaxFilesize();

        $this->_metrology->addLog('End init nebule instance', Metrology::LOG_LEVEL_DEBUG); // Log
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        $this->_saveCurrentsObjectsOnSessionBuffer();
        $this->_saveCacheOnSessionBuffer();
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return self::NEBULE_LICENCE_NAME;
    }

    public function __sleep()
    {
        // @todo
        return array('_ioDefaultPrefix',
            '_flushCache',
            //	'_optionCheckedWriteableIO',
            //	'_referenceObjectConversation',
            //	'_referenceObjectConversationClosed',
            //	'_referenceObjectConversationProtected',
            //	'_referenceObjectConversationObfuscated',
        );
    }

    public function __wakeup()
    {
        global $nebuleInstance;

        // S'auto-référence pour être capable de se transmettre aux objets.
        $this->_nebuleInstance = $this;
        $nebuleInstance = $this;

        // Détecte le mode rescue.
        $this->_findModeRescue();

        // Vérifie le minimum vital.
        if (!$this->_nebuleCheckEnvironment()) {
            $this->_nebuleInitEnvironment();
        }

        // Initialise les IO et la crypto.
        $this->_io = new io();
        $this->_crypto = new CryptoOpenssl($this->_nebuleInstance);
        $this->_social = new Social();
        $this->_metrology = new Metrology($this->_nebuleInstance);
        $this->_ioDefaultPrefix = $this->_io->getDefaultLocalisation();

        $this->_metrology->addLog('First step init nebule instance', Metrology::LOG_LEVEL_NORMAL); // Log

        // Activation des options par liens. Vide le cache.
        $this->_permitOptionsByLinks = true;
        $this->_optionCache = array();

        // Détermine si la session utilisateur doit être effacée.
        $this->_findFlushCache();

        // Restaure les instances depuis le cache de session.
        $this->_sessionBufferLimit = $this->getOption('sessionBufferSize');
        $this->_readCacheOnSessionBuffer();

        // Vérifie le ticket. Doit être après la détection du flush cache.
        $this->_findActionTicket();

        // Vérifie les options importantes.
        $this->_getsubordinationEntity();
        $this->_checkWriteableIO();
        //$this->_checkReadOnlyOptions();

        // Recherche les entités.
        $this->_findPuppetmaster();
        $this->_findSecurityMaster();
        $this->_findCodeMaster();
        $this->_findDirectoryMaster();
        $this->_findTimeMaster();
        $this->_findLocalAuthorities();
        $this->_findInstanceEntity();
        $this->_findDefaultEntity();
        $this->_addInstanceEntityAsAuthorities();
        $this->_addDefaultEntityAsAuthorities();
        $this->_findCurrentEntity();
        $this->_addLocalAuthorities();
        $this->_findRecoveryEntities();
        $this->_addInstanceEntityAsRecovery();
        $this->_addDefaultEntityAsRecovery();

        $this->_findCurrentObjet();
        $this->_findCurrentEntityPrivateKey();
        $this->_findCurrentEntityPassword();
        $this->_findCurrentGroup();
        $this->_findCurrentConversation();
        $this->_findCurrentCurrency();
        $this->_findCurrentTokenPool();
        $this->_findCurrentToken();

        // Modifie la taille de fichier maximum dans PHP en chargement.
        $this->_changeIoUploadMaxFilesize();

        $this->_metrology->addLog('End init nebule instance', Metrology::LOG_LEVEL_DEBUG); // Log
    }


    /**
     * Liste des noms des options.
     *
     * @var array:string
     */
    private static $_listOptions = array(
        'puppetmaster',
        'hostURL',
        'permitWrite',
        'permitWriteObject',
        'permitCreateObject',
        'permitSynchronizeObject',
        'permitProtectedObject',
        'permitWriteLink',
        'permitCreateLink',
        'permitSynchronizeLink',
        'permitUploadLink',
        'permitPublicUploadLink',
        'permitPublicUploadCodeAuthoritiesLink',
        'permitObfuscatedLink',
        'permitWriteEntity',
        'permitPublicCreateEntity',
        'permitWriteGroup',
        'permitWriteConversation',
        'permitCurrency',
        'permitWriteCurrency',
        'permitCreateCurrency',
        'permitWriteTransaction',
        'permitObfuscatedTransaction',
        'permitSynchronizeApplication',
        'permitPublicSynchronizeApplication',
        'permitDeleteObjectOnUnknownHash',
        'permitCheckSignOnVerify',
        'permitCheckSignOnList',
        'permitCheckObjectHash',
        'permitListInvalidLinks',
        'permitHistoryLinksSign',
        'permitInstanceEntityAsAuthority',
        'permitDefaultEntityAsAuthority',
        'permitLocalSecondaryAuthorities',
        'permitRecoveryEntities',
        'permitRecoveryRemoveEntity',
        'permitInstanceEntityAsRecovery',
        'permitDefaultEntityAsRecovery',
        'permitAddLinkToSigner',
        'permitListOtherHash',
        'permitLocalisationStats',
        'permitFollowUpdates',
        'permitOnlineRescue',
        'permitLogs',
        'permitJavaScript',
        'logsLevel',
        'modeRescue',
        'cryptoLibrary',
        'cryptoHashAlgorithm',
        'cryptoSymetricAlgorithm',
        'cryptoAsymetricAlgorithm',
        'socialLibrary',
        'ioLibrary',
        'ioReadMaxLinks',
        'ioReadMaxData',
        'ioReadMaxUpload',
        'ioTimeout',
        'displayUnsecureURL',
        'displayNameSize',
        'displayEmotions',
        'forceDisplayEntityOnTitle',
        'maxFollowedUpdates',
        'permitSessionOptions',
        'permitSessionBuffer',
        'permitBufferIO', //  TODO Need to be used on the library in side of permitSessionBuffer...
        'sessionBufferSize',
        'defaultCurrentEntity',
        'defaultApplication',
        'defaultObfuscateLinks',
        'defaultLinksVersion',
        'subordinationEntity',
    );

    /**
     * Liste des catégories de tri des options.
     *
     * @var array:string
     */
    private static $_listCategoriesOptions = array(
        'Global',
        'Objects',
        'Links',
        'Entities',
        'Groups',
        'Conversations',
        'Currencies',
        'Applications',
        'Logs',
        'Cryptography',
        'I/O',
        'Social',
        'Display',
    );

    /**
     * Liste de catégorisation des options.
     *
     * Les types supportés :
     * - string
     * - boolean
     * - integer
     *
     * @var array:string
     */
    private static $_listOptionsCategory = array(
        'puppetmaster' => 'Global',
        'hostURL' => 'Global',
        'permitWrite' => 'Global',
        'permitWriteObject' => 'Objects',
        'permitCreateObject' => 'Objects',
        'permitSynchronizeObject' => 'Objects',
        'permitProtectedObject' => 'Objects',
        'permitWriteLink' => 'Links',
        'permitCreateLink' => 'Links',
        'permitSynchronizeLink' => 'Links',
        'permitUploadLink' => 'Links',
        'permitPublicUploadLink' => 'Links',
        'permitPublicUploadCodeAuthoritiesLink' => 'Links',
        'permitObfuscatedLink' => 'Links',
        'permitWriteEntity' => 'Entities',
        'permitPublicCreateEntity' => 'Entities',
        'permitWriteGroup' => 'Groups',
        'permitWriteConversation' => 'Conversations',
        'permitCurrency' => 'Currencies',
        'permitWriteCurrency' => 'Currencies',
        'permitCreateCurrency' => 'Currencies',
        'permitWriteTransaction' => 'Currencies',
        'permitObfuscatedTransaction' => 'Currencies',
        'permitSynchronizeApplication' => 'Applications',
        'permitPublicSynchronizeApplication' => 'Applications',
        'permitDeleteObjectOnUnknownHash' => 'Objects',
        'permitCheckSignOnVerify' => 'Links',
        'permitCheckSignOnList' => 'Links',
        'permitCheckObjectHash' => 'Objects',
        'permitListInvalidLinks' => 'Links',
        'permitHistoryLinksSign' => 'Links',
        'permitInstanceEntityAsAuthority' => 'Entities',
        'permitDefaultEntityAsAuthority' => 'Entities',
        'permitLocalSecondaryAuthorities' => 'Entities',
        'permitRecoveryEntities' => 'Entities',
        'permitRecoveryRemoveEntity' => 'Entities',
        'permitInstanceEntityAsRecovery' => 'Entities',
        'permitDefaultEntityAsRecovery' => 'Entities',
        'permitAddLinkToSigner' => 'Links',
        'permitListOtherHash' => 'Links',
        'permitLocalisationStats' => 'Global',
        'permitFollowUpdates' => 'Links',
        'permitOnlineRescue' => 'Global',
        'permitLogs' => 'Logs',
        'permitJavaScript' => 'Display',
        'logsLevel' => 'Logs',
        'modeRescue' => 'Global',
        'cryptoLibrary' => 'Cryptography',
        'cryptoHashAlgorithm' => 'Cryptography',
        'cryptoSymetricAlgorithm' => 'Cryptography',
        'cryptoAsymetricAlgorithm' => 'Cryptography',
        'socialLibrary' => 'Social',
        'ioLibrary' => 'I/O',
        'ioReadMaxLinks' => 'I/O',
        'ioReadMaxData' => 'I/O',
        'ioReadMaxUpload' => 'I/O',
        'ioTimeout' => 'I/O',
        'displayUnsecureURL' => 'Display',
        'displayNameSize' => 'Display',
        'displayEmotions' => 'Display',
        'forceDisplayEntityOnTitle' => 'Display',
        'maxFollowedUpdates' => 'Links',
        'permitSessionOptions' => 'I/O',
        'permitSessionBuffer' => 'I/O',
        'permitBufferIO' => 'I/O',
        'sessionBufferSize' => 'I/O',
        'defaultCurrentEntity' => 'Entities',
        'defaultApplication' => 'Applications',
        'defaultObfuscateLinks' => 'Links',
        'defaultLinksVersion' => 'Links',
        'subordinationEntity' => 'Global',
    );

    /**
     * Liste des types des options.
     *
     * Les types supportés :
     * - string
     * - boolean
     * - integer
     *
     * @var array:string
     */
    private static $_listOptionsType = array(
        'puppetmaster' => 'string',
        'hostURL' => 'string',
        'permitWrite' => 'boolean',
        'permitWriteObject' => 'boolean',
        'permitCreateObject' => 'boolean',
        'permitSynchronizeObject' => 'boolean',
        'permitProtectedObject' => 'boolean',
        'permitWriteLink' => 'boolean',
        'permitCreateLink' => 'boolean',
        'permitSynchronizeLink' => 'boolean',
        'permitUploadLink' => 'boolean',
        'permitPublicUploadLink' => 'boolean',
        'permitPublicUploadCodeAuthoritiesLink' => 'boolean',
        'permitObfuscatedLink' => 'boolean',
        'permitWriteEntity' => 'boolean',
        'permitPublicCreateEntity' => 'boolean',
        'permitWriteGroup' => 'boolean',
        'permitWriteConversation' => 'boolean',
        'permitCurrency' => 'boolean',
        'permitWriteCurrency' => 'boolean',
        'permitCreateCurrency' => 'boolean',
        'permitWriteTransaction' => 'boolean',
        'permitObfuscatedTransaction' => 'boolean',
        'permitSynchronizeApplication' => 'boolean',
        'permitPublicSynchronizeApplication' => 'boolean',
        'permitDeleteObjectOnUnknownHash' => 'boolean',
        'permitCheckSignOnVerify' => 'boolean',
        'permitCheckSignOnList' => 'boolean',
        'permitCheckObjectHash' => 'boolean',
        'permitListInvalidLinks' => 'boolean',
        'permitHistoryLinksSign' => 'boolean',
        'permitInstanceEntityAsAuthority' => 'boolean',
        'permitDefaultEntityAsAuthority' => 'boolean',
        'permitLocalSecondaryAuthorities' => 'boolean',
        'permitRecoveryEntities' => 'boolean',
        'permitRecoveryRemoveEntity' => 'boolean',
        'permitInstanceEntityAsRecovery' => 'boolean',
        'permitDefaultEntityAsRecovery' => 'boolean',
        'permitAddLinkToSigner' => 'boolean',
        'permitListOtherHash' => 'boolean',
        'permitLocalisationStats' => 'boolean',
        'permitFollowUpdates' => 'boolean',
        'permitOnlineRescue' => 'boolean',
        'permitLogs' => 'boolean',
        'permitJavaScript' => 'boolean',
        'logsLevel' => 'string',
        'modeRescue' => 'boolean',
        'cryptoLibrary' => 'string',
        'cryptoHashAlgorithm' => 'string',
        'cryptoSymetricAlgorithm' => 'string',
        'cryptoAsymetricAlgorithm' => 'string',
        'socialLibrary' => 'string',
        'ioLibrary' => 'string',
        'ioReadMaxLinks' => 'integer',
        'ioReadMaxData' => 'integer',
        'ioReadMaxUpload' => 'integer',
        'ioTimeout' => 'integer',
        'displayUnsecureURL' => 'boolean',
        'displayNameSize' => 'integer',
        'displayEmotions' => 'boolean',
        'forceDisplayEntityOnTitle' => 'boolean',
        'maxFollowedUpdates' => 'integer',
        'permitSessionOptions' => 'boolean',
        'permitSessionBuffer' => 'boolean',
        'permitBufferIO' => 'boolean',
        'sessionBufferSize' => 'integer',
        'defaultCurrentEntity' => 'string',
        'defaultApplication' => 'string',
        'defaultObfuscateLinks' => 'boolean',
        'defaultLinksVersion' => 'string',
        'subordinationEntity' => 'string',
    );

    /**
     * Liste des options qui sont modifiables.
     * Les options non modifiables peuvent cependant être forcées dans le fichier d'environnement.
     *
     * @var array:boolean
     */
    private static $_listOptionsWritable = array(
        'puppetmaster' => false,
        'hostURL' => true,
        'permitWrite' => false,
        'permitWriteObject' => true,
        'permitCreateObject' => true,
        'permitSynchronizeObject' => true,
        'permitProtectedObject' => true,
        'permitWriteLink' => true,
        'permitCreateLink' => true,
        'permitSynchronizeLink' => true,
        'permitUploadLink' => true,
        'permitPublicUploadLink' => true,
        'permitPublicUploadCodeAuthoritiesLink' => true,
        'permitObfuscatedLink' => true,
        'permitWriteEntity' => true,
        'permitPublicCreateEntity' => true,
        'permitWriteGroup' => true,
        'permitWriteConversation' => true,
        'permitCurrency' => true,
        'permitWriteCurrency' => true,
        'permitCreateCurrency' => true,
        'permitWriteTransaction' => true,
        'permitObfuscatedTransaction' => true,
        'permitSynchronizeApplication' => true,
        'permitPublicSynchronizeApplication' => true,
        'permitDeleteObjectOnUnknownHash' => false,
        'permitCheckSignOnVerify' => false,
        'permitCheckSignOnList' => true,
        'permitCheckObjectHash' => false,
        'permitListInvalidLinks' => false,
        'permitHistoryLinksSign' => true,
        'permitInstanceEntityAsAuthority' => false,
        'permitDefaultEntityAsAuthority' => false,
        'permitLocalSecondaryAuthorities' => true, // @todo à voir...
        'permitRecoveryEntities' => false,
        'permitRecoveryRemoveEntity' => false,
        'permitInstanceEntityAsRecovery' => false,
        'permitDefaultEntityAsRecovery' => false,
        'permitAddLinkToSigner' => true,
        'permitListOtherHash' => true,
        'permitLocalisationStats' => true,
        'permitFollowUpdates' => true,
        'permitOnlineRescue' => true,
        'permitLogs' => true,
        'permitJavaScript' => false,
        'logsLevel' => true,
        'modeRescue' => false,
        'cryptoLibrary' => true,
        'cryptoHashAlgorithm' => true,
        'cryptoSymetricAlgorithm' => true,
        'cryptoAsymetricAlgorithm' => true,
        'socialLibrary' => true,
        'ioLibrary' => true,
        'ioReadMaxLinks' => true,
        'ioReadMaxData' => true,
        'ioReadMaxUpload' => true,
        'ioTimeout' => true,
        'displayUnsecureURL' => false,
        'displayNameSize' => true,
        'displayEmotions' => true,
        'forceDisplayEntityOnTitle' => true,
        'maxFollowedUpdates' => true,
        'permitSessionOptions' => true,
        'permitSessionBuffer' => true,
        'permitBufferIO' => true,
        'sessionBufferSize' => true,
        'defaultCurrentEntity' => true,
        'defaultApplication' => true,
        'defaultObfuscateLinks' => true,
        'defaultLinksVersion' => true,
        'subordinationEntity' => false,
    );

    /**
     * Liste des valeurs par défaut des options.
     *
     * @var array:string|boolean|integer
     */
    private static $_listOptionsDefaultValue = array(
        'puppetmaster' => nebule::DEFAULT_PUPPETMASTER,
        'hostURL' => nebule::DEFAULT_HOST_URL,
        'permitWrite' => nebule::DEFAULT_PERMIT_WRITE,
        'permitWriteObject' => nebule::DEFAULT_PERMIT_WRITE_OBJECT,
        'permitCreateObject' => nebule::DEFAULT_PERMIT_CREATE_OBJECT,
        'permitSynchronizeObject' => nebule::DEFAULT_PERMIT_SYNCHRONIZE_OBJECT,
        'permitProtectedObject' => nebule::DEFAULT_PERMIT_PROTECTED_OBJECT,
        'permitWriteLink' => nebule::DEFAULT_PERMIT_WRITE_LINK,
        'permitCreateLink' => nebule::DEFAULT_PERMIT_CREATE_LINK,
        'permitSynchronizeLink' => nebule::DEFAULT_PERMIT_SYNCHRONIZE_LINK,
        'permitUploadLink' => nebule::DEFAULT_PERMIT_UPLOAD_LINK,
        'permitPublicUploadLink' => nebule::DEFAULT_PERMIT_PUBLIC_UPLOAD_LINK,
        'permitPublicUploadCodeAuthoritiesLink' => nebule::DEFAULT_PERMIT_PUBLIC_UPLOAD_CODE_MASTER_LINK,
        'permitObfuscatedLink' => nebule::DEFAULT_PERMIT_OBFUSCATED_LINK,
        'permitWriteEntity' => nebule::DEFAULT_PERMIT_WRITE_ENTITY,
        'permitPublicCreateEntity' => nebule::DEFAULT_PERMIT_PUBLIC_CREATE_ENTITY,
        'permitWriteGroup' => nebule::DEFAULT_PERMIT_WRITE_GROUP,
        'permitWriteConversation' => nebule::DEFAULT_PERMIT_WRITE_CONVERSATION,
        'permitCurrency' => nebule::DEFAULT_PERMIT_CURRENCY,
        'permitWriteCurrency' => nebule::DEFAULT_PERMIT_WRITE_CURRENCY,
        'permitCreateCurrency' => nebule::DEFAULT_PERMIT_CREATE_CURRENCY,
        'permitWriteTransaction' => nebule::DEFAULT_PERMIT_WRITE_TRANSACTION,
        'permitObfuscatedTransaction' => nebule::DEFAULT_PERMIT_OBFUSCATED_TRANSACTION,
        'permitSynchronizeApplication' => nebule::DEFAULT_PERMIT_SYNCHRONIZE_APPLICATIONS,
        'permitPublicSynchronizeApplication' => nebule::DEFAULT_PERMIT_PUBLIC_SYNCHRONIZE_APPLICATIONS,
        'permitDeleteObjectOnUnknownHash' => nebule::DEFAULT_PERMIT_DELETE_OBJECT_ON_UNKNOW_HASH,
        'permitCheckSignOnVerify' => nebule::DEFAULT_PERMIT_CHECK_SIGN_ON_VERIFY,
        'permitCheckSignOnList' => nebule::DEFAULT_PERMIT_CHECK_SIGN_ON_LIST,
        'permitCheckObjectHash' => nebule::DEFAULT_PERMIT_CHECK_OBJECT_HASH,
        'permitListInvalidLinks' => nebule::DEFAULT_PERMIT_LIST_INVALID_LINKS,
        'permitHistoryLinksSign' => nebule::DEFAULT_PERMIT_HISTORY_LINKS_SIGN,
        'permitInstanceEntityAsAuthority' => nebule::DEFAULT_PERMIT_INSTANCE_ENTITY_AS_AUTHORITY,
        'permitDefaultEntityAsAuthority' => nebule::DEFAULT_PERMIT_DEFAULT_ENTITY_AS_AUTHORITY,
        'permitLocalSecondaryAuthorities' => nebule::DEFAULT_PERMIT_LOCAL_SECONDARY_AUTHORITY,
        'permitRecoveryEntities' => nebule::DEFAULT_PERMIT_RECOVERY_ENTITIES,
        'permitRecoveryRemoveEntity' => nebule::DEFAULT_PERMIT_RECOVERY_REMOVE_ENTITY,
        'permitInstanceEntityAsRecovery' => nebule::DEFAULT_PERMIT_INSTANCE_ENTITY_AS_RECOVERY,
        'permitDefaultEntityAsRecovery' => nebule::DEFAULT_PERMIT_DEFAULT_ENTITY_AS_RECOVERY,
        'permitAddLinkToSigner' => nebule::DEFAULT_PERMIT_ADD_LINK_TO_SIGNER,
        'permitListOtherHash' => nebule::DEFAULT_PERMIT_LIST_OTHER_HASH,
        'permitLocalisationStats' => nebule::DEFAULT_PERMIT_LOCALISATION_STATS,
        'permitFollowUpdates' => nebule::DEFAULT_PERMIT_FOLLOW_UPDATES,
        'permitOnlineRescue' => nebule::DEFAULT_PERMIT_ONLINE_RESCUE,
        'permitLogs' => nebule::DEFAULT_PERMIT_LOGS,
        'permitJavaScript' => nebule::DEFAULT_PERMIT_JAVASCRIPT,
        'logsLevel' => nebule::DEFAULT_LOGS_LEVEL,
        'modeRescue' => nebule::DEFAULT_MODE_RESCUE,
        'cryptoLibrary' => nebule::DEFAULT_CRYPTO_LIBRARY,
        'cryptoHashAlgorithm' => nebule::DEFAULT_CRYPTO_HASH_ALGORITHM,
        'cryptoSymetricAlgorithm' => nebule::DEFAULT_CRYPTO_SYMETRIC_ALGORITHM,
        'cryptoAsymetricAlgorithm' => nebule::DEFAULT_CRYPTO_ASYMETRIC_ALGORITHM,
        'socialLibrary' => nebule::DEFAULT_SOCIAL_LIBRARY,
        'ioLibrary' => nebule::DEFAULT_IO,
        'ioReadMaxLinks' => nebule::DEFAULT_IO_READ_MAX_LINKS,
        'ioReadMaxData' => nebule::DEFAULT_IO_READ_MAX_DATA,
        'ioReadMaxUpload' => nebule::DEFAULT_IO_READ_MAX_UPLOAD,
        'ioTimeout' => nebule::DEFAULT_IO_TIMEOUT,
        'displayUnsecureURL' => nebule::DEFAULT_DISPLAY_UNSECURE_URL,
        'displayNameSize' => nebule::DEFAULT_DISPLAY_NAME_SIZE,
        'displayEmotions' => nebule::DEFAULT_DISPLAY_EMOTIONS,
        'forceDisplayEntityOnTitle' => nebule::DEFAULT_FORCE_DISPLAY_ENTITY_ON_TITLE,
        'maxFollowedUpdates' => nebule::DEFAULT_MAX_FOLLOWED_UPDATES,
        'permitSessionOptions' => nebule::DEFAULT_PERMIT_SESSION_OPTIONS,
        'permitSessionBuffer' => nebule::DEFAULT_PERMIT_SESSION_BUFFER,
        'permitBufferIO' => nebule::DEFAULT_PERMIT_BUFFER_IO,
        'sessionBufferSize' => nebule::DEFAULT_SESSION_BUFFER_SIZE,
        'defaultCurrentEntity' => nebule::DEFAULT_PUPPETMASTER,
        'defaultApplication' => nebule::DEFAULT_APPLICATION,
        'defaultObfuscateLinks' => nebule::DEFAULT_OBFUSCATE_LINKS,
        'defaultLinksVersion' => nebule::DEFAULT_LINKS_VERSION,
        'subordinationEntity' => nebule::DEFAULT_SUBORDINATION_TO_ENTITY,
    );

    /**
     * Liste de la criticité des options.
     *
     * @var array:string
     */
    private static $_listOptionsCriticality = array(
        'puppetmaster' => 'critical',
        'hostURL' => 'useful',
        'permitWrite' => 'useful',
        'permitWriteObject' => 'useful',
        'permitCreateObject' => 'useful',
        'permitSynchronizeObject' => 'useful',
        'permitProtectedObject' => 'useful',
        'permitWriteLink' => 'useful',
        'permitCreateLink' => 'useful',
        'permitSynchronizeLink' => 'useful',
        'permitUploadLink' => 'careful',
        'permitPublicUploadLink' => 'careful',
        'permitPublicUploadCodeAuthoritiesLink' => 'useful',
        'permitObfuscatedLink' => 'useful',
        'permitWriteEntity' => 'useful',
        'permitPublicCreateEntity' => 'critical',
        'permitWriteGroup' => 'useful',
        'permitWriteConversation' => 'useful',
        'permitCurrency' => 'useful',
        'permitWriteCurrency' => 'useful',
        'permitCreateCurrency' => 'useful',
        'permitWriteTransaction' => 'useful',
        'permitObfuscatedTransaction' => 'careful',
        'permitSynchronizeApplication' => 'careful',
        'permitPublicSynchronizeApplication' => 'careful',
        'permitDeleteObjectOnUnknownHash' => 'critical',
        'permitCheckSignOnVerify' => 'critical',
        'permitCheckSignOnList' => 'critical',
        'permitCheckObjectHash' => 'critical',
        'permitListInvalidLinks' => 'critical',
        'permitHistoryLinksSign' => 'useful',
        'permitInstanceEntityAsAuthority' => 'careful',
        'permitDefaultEntityAsAuthority' => 'careful',
        'permitLocalSecondaryAuthorities' => 'careful',
        'permitRecoveryEntities' => 'critical',
        'permitRecoveryRemoveEntity' => 'careful',
        'permitInstanceEntityAsRecovery' => 'critical',
        'permitDefaultEntityAsRecovery' => 'critical',
        'permitAddLinkToSigner' => 'useful',
        'permitListOtherHash' => 'useful',
        'permitLocalisationStats' => 'useful',
        'permitFollowUpdates' => 'useful',
        'permitOnlineRescue' => 'careful',
        'permitLogs' => 'useful',
        'permitJavaScript' => 'careful',
        'logsLevel' => 'useful',
        'modeRescue' => 'critical',
        'cryptoLibrary' => 'careful',
        'cryptoHashAlgorithm' => 'careful',
        'cryptoSymetricAlgorithm' => 'careful',
        'cryptoAsymetricAlgorithm' => 'careful',
        'socialLibrary' => 'careful',
        'ioLibrary' => 'careful',
        'ioReadMaxLinks' => 'useful',
        'ioReadMaxData' => 'useful',
        'ioReadMaxUpload' => 'useful',
        'ioTimeout' => 'useful',
        'displayUnsecureURL' => 'critical',
        'displayNameSize' => 'useful',
        'displayEmotions' => 'useful',
        'forceDisplayEntityOnTitle' => 'useful',
        'maxFollowedUpdates' => 'useful',
        'permitSessionOptions' => 'careful',
        'permitSessionBuffer' => 'careful',
        'permitBufferIO' => 'careful',
        'sessionBufferSize' => 'useful',
        'defaultCurrentEntity' => 'useful',
        'defaultApplication' => 'useful',
        'defaultObfuscateLinks' => 'useful',
        'defaultLinksVersion' => 'useful',
        'subordinationEntity' => 'critical',
    );

    /**
     * Liste des descriptions des options.
     * @todo
     *
     * @var array:string
     */
    private static $_listOptionsDescription = array(
        'puppetmaster' => 'The master of all. the authority of all globals authorities.',
        'hostURL' => "The URL, domain name, of this server. This is use by others servers and others entities to find this server and it's local entities.",
        'permitWrite' => 'The big switch to write protect all the instance on this server. This switch is not an object but is on the options file.',
        'permitWriteObject' => 'The switch to permit objects writing.',
        'permitCreateObject' => 'The switch to permit creation of new objects localy.',
        'permitSynchronizeObject' => 'The switch to permit to synchronize (update) objects from other localisations.',
        'permitProtectedObject' => 'The switch to permit read/write protected objects. On false, generation of liens k for protected objects is disabled and all existing/downloaded links for protected objects are assumed as invalid and dropped.',
        'permitWriteLink' => 'The switch to permit links writing.',
        'permitCreateLink' => 'The switch to permit creation of new links localy.',
        'permitSynchronizeLink' => 'The switch to permit to synchronize links of objects from other localisations.',
        'permitUploadLink' => 'The switch to permit ask creation and sign of new links uploaded within an URL.',
        'permitPublicUploadLink' => 'The switch to permit ask upload signed links (from known entities) within an URL.',
        'permitPublicUploadCodeAuthoritiesLink' => 'The switch to permit ask upload signed links by the code master within an URL.',
        'permitObfuscatedLink' => 'The switch to permit read/write obfuscated links. On false, generation of obfuscated liens c is disabled and all existing/downloaded obfuscated links are assumed as invalid and dropped.',
        'permitWriteEntity' => 'The switch to permit entities writing.',
        'permitPublicCreateEntity' => 'The switch to permit create new entity by anyone.',
        'permitWriteGroup' => 'The switch to permit groups writing.',
        'permitWriteConversation' => 'The switch to permit conversations writing.',
        'permitCurrency' => 'The switch to permit use of currencies.',
        'permitWriteCurrency' => 'The switch to permit currencies writing.',
        'permitCreateCurrency' => 'The switch to permit currencies creation.',
        'permitWriteTransaction' => 'The switch to permit transactions writing.',
        'permitObfuscatedTransaction' => 'The switch to permit transactions on obfuscated links.',
        'permitSynchronizeApplication' => 'The switch to permit to synchronize (update) applications from other localisations.',
        'permitPublicSynchronizeApplication' => 'The switch to permit to synchronize (update) applications by anyone from other localisations.',
        'permitDeleteObjectOnUnknownHash' => 'Permit erasing object if not valid hash type can be found.',
        'permitCheckSignOnVerify' => 'Todo description...',
        'permitCheckSignOnList' => 'Todo description...',
        'permitCheckObjectHash' => 'Todo description...',
        'permitListInvalidLinks' => 'Todo description...',
        'permitHistoryLinksSign' => 'Todo description...',
        'permitInstanceEntityAsAuthority' => 'Declare instance entity of this server as local authority.',
        'permitDefaultEntityAsAuthority' => 'Declare default entity on this server as local authority.',
        'permitLocalSecondaryAuthorities' => 'Todo description...',
        'permitRecoveryEntities' => 'Activate the recovery process. Local recovery entities are listed and new protection of objects are automaticaly shared with recovery entities.',
        'permitRecoveryRemoveEntity' => 'An entity can remove shared protection to recovery entity. By default, it is not permited.',
        'permitInstanceEntityAsRecovery' => 'Declare instance entity of this server as recovery entity.',
        'permitDefaultEntityAsRecovery' => 'Declare default entity on this server as recovery entity.',
        'permitAddLinkToSigner' => 'Todo description...',
        'permitListOtherHash' => 'Todo description...',
        'permitLocalisationStats' => 'Todo description...',
        'permitFollowUpdates' => 'Todo description...',
        'permitOnlineRescue' => 'Todo description...',
        'permitLogs' => 'Activate more logs (syslog) on internal process.',
        'permitJavaScript' => 'Activate by default JavaScript (JS) on web pages.',
        'logsLevel' => 'Select verbosity of logs. Select on NORMAL, ERROR, FUNCTION and DEBUG.',
        'modeRescue' => 'Activate the rescue mode. Follow only links from globals authorities for applications detection.',
        'cryptoLibrary' => 'Define the default cryptographic library used.',
        'cryptoHashAlgorithm' => 'Define the default cryptographic hash algorythm used.',
        'cryptoSymetricAlgorithm' => 'Define the default cryptographic symetric algorythm used.',
        'cryptoAsymetricAlgorithm' => 'Define the default cryptographic asymetric algorythm used.',
        'socialLibrary' => 'Todo description...',
        'ioLibrary' => 'Todo description...',
        'ioReadMaxLinks' => 'Maximum number of links readable in one time for one object.',
        'ioReadMaxData' => 'Maximum quantity of bytes readable in one time from one object file content.',
        'ioReadMaxUpload' => 'Maximum file size on upload. Overload default value upload_max_filesize on php.ini file.',
        'ioTimeout' => 'Todo description...',
        'displayUnsecureURL' => 'Display a warning message if the connexion link is not protected (https : HTTP overs TLS).',
        'displayNameSize' => 'The maximum displayable size of a name of objects.',
        'displayEmotions' => 'Display all emotions when asked by applications, or not.',
        'forceDisplayEntityOnTitle' => 'Force display of current selected entity on application even if is the same of current entity used on library.',
        'maxFollowedUpdates' => 'Todo description...',
        'permitSessionOptions' => 'Todo description...',
        'permitSessionBuffer' => 'Todo description...',
        'permitBufferIO' => 'Todo description...',
        'sessionBufferSize' => 'Todo description...',
        'defaultCurrentEntity' => 'Todo description...',
        'defaultApplication' => 'Todo description...',
        'defaultObfuscateLinks' => 'Todo description...',
        'defaultLinksVersion' => 'Define the version of new generated links.',
        'subordinationEntity' => 'Define the external entity which can modify writeable options on this server instance.',
    );

    /**
     * Donne la liste des noms des options disponibles.
     *
     * @return array:string
     */
    public static function getListOptions()
    {
        return self::$_listOptions;
    }

    /**
     * Donne la liste de catégories d'options.
     *
     * @return array:string
     */
    public static function getListCategoriesOptions()
    {
        return self::$_listCategoriesOptions;
    }

    /**
     * Donne la liste de catégorisation des options disponibles.
     *
     * @return array:string
     */
    public static function getListOptionsCategory()
    {
        return self::$_listOptionsCategory;
    }

    /**
     * Donne la liste des types des options disponibles.
     *
     * @return array:string
     */
    public static function getListOptionsType()
    {
        return self::$_listOptionsType;
    }

    /**
     * Donne la liste de capacité d'écriture des options disponibles.
     *
     * @return array:boolean
     */
    public static function getListOptionsWritable()
    {
        return self::$_listOptionsWritable;
    }

    /**
     * Donne la liste des valeurs par défaut des options disponibles.
     *
     * @return array:string|boolean|integer
     */
    public static function getListOptionsDefaultValue()
    {
        return self::$_listOptionsDefaultValue;
    }

    /**
     * Donne la liste de criticité des options disponibles.
     *
     * @return array:string
     */
    public static function getListOptionsCriticality()
    {
        return self::$_listOptionsCriticality;
    }

    /**
     * Donne la liste des descriptions des options disponibles.
     *
     * @return array:string
     */
    public static function getListOptionsDescription()
    {
        return self::$_listOptionsDescription;
    }

    /**
     * Le cache des options déjà lues.
     *
     * @var array
     */
    private $_optionCache = array();

    /**
     * Vérifie l'état des options importantes.
     * Ajoute aux logs en cas de divergeance à la valeur par défaut.
     *
     * @return void
     */
    private function _checkReadOnlyOptions()
    {
        $this->_metrology->addLog('Check options', Metrology::LOG_LEVEL_DEBUG); // Log

        foreach (self::$_listOptions as $option) {
            if (self::$_listOptionsCriticality[$option] == 'critical') {
                $value = $this->getOption($option);
                if ($value != self::$_listOptionsDefaultValue[$option]) {
                    if (is_bool($value)) {
                        if ($value) {
                            $value = 'true';
                        } else {
                            $value = 'false';
                        }
                    }
                    if (is_int($value)) {
                        $value = (string)$value;
                    }
                    $this->_metrology->addLog('Warning:critical_option ' . $option . '=' . $value, Metrology::LOG_LEVEL_NORMAL); // Log
                }
            }
        }
    }

    /**
     * Entité de subordination des options de l'entité en cours.
     * Par défaut vide.
     *
     * @var string
     */
    private $_subordinationEntity = '';

    /**
     * Extrait l'entité de subordination des options si présente.
     *
     * Utilise la fonction getOptionFromEnvironment() pour extraire l'option du fichier d'environnement.
     *
     * @return void
     */
    private function _getsubordinationEntity()
    {
        $this->_subordinationEntity = $this->getOptionFromEnvironment('subordinationEntity');

        if ($this->_metrology !== null) {
            $this->_metrology->addLog('Get subordination entity = ' . $this->_subordinationEntity, Metrology::LOG_LEVEL_NORMAL); // Log
        }
    }

    /**
     * Retourne l'entité de subordination si défini.
     * Rtourne une chaine vide sinon.
     *
     * @return string
     */
    public function getSubordinationEntity()
    {
        return $this->_subordinationEntity;
    }

    /**
     * Vérifie que le système d'entrée/sortie par défaut est lecture/écriture.
     * Force les options permitWrite permitWriteObject et permitWriteLink au besoin.
     *
     * @return void
     * @todo ne fonctionne pas correctement mais non blocant.
     *
     */
    private function _checkWriteableIO()
    {
        // Extrait la capacité d'IO.
        if ($this->_io->getMode() == 'RW') {
            $this->_optionCache['permitWriteObject'] = $this->_io->checkObjectsWrite();
            $this->_optionCache['permitWriteLink'] = $this->_io->checkLinksWrite();
            $this->_optionCache['permitWrite'] = $this->_optionCache['permitWriteObject'] || $this->_optionCache['permitWriteLink'];
        } else {
            $this->_optionCache['permitWriteObject'] = false;
            $this->_optionCache['permitWriteLink'] = false;
            $this->_optionCache['permitWrite'] = false;
        }

        if (!$this->_optionCache['permitWriteObject']) {
            $this->_metrology->addLog('objects ro not rw', Metrology::LOG_LEVEL_NORMAL); // Log
        }
        if (!$this->_optionCache['permitWriteLink']) {
            $this->_metrology->addLog('links ro not rw', Metrology::LOG_LEVEL_NORMAL); // Log
        }
    }

    /**
     * Cette fonction permet d'ajuster la taille des tichiers que l'on peut charger sur le serveur en fonction de l'option ioReadMaxUpload.
     * Cela me marchant pas, l'option est indicative et doit refleter la valeur de upload_max_filesize dans le fichier définissant le serveur web...
     *
     * @return void
     */
    private function _changeIoUploadMaxFilesize()
    {
        //$UploadMaxFilesize = $this->getOption('ioReadMaxUpload');

        // Connu pour ne plus fonctionner.
        //ini_set('upload_max_filesize', $UploadMaxFilesize);

        // Méthode par le fichier local de préférence.
        //file_put_contents('neb_http.ini', 'upload_max_filesize = '.$UploadMaxFilesize."\n".'post_max_size = '.$UploadMaxFilesize);
    }

    /**
     * Extrait les options nebule.
     * Retourne :
     *  - le contenu de l'option dans l'environnement ;
     *  - ou le contenu de l'option dans les liens ;
     *  - ou le contenu de l'option par défaut ;
     *  - ou false.
     *
     * La valeur trouvée dans l'environnement est prioritaire.
     * C'est la façon de forcer une option.
     *
     * @param string $name : le nom de l'option demandée.
     * @return string/boolean/integer : la valeur de l'option.
     */
    public function getOption($name)
    {
        // Vérifie le nom.
        if ($name == ''
            || !is_string($name)
            || !isset(self::$_listOptionsType[$name])
        ) {
            return false;
        }

        if ($this->_metrology !== null) {
            $this->_metrology->addLog('Get option ' . $name, Metrology::LOG_LEVEL_DEBUG); // Log
        }

        // La réponse.
        $result = null;

        // Lit le cache.
        if (isset($this->_optionCache[$name])) {
            $result = $this->_optionCache[$name];
        }

        // Cherche l'option dans l'environnement.
        if ($result === null) {
            $result = $this->getOptionFromEnvironment($name);
        }

        // Si non trouvé et si non protégée, cherche l'option dans les liens.
        if (self::$_listOptionsWritable[$name]
            && $result === null
        ) {
            $result = $this->getOptionFromLinks($name);
        }

        // Si non trouvé, cherche la valeur par défaut de l'option.
        if ($result === null) {
            $result = self::$_listOptionsDefaultValue[$name];
            if ($this->_metrology !== null) {
                $this->_metrology->addLog('Get default option ' . $name . ' = ' . (string)$result, Metrology::LOG_LEVEL_DEBUG); // Log
            }
        }

        // Si non trouvé, retourne la valeur par défaut.
        if ($result === null) {
            $result = false;
            if ($this->_metrology !== null) {
                $this->_metrology->addLog('Get unknown option ' . $name . ' = ' . (string)$result, Metrology::LOG_LEVEL_DEBUG); // Log
            }
        }

        if ($this->_metrology !== null) {
            $this->_metrology->addLog('Return option ' . $name . ' = ' . (string)$result, Metrology::LOG_LEVEL_DEBUG); // Log
        }

        // Ecrit le cache.
        if ($result !== null) {
            $this->_optionCache[$name] = $result;
        }

        return $result;
    }

    /**
     * Extrait les options du fichier d'environnement nebule : nebule.env @param string $name : le nom de l'option demandée.
     * @return string/boolean : la valeur de l'option.
     * @todo
     * Retourne :
     *  - une chaine de caractères avec le contenu de l'option _ou_ un nombre _ou_ un booléen ;
     *  - ou null si rien n'est trouvé.
     *
     * Pour les booléens, on regarde si on a l'inverse de la valeur par défaut de l'option.
     *
     * Est utilisé directement par la fonction _getsubordinationEntity() avant la lecture des options.
     *
     */
    public function getOptionFromEnvironment($name)
    {
        if ($name == ''
            || !is_string($name)
            || !isset(self::$_listOptionsType[$name])
        ) {
            return null;
        }

        // La réponse.
        $result = null;
        $value = null;

        // Lit le fichier d'environnement.
        if (file_exists(self::NEBULE_ENVIRONMENT_FILE)) {
            // Extrait un tableau avec une ligne par élément.
            $file = file(self::NEBULE_ENVIRONMENT_FILE, FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES);
            foreach ($file as $line) {
                $l = trim($line);

                // Si commentaire, passe à la ligne suivante.
                if (substr($l, 0, 1) == "#") {
                    continue;
                }

                // Recherche l'option demandée.
                if (filter_var(trim(strtok($l, '=')), FILTER_SANITIZE_STRING) == $name) {
                    $value = trim(filter_var(trim(substr($l, strpos($l, '=') + 1)), FILTER_SANITIZE_STRING));
                    break;
                }
            }
            unset($file, $line, $l);
        }

        // Si pas trouvé, quitte.
        if ($value == null) {
            return null;
        }

        // Extrait la valeur en fonction du type de l'option.
        switch (self::$_listOptionsType[$name]) {
            case 'string' :
                $result = $value;
                break;
            case 'boolean' :
                if ($value == 'true'
                    || $value == 'false'
                ) {
                    if (self::$_listOptionsDefaultValue[$name]) {
                        $reference = 'false';
                    } else {
                        $reference = 'true';
                    }

                    if ($value == $reference) {
                        $result = !self::$_listOptionsDefaultValue[$name];
                    } else {
                        $result = self::$_listOptionsDefaultValue[$name];
                    }
                } else {
                    $result = null;
                }
                break;
            case 'integer' :
                if ($value != '') {
                    $result = (int)$value;
                }
                break;
            default :
                $result = null;
        }

        if ($this->_metrology !== null) {
            $this->_metrology->addLog('Return option env = ' . (string)$result, Metrology::LOG_LEVEL_DEBUG); // Log
        }

        return $result;
    }

    /**
     * Verrouillage de la recherche d'option via les liens.
     * Anti-boucle infinie.
     *
     * @var boolean
     */
    private $_optionsByLinksIsInUse = false;

    /**
     * Extrait les options depuis les liens.
     * Retourne :
     *  - une chaine de caractères avec le contenu de l'option _ou_ un nombre _ou_ un booléen ;
     *  - ou null si rien n'est trouvé.
     *
     * Pour les booléens, on regarde si on a l'inverse de la valeur par défaut de l'option.
     *
     * @param string $name : le nom de l'option demandée.
     * @return string/null : la valeur de l'option.
     */
    public function getOptionFromLinks($name)
    {
        if ($name == ''
            || !is_string($name)
            || !isset(self::$_listOptionsType[$name])
        ) {
            return null;
        }

        // La réponse.
        $result = null;
        $value = '';

        // Extrait la valeur de l'option, lorsque disponible.
        if ($this->_permitOptionsByLinks
            && !$this->_optionsByLinksIsInUse
        ) {
            $this->_optionsByLinksIsInUse = true;

            //$instance = $this->newObject($this->_crypto->hash($name));
            //$value = trim($instance->getProperty(nebule::REFERENCE_NEBULE_OPTION));

            // Si une entité de subordination est défini, lit l'option forcée par cette entité.
            if ($this->_subordinationEntity != '') {
                $instance = $this->newEntity($this->_subordinationEntity);
                $value = trim($instance->getProperty(nebule::REFERENCE_NEBULE_OPTION . '/' . $name));
                unset($instance);
            }

            // Si aucune valeur trouvée de l'entité de subordination, lit l'option pour l'entité en cours.
            if ($value == ''
                && $this->_currentEntity != ''
            ) {
                $value = trim($this->_currentEntityInstance->getProperty(nebule::REFERENCE_NEBULE_OPTION . '/' . $name));
            }

            $this->_optionsByLinksIsInUse = false;

            // Extrait la valeur en fonction du type de l'option.
            switch (self::$_listOptionsType[$name]) {
                case 'string' :
                    if ($value != '') {
                        $result = $value;
                    }
                    break;
                case 'boolean' :
                    if ($value == 'true'
                        || $value == 'false'
                    ) {
                        if (self::$_listOptionsDefaultValue[$name]) {
                            $reference = 'false';
                        } else {
                            $reference = 'true';
                        }

                        if ($value == $reference) {
                            $result = !self::$_listOptionsDefaultValue[$name];
                        } else {
                            $result = self::$_listOptionsDefaultValue[$name];
                        }
                    } else {
                        $result = null;
                    }
                    break;
                case 'integer' :
                    if ($value != '') {
                        $result = (int)$value;
                    }
                    break;
                default :
                    $result = null;
            }
        }

        if ($this->_metrology !== null) {
            $this->_metrology->addLog('Return option links = ' . (string)$result, Metrology::LOG_LEVEL_DEBUG); // Log
        }

        return $result;
    }

    /**
     * Verrou des modifications des options dans le cache.
     * @var boolean
     */
    private $_writeOptionCacheLock = false;

    /**
     * Verrouille la possibilité de modification des options dans le cache.
     * L'opération n'est pas annulable.
     */
    public function setOptionCacheLock()
    {
        $this->_writeOptionCacheLock = true;
    }

    /**
     * Ecrit une option en cache.
     *
     * La valeur est traduite sous forme de texte au besoin.
     *
     * L'écritue en cache n'est possible que si cette possibilité n'est pas verrouillée.
     * Le bootstrap verrouille automatiquement en fin de chargement la possibilité
     *   de modification des options directement en cache.
     * Le verrouillage n'est pas annulable.
     *
     * @param string $name
     * @param string|boolean|integer $value
     * @return boolean
     */
    public function setOptionCache($name, $value)
    {
        // Vérifie le verrouillage.
        if ($this->_writeOptionCacheLock) {
            return false;
        }

        // Vérifie le nom.
        if ($name == ''
            || !is_string($name)
            || !isset(self::$_listOptionsType[$name])
            || !self::$_listOptionsWritable[$name]
        ) {
            return false;
        }

        $this->_metrology->addLog('Set option cache ' . $name, Metrology::LOG_LEVEL_DEBUG); // Log

        // Prépare la valeur.
        $writeValue = '';
        switch (self::$_listOptionsType[$name]) {
            case 'string' :
                $writeValue = $value;
                break;
            case 'boolean' :
                if ($value === true) {
                    $writeValue = 'true';
                } else {
                    $writeValue = 'false';
                }
                break;
            case 'integer' :
                $writeValue = (string)$value;
                break;
            default :
                return false;
        }

        $this->_metrology->addLog('Set option cache value = ' . $writeValue, Metrology::LOG_LEVEL_DEBUG); // Log

        // Ecrit l'option.
        $this->_optionCache[$name] = $value;
    }

    /**
     * Ecrit une option.
     * L'option est écrite sous forme de lien si elle n'est pas protégée ou forcée.
     *
     * La valeur est traduite sous forme de texte au besoin.
     *
     * La variable $entity permet de cibler une entité pour l'application de l'option... si on est entité de subordination.
     *
     * @param string $name
     * @param string|boolean|integer $value
     * @param string $entity
     * @return boolean
     */
    public function setOption($name, $value, $entity = '')
    {
        // Vérifie le nom.
        if ($name == ''
            || !is_string($name)
            || !isset(self::$_listOptionsType[$name])
            || !self::$_listOptionsWritable[$name]
            || $this->getOptionFromEnvironment($name) !== null
        ) {
            return false;
        }

        // Détermine l'entité ciblée par l'option.
        if ($entity = ''
            || $entity == '0'
        ) {
            $entity = $this->_currentEntity;
        }

        $this->_metrology->addLog('Set option ' . $name, Metrology::LOG_LEVEL_DEBUG); // Log

        // Prépare la valeur.
        $writeValue = '';
        switch (self::$_listOptionsType[$name]) {
            case 'string' :
                $writeValue = $value;
                break;
            case 'boolean' :
                if ($value === true) {
                    $writeValue = 'true';
                } else {
                    $writeValue = 'false';
                }
                break;
            case 'integer' :
                $writeValue = (string)$value;
                break;
            default :
                return false;
        }

        $this->_metrology->addLog('Set option value = ' . $writeValue, Metrology::LOG_LEVEL_DEBUG); // Log

        // Crée l'instance de l'objet de la valeur.
        $instance = new Node($this->_nebuleInstance, '0', $writeValue);
        if ($instance === false) {
            $this->_metrology->addLog("L'instance de l'objet n'a pas pu être créée.", Metrology::LOG_LEVEL_ERROR); // Log
            return false;
        }

        // Lit l'ID.
        $id = $instance->getID();
        if ($id == '0') {
            $this->_metrology->addLog("L'objet n'a pas pu être créé.", Metrology::LOG_LEVEL_ERROR); // Log
            return false;
        }

        // Création du type mime.
        $instance->setType(nebule::REFERENCE_OBJECT_TEXT);

        // Crée le lien de l'option.
        $signer = $this->_currentEntity;
        $date = date(DATE_ATOM);
        $action = 'l';
        //$source	= $this->_crypto->hash( $name );
        $source = $entity;
        $target = $id;
        //$meta	= $this->_crypto->hash(nebule::REFERENCE_NEBULE_OPTION);
        $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OPTION . '/' . $name);
        // Génère le lien.
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        // Signe le lien.
        $newLink->sign($signer);
        // Ecrit le lien.
        $ok = $newLink->write();

        if ($ok) {
            $this->_optionCache[$name] = $value;
            return true;
        } else {
            $this->_metrology->addLog('Set option write error', Metrology::LOG_LEVEL_ERROR); // Log
            return false;
        }
    }



    /*
	 * --------------------------------------------------------------------------------
	 * Gestion du stockage des options et du buffer dans la session php.
	 * --------------------------------------------------------------------------------
	 */
    /**
     * Lit la valeur d'une option dans la session php.
     * Si l'option n'est pas renseignée, retourne false.
     *
     * @param string $name
     * @return mixed
     */
    public function getSessionStore($name)
    {
        session_start();

        if ($name == ''
            || $this->_flushCache
            || !$this->getOption('permitSessionOptions')
            || !isset($_SESSION['Option'][$name])
        ) {
            session_write_close();
            return false;
        }
        $val = $_SESSION['Option'][$name];

        session_write_close();

        return $val;
    }

    /**
     * Ecrit la valeur d'une option dans la session php.
     *
     * @param string $name
     * @param mixed $content
     * @return boolean
     */
    public function setSessionStore($name, $content)
    {
        if ($name == ''
            || $this->_flushCache
            || !$this->getOption('permitSessionOptions')
        ) {
            return false;
        }

        session_start();

        $_SESSION['Option'][$name] = $content;

        session_write_close();

        return true;
    }

    /**
     * Vide les options dans la session php.
     *
     * @return boolean
     */
    private function _flushSessionStore()
    {
        $this->_metrology->addLog('Flush session store', Metrology::LOG_LEVEL_NORMAL);

        session_start();

        unset($_SESSION['Option']);

        session_write_close();

        return true;
    }

    /**
     * Lit la valeur d'un contenu mémorisé dans la session php.
     * Si le contenu mémorisé n'est pas renseigné, retourne false.
     *
     * @param string $name
     * @return mixed
     */
    private function _getSessionBuffer($name)
    {
        session_start();

        if ($name == ''
            || $this->_flushCache
            || !$this->getOption('permitSessionBuffer')
            || !isset($_SESSION['Buffer'][$name])
        ) {
            session_write_close();

            return false;
        }
        $val = unserialize($_SESSION['Buffer'][$name]);

        session_write_close();

        return $val;
    }

    /**
     * Ecrit la valeur d'un contenu mémorisé dans la session php.
     * Le nombre de contenus mémorisés n'est pas comptabilisé par cette fonction.
     *
     * @param string $name
     * @param mixed $content
     * @return boolean
     */
    private function _setSessionBuffer($name, $content)
    {
        if ($name == ''
            || $this->_flushCache
            || !$this->getOption('permitSessionBuffer')
        ) {
            return false;
        }

        session_start();

        $_SESSION['Buffer'][$name] = serialize($content);

        session_write_close();

        return true;
    }

    /**
     * Supprime un contenu mémorisé dans la session php.
     *
     * Fonction désactivée !
     *
     * @param string $name
     * @return boolean
     */
    public function unsetSessionBuffer($name)
    {
        return false; // Fonction désactivée !
        if ($name == ''
            || $this->_flushCache
            || !$this->getOption('permitSessionBuffer')
        ) {
            return false;
        }

        session_start();

        if (isset($_SESSION['Buffer'][$name])) {
            unset($_SESSION['Buffer'][$name]);
        }

        session_write_close();

        return true;
    }

    /**
     * Extrait les instances du buffer de session vers le cache.
     *
     * @return null
     */
    private function _readCacheOnSessionBuffer()
    {
        if ($this->_flushCache
            || !$this->getOption('permitSessionBuffer')
        ) {
            return;
        }

        session_start();

        // Extrait les objets/liens du cache.
        $list = array();
        if (isset($_SESSION['Buffer'])) {
            $list = $_SESSION['Buffer'];
        }
        if (sizeof($list) > 0) {
            foreach ($list as $string) {
                $instance = unserialize($string);
                if (is_a($instance, 'Transaction')) {
                    $id = $instance->getFullLink();
                    $this->_cacheTransactions[$id] = $instance;
                } elseif (is_a($instance, 'Wallet')) {
                    $id = $instance->getID();
                    $this->_cacheWallets[$id] = $instance;
                } elseif (is_a($instance, 'Token')) {
                    $id = $instance->getID();
                    $this->_cacheTokens[$id] = $instance;
                } elseif (is_a($instance, 'TokenPool')) {
                    $id = $instance->getID();
                    $this->_cacheTokenPools[$id] = $instance;
                } elseif (is_a($instance, 'Currency')) {
                    $id = $instance->getID();
                    $this->_cacheCurrencies[$id] = $instance;
                } elseif (is_a($instance, 'Conversation')) {
                    $id = $instance->getID();
                    $this->_cacheConversations[$id] = $instance;
                } elseif (is_a($instance, 'Group')) {
                    $id = $instance->getID();
                    $this->_cacheGroups[$id] = $instance;
                } elseif (is_a($instance, 'Entity')) {
                    $id = $instance->getID();
                    $this->_cacheEntities[$id] = $instance;
                } elseif (is_a($instance, 'Node')) {
                    $id = $instance->getID();
                    $this->_cacheObjects[$id] = $instance;
                } elseif (is_a($instance, 'Link')) {
                    $id = $instance->getFullLink();
                    $this->_cacheLinks[$id] = $instance;
                }
            }

            // Extrait les objets/liens du cache.
            $list = array();
            if (isset($_SESSION['BufferDateInsertion'])) {
                $list = $_SESSION['BufferDateInsertion'];
            }
            if (sizeof($list) > 0) {
                foreach ($list as $id => $string) {
                    $this->_cacheDateInsertion[$id] = $string;
                }
            }
        }

        session_write_close();

        // Vérifie si le cache n'est pas trop gros. Le vide au besoin.
        $this->_getCacheNeedCleaning();
    }

    /**
     * Re-sauvegarde les instances des certains objets avant la sauvegarde du cache vers le buffer de session.
     * Ces objets sont potentiellement modifiés depuis leur première instanciation.
     *
     * @return null
     */
    private function _saveCurrentsObjectsOnSessionBuffer()
    {
        $this->setSessionStore('nebuleHostEntityInstance', serialize($this->_instanceEntityInstance));
        $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
    }

    /**
     * Sauvegarde les instances du cache vers le buffer de session.
     *
     * @020200315
     * @return null
     */
    private function _saveCacheOnSessionBuffer()
    {
        if ($this->_flushCache
            || !$this->getOption('permitSessionBuffer')
        ) {
            return;
        }

        // Vérifie si le cache n'est pas trop gros. Le vide au besoin.
        $this->_getCacheNeedCleaning();

        session_start();

        // Vide le cache de la session PHP.
        $_SESSION['Buffer'] = array();

        // Mémorise les objets/liens.
        foreach ($this->_cacheLinks as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getFullLink()])) {
                $_SESSION['Buffer'][$instance->getFullLink()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getFullLink()] = $this->_cacheDateInsertion[$instance->getFullLink()];
            }
        }
        foreach ($this->_cacheObjects as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getID()])) {
                $_SESSION['Buffer'][$instance->getID()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getID()] = $this->_cacheDateInsertion[$instance->getID()];
            }
        }
        foreach ($this->_cacheEntities as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getID()])) {
                $_SESSION['Buffer'][$instance->getID()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getID()] = $this->_cacheDateInsertion[$instance->getID()];
            }
        }
        foreach ($this->_cacheGroups as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getID()])) {
                $_SESSION['Buffer'][$instance->getID()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getID()] = $this->_cacheDateInsertion[$instance->getID()];
            }
        }
        foreach ($this->_cacheConversations as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getID()])) {
                $_SESSION['Buffer'][$instance->getID()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getID()] = $this->_cacheDateInsertion[$instance->getID()];
            }
        }
        foreach ($this->_cacheCurrencies as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getID()])) {
                $_SESSION['Buffer'][$instance->getID()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getID()] = $this->_cacheDateInsertion[$instance->getID()];
            }
        }
        foreach ($this->_cacheTokenPools as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getID()])) {
                $_SESSION['Buffer'][$instance->getID()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getID()] = $this->_cacheDateInsertion[$instance->getID()];
            }
        }
        foreach ($this->_cacheTokens as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getID()])) {
                $_SESSION['Buffer'][$instance->getID()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getID()] = $this->_cacheDateInsertion[$instance->getID()];
            }
        }
        foreach ($this->_cacheWallets as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getID()])) {
                $_SESSION['Buffer'][$instance->getID()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getID()] = $this->_cacheDateInsertion[$instance->getID()];
            }
        }
        foreach ($this->_cacheTransactions as $instance) {
            if (isset($this->_cacheDateInsertion[$instance->getFullLink()])) {
                $_SESSION['Buffer'][$instance->getFullLink()] = serialize($instance);
                $_SESSION['BufferDateInsertion'][$instance->getFullLink()] = $this->_cacheDateInsertion[$instance->getFullLink()];
            }
        }

        session_write_close();
    }

    /**
     * Vide le buffer dans la session php.
     *
     * @return boolean
     */
    private function _flushBufferStore()
    {
        $this->_metrology->addLog('Flush buffer store', Metrology::LOG_LEVEL_NORMAL);
        session_start();
        unset($_SESSION['Buffer']);
        $_SESSION['Buffer'] = array();
        session_write_close();
        return true;
    }

    /**
     * Nettoye le cache du nombre d'entrés demandées.
     *
     * @020200315
     * @param number $c
     */
    private function _cleanCacheOverflow($c = 0)
    {
        // Quitte tout de suite si le cache n'est pas acctivé.
        if (!$this->getOption('permitSessionBuffer')) {
            return;
        }

        // Quitte si le nombre est nul ou négatif.
        if (!is_numeric($c)
            || $c <= 0
        ) {
            return;
        }

        if ($c > 100)
            $this->_metrology->addLog(__METHOD__ . ' cache need flush ' . $c . '/' . sizeof($this->_cacheDateInsertion), Metrology::LOG_LEVEL_NORMAL); // Log

        // Tri le tableau des temps. Les plus anciens sont au début.
        asort($this->_cacheDateInsertion);
        $i = 1;
        foreach ($this->_cacheDateInsertion as $id => $item) {
            if ($i > $c) {
                break;
            }

            // Nettoie le temps.
            unset($this->_cacheDateInsertion[$id]);

            // Nettoie un objet.
            if (isset($this->_cacheObjects[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_obj=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheObjects[$id]);
            }

            // Nettoie un lien.
            if (isset($this->_cacheLinks[$id])) // @todo bugg de suppression des liens !?
            {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_lnk=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheLinks[$id]);
            }

            // Nettoie une entité.
            if (isset($this->_cacheEntities[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_ent=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheEntities[$id]);
            }

            // Nettoie un groupe.
            if (isset($this->_cacheGroups[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_grp=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheGroups[$id]);
            }

            // Nettoie une conversation.
            if (isset($this->_cacheConversations[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_cvt=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheConversations[$id]);
            }

            // Nettoie une monnaie.
            if (isset($this->_cacheCurrencies[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_cur=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheCurrencies[$id]);
            }

            // Nettoie un sac de jetons.
            if (isset($this->_cacheTokenPools[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_tkp=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheTokenPools[$id]);
            }

            // Nettoie un jeton.
            if (isset($this->_cacheTokens[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_tkn=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheTokens[$id]);
            }

            // Nettoie un portefeuille.
            if (isset($this->_cacheWallets[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_wlt=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheWallets[$id]);
            }

            // Nettoie une transaction.
            if (isset($this->_cacheTransactions[$id])) {
                $this->_metrology->addLog(__METHOD__ . ' cache_supp_trt=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                unset($this->_cacheTransactions[$id]);
            }

            $i++;
        }
        unset($list);
    }

    /**
     * Retourne la taille totale de tous les caches.
     * Cette taille ne doit pas exéder la taille définie dans l'option sessionBufferSize.
     *
     * @return number
     */
    private function _getAllCachesSize()
    {
        return sizeof($this->_cacheObjects) + sizeof($this->_cacheLinks) + sizeof($this->_cacheEntities) + sizeof($this->_cacheGroups) + sizeof($this->_cacheConversations) + sizeof($this->_cacheCurrencies) + sizeof($this->_cacheTokenPools) + sizeof($this->_cacheTokens) + sizeof($this->_cacheWallets) + sizeof($this->_cacheTransactions);
    }

    /**
     * Vérifie si il faut libérer une place pour l'ajout en cache d'un nouvel objet/lien.
     * C'est à dire que la taille maximum du cache est atteinte.
     * Libère au moins une place si besoin.
     *
     * @return void
     */
    private function _getCacheNeedOnePlace()
    {
        // Quitte tout de suite si le cache n'est pas acctivé.
        if (!$this->getOption('permitSessionBuffer')) {
            return;
        }

        $size = $this->_getAllCachesSize();
        $limit = $this->_sessionBufferLimit;
        if ($size >= $limit) {
            $this->_cleanCacheOverflow($size - $limit + 1);
        }
    }

    /**
     * Vérifie si il faut libérer de la place en cache.
     * C'est à dire que la taille maximum du cache est atteinte.
     * Libère de la place si besoin.
     *
     * @return void
     */
    private function _getCacheNeedCleaning()
    {
        // Quitte tout de suite si le cache n'est pas acctivé.
        if (!$this->getOption('permitSessionBuffer')) {
            return;
        }

        $size = $this->_getAllCachesSize();
        $limit = $this->_sessionBufferLimit;
        if ($size >= $limit) {
            $this->_cleanCacheOverflow($size - $limit);
        }
    }


    /**
     * Nouvelle instance d'un objet.
     *
     * @param string $id
     * @param boolean $protect
     * @param boolean $obfuscated
     * @return Node
     */
    public function newObject($id, $protect = false, $obfuscated = false)
    {
        if (!is_string($id)
            || $id == ''
        ) {
            $id = '0';
        }

        if (!$this->_flushCache
            && isset($this->_cacheObjects[$id])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$id] = microtime(true);
            return $this->_cacheObjects[$id];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Node($this, $id, '', $protect, $obfuscated);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheObjects[$id] = $instance;
                $this->_cacheDateInsertion[$id] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'un objet.
     *
     * @param string $id
     * @return boolean
     */
    public function removeCacheObject($id)
    {
        if (isset($this->_cacheObjects[$id])) {
            unset($this->_cacheObjects[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retourne le nombre d'objets dans le cache.
     *
     * @return integer
     */
    public function getCacheObjectSize()
    {
        return sizeof($this->_cacheObjects);
    }


    /**
     * Nouvelle instance d'un lien.
     *
     * @param string $link
     * @param string $version
     * @return Link
     */
    public function newLink($link, $version = 'UNKNOWN')
    {
        if ($link == '') {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheLinks[$link])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$link] = microtime(true);
            return $this->_cacheLinks[$link];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Link($this, $link, $version);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheLinks[$link] = $instance;
                $this->_cacheDateInsertion[$link] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'un lien.
     *
     * @param string $link
     * @return boolean
     */
    public function removeCacheLink($link)
    {
        if (isset($this->_cacheLinks[$link])) {
            unset($this->_cacheLinks[$link], $this->_cacheDateInsertion[$link]);
        }
        return true;
    }

    /**
     * Retourne le nombre de liens dans le cache.
     *
     * @return integer
     */
    public function getCacheLinkSize()
    {
        return sizeof($this->_cacheLinks);
    }


    /**
     * Nouvelle instance d'une entité.
     *
     * @param string $id
     * @return Entity
     */
    public function newEntity($id)
    {
        if (!is_string($id)
            || $id == ''
        ) {
            $id = '0';
        }

        if (!$this->_flushCache
            && isset($this->_cacheEntities[$id])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$id] = microtime(true);
            return $this->_cacheEntities[$id];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Entity($this, $id);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheEntities[$id] = $instance;
                $this->_cacheDateInsertion[$id] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'une entité.
     *
     * @param string $id
     * @return boolean
     */
    public function removeCacheEntity($id)
    {
        if (isset($this->_cacheEntities[$id])) {
            unset($this->_cacheEntities[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retourne le nombre d'entités dans le cache.
     *
     * @return integer
     */
    public function getCacheEntitySize()
    {
        return sizeof($this->_cacheEntities);
    }


    /**
     * Nouvelle instance d'un groupe.
     *
     * @param string $id
     * @return Group
     */
    public function newGroup($id)
    {
        if (!is_string($id)
            || $id == ''
        ) {
            $id = '0';
        }

        if (!$this->_flushCache
            && isset($this->_cacheGroups[$id])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$id] = microtime(true);
            return $this->_cacheGroups[$id];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Group($this, $id);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheGroups[$id] = $instance;
                $this->_cacheDateInsertion[$id] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'un groupe.
     *
     * @param string $id
     * @return boolean
     */
    public function removeCacheGroup($id)
    {
        if (isset($this->_cacheGroups[$id])) {
            unset($this->_cacheGroups[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retourne le nombre de groupes dans le cache.
     *
     * @return integer
     */
    public function getCacheGroupSize()
    {
        return sizeof($this->_cacheGroups);
    }


    /**
     * Nouvelle instance d'une conversation.
     *
     * @param string $id
     * @param boolean $closed
     * @param boolean $protect
     * @param boolean $obfuscated
     * @return Conversation
     */
    public function newConversation($id, $closed = false, $protected = false, $obfuscated = false)
    {
        if (!is_string($id)
            || $id == ''
        ) {
            $id = '0';
        }

        if (!$this->_flushCache
            && isset($this->_cacheConversations[$id])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$id] = microtime(true);
            return $this->_cacheConversations[$id];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Conversation($this, $id, $closed, $protected, $obfuscated);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheConversations[$id] = $instance;
                $this->_cacheDateInsertion[$id] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'une conversation.
     *
     * @param string $id
     * @return boolean
     */
    public function removeCacheConversation($id)
    {
        if (isset($this->_cacheConversations[$id])) {
            unset($this->_cacheConversations[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retourne le nombre de conversations dans le cache.
     *
     * @return integer
     */
    public function getCacheConversationSize()
    {
        return sizeof($this->_cacheConversations);
    }


    /**
     * Nouvelle instance d'une monnaie.
     *
     * @param string $id
     * @param array $param
     * @param boolean $protect
     * @param boolean $obfuscated
     * @return Currency
     */
    public function newCurrency($id, $param = array(), $protected = false, $obfuscated = false)
    {
        if (!is_string($id)
            || $id == ''
        ) {
            $id = '0';
        }

        if (!$this->_flushCache
            && isset($this->_cacheCurrencies[$id])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$id] = microtime(true);
            return $this->_cacheCurrencies[$id];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Currency($this, $id, $param, $protected, $obfuscated);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheCurrencies[$id] = $instance;
                $this->_cacheDateInsertion[$id] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'une monnaie.
     *
     * @param string $id
     * @return boolean
     */
    public function removeCacheCurrency($id)
    {
        if (isset($this->_cacheCurrencies[$id])) {
            unset($this->_cacheCurrencies[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retourne le nombre de monnaies dans le cache.
     *
     * @return integer
     */
    public function getCacheCurrencySize()
    {
        return sizeof($this->_cacheCurrencies);
    }


    /**
     * Nouvelle instance d'un jeton.
     *
     * @param string $id
     * @param array $param
     * @param boolean $protect
     * @param boolean $obfuscated
     * @return Token
     */
    public function newToken($id, $param = array(), $protected = false, $obfuscated = false)
    {
        if (!is_string($id)
            || $id == ''
        ) {
            $id = '0';
        }

        if (!$this->_flushCache
            && isset($this->_cacheTokens[$id])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$id] = microtime(true);
            return $this->_cacheTokens[$id];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Token($this, $id, $param, $protected, $obfuscated);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheTokens[$id] = $instance;
                $this->_cacheDateInsertion[$id] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'un jeton.
     *
     * @param string $id
     * @return boolean
     */
    public function removeCacheToken($id)
    {
        if (isset($this->_cacheTokens[$id])) {
            unset($this->_cacheTokens[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retourne le nombre de jetons dans le cache.
     *
     * @return integer
     */
    public function getCacheTokenSize()
    {
        return sizeof($this->_cacheTokens);
    }


    /**
     * Nouvelle instance d'un sac de jetons.
     *
     * @param string $id
     * @param array $param
     * @param boolean $protect
     * @param boolean $obfuscated
     * @return TokenPool
     */
    public function newTokenPool($id, $param = array(), $protected = false, $obfuscated = false)
    {
        if (!is_string($id)
            || $id == ''
        ) {
            $id = '0';
        }

        if (!$this->_flushCache
            && isset($this->_cacheTokenPools[$id])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$id] = microtime(true);
            return $this->_cacheTokenPools[$id];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new TokenPool($this, $id, $param, $protected, $obfuscated);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheTokenPools[$id] = $instance;
                $this->_cacheDateInsertion[$id] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'un sac de jetons.
     *
     * @param string $id
     * @return boolean
     */
    public function removeCacheTokenPool($id)
    {
        if (isset($this->_cacheTokenPools[$id])) {
            unset($this->_cacheTokenPools[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retourne le nombre de sacs de jetons dans le cache.
     *
     * @return integer
     */
    public function getCacheTokenPoolSize()
    {
        return sizeof($this->_cacheTokenPools);
    }


    /**
     * Nouvelle instance d'un portefeuille.
     *
     * @param string $id
     * @param array $param
     * @param boolean $protect
     * @param boolean $obfuscated
     * @return Wallet
     */
    public function newWallet($id, $param = array(), $protected = false, $obfuscated = false)
    {
        if (!is_string($id)
            || $id == ''
        ) {
            $id = '0';
        }

        if (!$this->_flushCache
            && isset($this->_cacheWallets[$id])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$id] = microtime(true);
            return $this->_cacheWallets[$id];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Wallet($this, $id, $param, $protected, $obfuscated);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheWallets[$id] = $instance;
                $this->_cacheDateInsertion[$id] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'un portefeuille.
     *
     * @param string $id
     * @return boolean
     */
    public function removeCacheWallet($id)
    {
        if (isset($this->_cacheWallets[$id])) {
            unset($this->_cacheWallets[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retourne le nombre de portefeuilles dans le cache.
     *
     * @return integer
     */
    public function getCacheWalletSize()
    {
        return sizeof($this->_cacheWallets);
    }


    /**
     * Nouvelle instance d'une transaction.
     * Attention, c'est un lien !
     *
     * @param string $link
     * @param string $version
     * @return Transaction
     */
    public function newTransaction($link, $version = 'UNKNOWN')
    {
        if ($link == '') {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheTransactions[$link])
        ) {
            // Surchage la date d'ajout.
            $this->_cacheDateInsertion[$link] = microtime(true);
            return $this->_cacheTransactions[$link];
        } else {
            // Regarde si la limite de taille du cache est atteinte.
            $this->_getCacheNeedOnePlace();

            // Génère une instance.
            $instance = new Transaction($this, $link, $version);

            // Si le cache est activé.
            if ($this->getOption('permitSessionBuffer')) {
                // Ajoute l'instance au cache.
                $this->_cacheTransactions[$link] = $instance;
                $this->_cacheDateInsertion[$link] = microtime(true);
            }

            return $instance;
        }
    }

    /**
     * Supprime le cache d'une transaction.
     *
     * @param string $link
     * @return boolean
     */
    public function removeCacheTransaction($link)
    {
        if (isset($this->_cacheTransactions[$link])) {
            unset($this->_cacheTransactions[$link], $this->_cacheDateInsertion[$link]);
        }
        return true;
    }

    /**
     * Retourne le nombre de transactions dans le cache.
     *
     * @return integer
     */
    public function getCacheTransactionSize()
    {
        return sizeof($this->_cacheTransactions);
    }


    /**
     * Retire le cache d'un objet.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture de l'objet.
     *
     * @param $id string
     * @return boolean
     */
    public function unsetObjectCache($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheObjects[$id])
        ) {
            unset($this->_cacheObjects[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retire le cache d'une entité.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture de l'entité.
     *
     * @param $id string
     * @return boolean
     */
    public function unsetEntityCache($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheEntities[$id])
        ) {
            unset($this->_cacheEntities[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retire le cache d'un groupe.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture du groupe.
     *
     * @param $id string
     * @return boolean
     */
    public function unsetGroupCache($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheGroups[$id])
        ) {
            unset($this->_cacheGroups[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retire le cache d'une conversation.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture de la conversation.
     *
     * @param $id string
     * @return boolean
     */
    public function unsetConversationCache($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheConversations[$id])
        ) {
            unset($this->_cacheConversations[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retire le cache d'une monnaie.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture de la monnaie.
     *
     * @param $id string
     * @return boolean
     */
    public function unsetCurrencyCache($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheCurrencies[$id])
        ) {
            unset($this->_cacheCurrencies[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retire le cache d'un sac de jetons.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture du sac de jetons.
     *
     * @param $id string
     * @return boolean
     */
    public function unsetTokenPoolCache($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheTokenPools[$id])
        ) {
            unset($this->_cacheTokenPools[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retire le cache d'un jeton.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture du jeton.
     *
     * @param $id string
     * @return boolean
     */
    public function unsetTokenCache($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheTokens[$id])
        ) {
            unset($this->_cacheTokens[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retire le cache d'un poretfeuille.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture du poretfeuille.
     *
     * @param $id string
     * @return boolean
     */
    public function unsetWalletCache($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheWallets[$id])
        ) {
            unset($this->_cacheWallets[$id], $this->_cacheDateInsertion[$id]);
        }
        return true;
    }

    /**
     * Retire le cache d'une transaction.
     * C'est utilisé lorsque l'on modifie une propriété et que l'on souhaite forcer la relecture de la transaction.
     *
     * @param $link string
     * @return boolean
     */
    public function unsetTransactionCache($link)
    {
        if (is_a($link, 'Link')) {
            $link = $link->getID();
        }

        if ($link == ''
            || $link == '0'
        ) {
            return false;
        }

        if (!$this->_flushCache
            && isset($this->_cacheTransactions[$link])
        ) {
            unset($this->_cacheTransactions[$link], $this->_cacheDateInsertion[$link]);
        }
        return true;
    }



    // Gestion des modules.

    /**
     * Liste les modules.
     * @param string $name
     * @return boolean
     * @todo
     *
     */
    public function listModule($name)
    {
        if ($name == '') {
            return false;
        }

        // ...

        return true;
    }

    /**
     * Charge un module.
     * @param string $name
     * @return boolean|Modules
     * @todo
     *
     */
    public function loadModule($name)
    {
        if ($name == '') {
            return false;
        }

        // ...

        $module = new $name;

        return $module;
    }



    // Gestion de l'objet en cours.

    /**
     * ID de l'objet en cours.
     *
     * @var string
     */
    private $_currentObject = '';

    /**
     * Instance de l'objet en cours.
     *
     * @var Node|null
     */
    private $_currentObjectInstance = null;

    /**
     * Recherche l'objet en cours d'utilisation.
     *
     * @return null
     */
    private function _findCurrentObjet()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        $arg_obj = trim(filter_input(INPUT_GET, self::COMMAND_SELECT_OBJECT, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

        // Si la variable est un objet avec ou sans liens.
        if ($arg_obj != ''
            && strlen($arg_obj) >= self::NEBULE_MINIMUM_ID_SIZE
            && ctype_xdigit($arg_obj)
            && ($this->getIO()->checkObjectPresent($arg_obj)
                || $this->getIO()->checkLinkPresent($arg_obj)
            )
        ) {
            // Ecrit l'objet dans la variable.
            $this->_currentObject = $arg_obj;
            $this->_currentObjectInstance = $this->newObject($arg_obj);
            // Ecrit l'objet dans la session.
            $this->setSessionStore('nebuleSelectedObject', $arg_obj);
        } else {
            // Sinon vérifie si une valeur n'est pas mémorisée dans la session.
            $cache = $this->getSessionStore('nebuleSelectedObject');
            // Si il existe une variable de session pour l'objet en cours, la lit.
            if ($cache !== false && $cache != '') {
                $this->_currentObject = $cache;
                $this->_currentObjectInstance = $this->newObject($cache);
            } else // Sinon selectionne l'entite courante par défaut.
            {
                $this->_currentObject = $this->getCurrentEntity();
                $this->_currentObjectInstance = $this->newObject($this->getCurrentEntity());
                $this->setSessionStore('nebuleSelectedObject', $this->getCurrentEntity());
            }
            unset($cache);
        }
        unset($arg_obj);

        $this->_metrology->addLog('Find current object ' . $this->_currentObject, Metrology::LOG_LEVEL_DEBUG); // Log
        $this->_currentObjectInstance->getMarkProtected();
    }

    /**
     * Donne l'ID de l'objet en cours.
     *
     * @return string
     */
    public function getCurrentObject()
    {
        return $this->_currentObject;
    }

    /**
     * Donne l'instance de l'objet en cours.
     *
     * @return Node|null
     */
    public function getCurrentObjectInstance()
    {
        return $this->_currentObjectInstance;
    }



    /*
	 * Gestion de l'entité de l'instance du serveur et donc de l'application.
	 */
    /**
     * Clé publique de l'entité hôte de l'instance du serveur.
     *
     * @var string
     */
    private $_instanceEntity = '';

    /**
     * Instance de l'entité hôte de l'instance du serveur.
     *
     * @var Entity|null
     */
    private $_instanceEntityInstance = null;

    /**
     * Recherche l'entité hôte sur le serveur.
     *
     * @return null
     */
    private function _findInstanceEntity()
    {
        $instance = null;
        // Vérifie si une valeur n'est pas mémorisée dans la session.
        $id = $this->getSessionStore('nebuleHostEntity');

        // Si il existe une variable de session pour l'hôte en cours, la lit.
        if ($id !== false
            && $id != ''
        ) {
            $instance = unserialize($this->getSessionStore('nebuleHostEntityInstance'));
        }

        if ($id !== false
            && $id != ''
            && $instance !== false
            && $instance !== ''
            && is_a($instance, 'Entity')
        ) {
            $this->_instanceEntity = $id;
            $this->_instanceEntityInstance = $instance;
        } else {
            // Sinon recherche une entité pour l'instance.
            // C'est le fichier 'e' qui contient normalement l'ID de cette entité.
            if (file_exists(self::NEBULE_LOCAL_ENTITY_FILE)
                && is_file(self::NEBULE_LOCAL_ENTITY_FILE)
            ) {
                $id = filter_var(trim(strtok(file_get_contents(self::NEBULE_LOCAL_ENTITY_FILE), "\n")), FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW);
            }

            if ($id != ''
                && strlen($id) >= self::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($id)
                && $this->_io->checkObjectPresent($id)
                && $this->_io->checkLinkPresent($id)
            ) {
                $this->_instanceEntity = $id;
                $this->_instanceEntityInstance = $this->newEntity($id);
            } else {
                // Sinon utilise l'instance du maître du code.
                $this->_instanceEntity = $this->_codeMaster;
                $this->_instanceEntityInstance = $this->_codeMasterInstance;
            }

            // Log
            $this->_metrology->addLog('Find server entity ' . $this->_instanceEntity, Metrology::LOG_LEVEL_DEBUG);

            // Mémorisation.
            $this->setSessionStore('nebuleHostEntity', $this->_instanceEntity);
            $this->setSessionStore('nebuleHostEntityInstance', serialize($this->_instanceEntityInstance));
        }
        unset($id, $instance);
    }

    /**
     * Donne l'ID de l'entité de l'instance de serveur.
     *
     * @return string
     */
    public function getInstanceEntity()
    {
        return $this->_instanceEntity;
    }

    /**
     * Donne l'instance de l'entité de l'instance de serveur.
     *
     * @return Entity|NULL
     */
    public function getInstanceEntityInstance()
    {
        return $this->_instanceEntityInstance;
    }



    /*
	 * Gestion de l'entité par défaut.
	 */
    /**
     * Clé publique de l'entité par défaut.
     *
     * @var string
     */
    private $_defaultEntity = '';

    /**
     * Instance de l'entité par défaut.
     *
     * @var Entity|null
     */
    private $_defaultEntityInstance = null;

    /**
     * Recherche l'entité par défaut.
     *
     * @return null
     */
    private function _findDefaultEntity()
    {
        $instance = null;
        // Vérifie si une valeur n'est pas mémorisée dans la session.
        $id = $this->getSessionStore('nebuleDefaultEntity');

        // Si il existe une variable de session pour l'hôte en cours, la lit.
        if ($id !== false
            && $id != ''
        ) {
            $instance = unserialize($this->getSessionStore('nebuleDefaultEntityInstance'));
        }

        if ($id !== false
            && $id != ''
            && $instance !== false
            && $instance !== ''
            && is_a($instance, 'Entity')
        ) {
            $this->_defaultEntity = $id;
            $this->_defaultEntityInstance = $instance;
        } else {
            // Sinon recherche une entité par défaut.
            // C'est définit comme une option.
            $id = $this->getOption('defaultCurrentEntity');

            if ($id != ''
                && strlen($id) >= self::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($id)
                && $this->_io->checkObjectPresent($id)
                && $this->_io->checkLinkPresent($id)
            ) {
                $this->_defaultEntity = $id;
                $this->_defaultEntityInstance = $this->newEntity($id);
            } else {
                // Sinon utilise l'instance du serveur hôte.
                $this->_defaultEntity = $this->_instanceEntity;
                $this->_defaultEntityInstance = $this->_instanceEntityInstance;
            }

            // Log
            $this->_metrology->addLog('Find default entity ' . $this->_defaultEntity, Metrology::LOG_LEVEL_NORMAL);

            // Mémorisation.
            $this->setSessionStore('nebuleDefaultEntity', $this->_defaultEntity);
            $this->setSessionStore('nebuleDefaultEntityInstance', serialize($this->_defaultEntityInstance));
        }
        unset($id, $instance);
    }

    /**
     * Donne l'ID de l'entité par défaut.
     *
     * @return string
     */
    public function getDefaultEntity()
    {
        return $this->_defaultEntity;
    }

    /**
     * Donne l'instance de l'entité par défaut.
     *
     * @return Entity|NULL
     */
    public function getDefaultEntityInstance()
    {
        return $this->_defaultEntityInstance;
    }



    // Gestion de l'entité en cours d'utilisation par l'application.

    /**
     * ID de la clé publique de l'entité.
     *
     * @var string
     */
    private $_currentEntity = '';

    /**
     * Instance de la clé publique de l'entité.
     *
     * @var Entity|null
     */
    private $_currentEntityInstance = null;

    /**
     * ID de la clé privée de l'entité.
     *
     * @var string
     */
    private $_currentEntityPrivateKey = '';

    /**
     * Instance de la clé privée de l'entité.
     *
     * @var Node|null
     */
    private $_currentEntityPrivateKeyInstance = null;

    /**
     * Etat de verrouillage de l'entité courante.
     *
     * @var boolean
     */
    private $_currentEntityUnlocked = false;

    private function _findCurrentEntity()
    {
        $itc_ent = null;

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // Regarde si demande de changement d'entité, si la variable GET ou POST existe (true/false).
        $arg_switch = (filter_has_var(INPUT_GET, self::COMMAND_SWITCH_TO_ENTITY)
            || filter_has_var(INPUT_POST, self::COMMAND_SWITCH_TO_ENTITY));
        // Lit et nettoye le contenu de la variable GET de la nouvelle entité attendue.
        $arg_ent = filter_input(INPUT_GET, self::COMMAND_SELECT_ENTITY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW);

        // Si la variable est une entité avec ou sans liens.
        if ($arg_switch
            && $arg_ent != ''
            && strlen($arg_ent) >= self::NEBULE_MINIMUM_ID_SIZE
            && ctype_xdigit($arg_ent)
            && $this->_io->checkObjectPresent($arg_ent)
            && $this->_io->checkLinkPresent($arg_ent)
        ) {
            $itc_ent = $this->newObject($arg_ent);
        }

        if ($arg_switch
            && is_a($itc_ent, 'Node')
            && $itc_ent->getType('all') == Entity::ENTITY_TYPE
        ) {
            unset($itc_ent);
            // Vide le mot de passe de l'entité en cours.
            if (is_a($this->_currentEntityInstance, 'Entity')) {
                $this->_currentEntityInstance->unsetPrivateKeyPassword();
                $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
            }
            // Ecrit l'entité dans la session et dans la variable globale.
            $this->_currentEntity = $arg_ent;
            $this->_currentEntityInstance = new Entity($this->_nebuleInstance, $arg_ent);
            $this->setSessionStore('nebulePublicEntity', $this->_currentEntity);
            $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
            // Vide la clé privée connue.
            $this->_currentEntityPrivateKey = '';
            $this->_currentEntityPrivateKeyInstance = '';
            $this->setSessionStore('nebulePrivateEntity', '');
            $this->_metrology->addLog('New current entity ' . $this->_currentEntity, Metrology::LOG_LEVEL_DEBUG); // Log
        } else {
            $tID = $this->getSessionStore('nebulePublicEntity');
            $tInstance = unserialize($this->getSessionStore('nebulePublicEntityInstance'));
            // Si il existe une variable de session pour l'entité, la lit.
            if ($tID !== false
                && $tID != ''
                && $tInstance !== false
                && is_a($tInstance, 'Entity')
            ) {
                $this->_currentEntity = $tID;
                $this->_currentEntityInstance = $tInstance;
                $this->_metrology->addLog('Reuse current entity ' . $this->_currentEntity, Metrology::LOG_LEVEL_DEBUG); // Log
            } else // Sinon essaie de la trouver ailleurs.
            {
                $itc_ent = '';
                $ext_ent = $this->getOption('defaultCurrentEntity');
                if ($ext_ent != ''
                    && strlen($ext_ent) >= self::NEBULE_MINIMUM_ID_SIZE
                    && ctype_xdigit($ext_ent)
                    && $this->_io->checkObjectPresent($ext_ent)
                    && $this->_io->checkLinkPresent($ext_ent)) {
                    $itc_ent = $this->newObject($ext_ent);
                }
                if (is_a($itc_ent, 'Node') && $itc_ent->getType('all') == Entity::ENTITY_TYPE) {
                    unset($itc_ent);
                    // Ecrit l'entité dans la session et dans la variable globale.
                    $this->_currentEntity = $ext_ent;
                    $this->_currentEntityInstance = new Entity($this->_nebuleInstance, $ext_ent);
                    $this->setSessionStore('nebulePublicEntity', $this->_currentEntity);
                    $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
                    // Vide la clé privée connue.
                    $this->_currentEntityPrivateKey = '';
                    $this->_currentEntityPrivateKeyInstance = '';
                    $this->setSessionStore('nebulePrivateEntity', '');
                    $this->_metrology->addLog('Find default current entity ' . $this->_currentEntity, Metrology::LOG_LEVEL_DEBUG); // Log
                } // Sinon utilise l'entité de l'instance.
                else {
                    $this->_currentEntity = $this->_instanceEntity;
                    $this->_currentEntityInstance = $this->_instanceEntityInstance;
                    $this->setSessionStore('nebulePublicEntity', $this->_currentEntity);
                    $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
                    // Vide la clé privée connue.
                    $this->_currentEntityPrivateKey = '';
                    $this->_currentEntityPrivateKeyInstance = '';
                    $this->setSessionStore('nebulePrivateEntity', '');
                    $this->_metrology->addLog('Find current (instance) entity ' . $this->_currentEntity, Metrology::LOG_LEVEL_DEBUG); // Log
                }
                unset($ext_ent);
            }
            unset($tID, $tInstance);
        }
        unset($arg_switch, $arg_ent);
    }

    private function _findCurrentEntityPrivateKey()
    {
        // Si il existe une variable de session pour l'entite, la lit
        if ($this->getSessionStore('nebulePrivateEntity') !== false
            && $this->getSessionStore('nebulePrivateEntity') != ''
        ) {
            $this->_currentEntityPrivateKey = $this->getSessionStore('nebulePrivateEntity');
            $this->_currentEntityPrivateKeyInstance = $this->newObject($this->_currentEntityPrivateKey);
            // Log
            $this->_metrology->addLog('Reuse current entity private key ' . $this->_currentEntityPrivateKey, Metrology::LOG_LEVEL_DEBUG);
        } // Sinon essaie de la trouver ailleurs
        else {
            if (is_a($this->_currentEntityInstance, 'Entity')) {
                $this->_currentEntityPrivateKey = $this->_currentEntityInstance->getPrivateKeyID();
                if ($this->_currentEntityPrivateKey != '') {
                    $this->_currentEntityPrivateKeyInstance = $this->newObject($this->_currentEntityPrivateKey);
                    // Log
                    $this->_metrology->addLog('Find current entity private key ' . $this->_currentEntityPrivateKey, Metrology::LOG_LEVEL_DEBUG);
                } else {
                    $this->_currentEntityPrivateKeyInstance = '';
                    // Log
                    $this->_metrology->addLog('Cant find current entity private key ' . $this->_currentEntityPrivateKey, Metrology::LOG_LEVEL_DEBUG);
                }
                $this->setSessionStore('nebulePrivateEntity', $this->_currentEntityPrivateKey);
            } else {
                $this->_currentEntityPrivateKey = '';
                $this->_currentEntityPrivateKeyInstance = '';
            }
        }
    }

    private function _findCurrentEntityPassword()
    {
        $arg_pwd = '';

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // Regarde si demande de changement fermeture d'entité, si la variable GET ou POST existe (true/false).
        $arg_logout = (filter_has_var(INPUT_GET, self::COMMAND_LOGOUT_ENTITY)
            || filter_has_var(INPUT_POST, self::COMMAND_LOGOUT_ENTITY));
        // Lit et nettoye le contenu des variables GET et POST pour le mot de passe.
        $arg_get_pwd = filter_input(INPUT_GET, self::COMMAND_SELECT_PASSWORD, FILTER_SANITIZE_STRING);
        $arg_post_pwd = filter_input(INPUT_POST, self::COMMAND_SELECT_PASSWORD, FILTER_SANITIZE_STRING);

        // Extrait un des mots de passes.
        if ($arg_get_pwd != '' && $arg_post_pwd == '') {
            $arg_pwd = $arg_get_pwd;
        }

        if ($arg_post_pwd != '') {
            $arg_pwd = $arg_post_pwd;
        }

        // Supprime le mdp et ferme la session si l'argment logout est présent.
        // Si c'est une demande de fermeture d'entité.
        if ($arg_logout) {
            // Supprime le mot de passe de l'entité en cours.
            if (is_a($this->_currentEntityInstance, 'Entity')) {
                $this->_currentEntityInstance->unsetPrivateKeyPassword();
                $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
                $this->_metrology->addLog('Logout ' . $this->_currentEntity, Metrology::LOG_LEVEL_NORMAL); // Log
            }
        } else {
            // Ajoute le mot de passe à l'entité en cours.
            $this->_currentEntityInstance->setPrivateKeyPassword($arg_pwd);
            $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
            // Test si le mot de passe est bon.
            $this->_currentEntityUnlocked = $this->_currentEntityInstance->checkPrivateKeyPassword();
            if ($this->_currentEntityUnlocked) {
                $this->_metrology->addLog('Login password ' . $this->_currentEntity . ' OK', Metrology::LOG_LEVEL_NORMAL); // Log
            } else {
                $this->_metrology->addLog('Login password ' . $this->_currentEntity . ' NOK', Metrology::LOG_LEVEL_ERROR); // Log
            }
        }
        unset($arg_logout, $arg_pwd, $arg_get_pwd, $arg_post_pwd);
    }

    /**
     * Lit l'ID de l'entité en cours.
     *
     * @return string
     */
    public function getCurrentEntity()
    {
        return $this->_currentEntity;
    }

    /**
     * Lit l'instance de l'entité en cours.
     *
     * @return Entity
     */
    public function getCurrentEntityInstance()
    {
        return $this->_currentEntityInstance;
    }

    /**
     * Lit l'ID de la clé privée de l'entité en cours.
     *
     * @return string
     */
    public function getCurrentEntityPrivateKey()
    {
        return $this->_currentEntityPrivateKey;
    }

    /**
     * Lit l'instance de la clé privée de l'entité en cours.
     *
     * @return Node
     */
    public function getCurrentEntityPrivateKeyInstance()
    {
        return $this->_currentEntityPrivateKeyInstance;
    }

    /**
     * Lit le status de verrouillage de l'entité en cours.
     * - true : entité déverrouillée.
     * - false : entité verrouillée.
     *
     * @return boolean
     */
    public function getCurrentEntityUnlocked()
    {
        return $this->_currentEntityUnlocked;
    }

    /**
     * Change l'entité courante. Le changement est permanent et les caches sont effacés.
     * Penser à lui pousser son mot de passe pour qu'elle soit déverrouillée.
     *
     * @param Entity $entity
     * @return boolean
     */
    public function setCurrentEntity(Entity $entity)
    {
        if (!$entity instanceof Entity) return false;
        // Reouvre une nouvelle session pour la suite.
        session_start();

        //$this->_flushSessionStore();
        $this->_flushBufferStore();

        // Change l'entité en cours.
        $this->_currentEntityInstance = $entity;
        $this->_currentEntity = $this->_currentEntityInstance->getID();
        $this->setSessionStore('nebulePublicEntity', $this->_currentEntity);
        $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
        // Cherche la clé privée.
        $this->_findCurrentEntityPrivateKey();
        // Test si le mot de passe est bon.
        $this->_currentEntityUnlocked = $this->_currentEntityInstance->checkPrivateKeyPassword();

        session_write_close();
        return true;
    }

    /**
     * Change l'entité courante de façon temporaire. Les caches sont effacés.
     * Penser à lui pousser son mot de passe pour qu'elle soit déverrouillée.
     *
     * L'ancienne entité est mémorisée pour être restaurée en fin de période temporaire.
     *
     * La fonction est utilisée par la génération d'une nouvelle entité
     *   afin de faire signer les liens par la nouvelle entité.
     *
     * @param Entity $entity
     * @return boolean
     */
    public function setTempCurrentEntity(Entity $entity)
    {
        if (!$entity instanceof Entity) return false;
        // Reouvre une nouvelle session pour la suite.
        session_start();

        //$this->_flushSessionStore();
        $this->_flushBufferStore();

        // Enregistre l'ancienne entité.
        $this->setSessionStore('nebuleTempPublicEntityInstance', serialize($this->_currentEntityInstance));

        // Change l'entité en cours.
        $this->_currentEntityInstance = $entity;
        $this->_currentEntity = $this->_currentEntityInstance->getID();
        $this->setSessionStore('nebulePublicEntity', $this->_currentEntity);
        $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
        // Cherche la clé privée.
        $this->_findCurrentEntityPrivateKey();
        // Test si le mot de passe est bon.
        $this->_currentEntityUnlocked = $this->_currentEntityInstance->checkPrivateKeyPassword();

        session_write_close();
        return true;
    }

    /**
     * Annule le changement temporaire de l'entité. Les caches sont effacés.
     * Elle contient déjà son mot de passe si elle était déverrouillée.
     *
     * L'ancienne entité est restaurée. L'entité actuelle est retirée.
     *
     * @return boolean
     */
    public function unsetTempCurrentEntity()
    {
        // Reouvre une nouvelle session pour la suite.
        session_start();

        // Restaure l'ancienne entité.
        $entity = $this->getSessionStore('nebuleTempPublicEntityInstance');
        if ($entity === false) {
            session_write_close();
            return false;
        }

        //$this->_flushSessionStore();
        $this->_flushBufferStore();

        // Change l'entité en cours.
        $this->_currentEntityInstance = unserialize($entity);
        $this->_currentEntity = $this->_currentEntityInstance->getID();
        $this->setSessionStore('nebulePublicEntity', $this->_currentEntity);
        $this->setSessionStore('nebulePublicEntityInstance', serialize($this->_currentEntityInstance));
        // Cherche la clé privée.
        $this->_findCurrentEntityPrivateKey();
        // Test si le mot de passe est bon.
        $this->_currentEntityUnlocked = $this->_currentEntityInstance->checkPrivateKeyPassword();

        session_write_close();
        return true;
    }


    /**
     * Liste des ID des entitées déverrouillées.
     *
     * @var array:string
     */
    private $_listEntitiesUnlocked = array();

    /**
     * Liste des instances des entitées déverrouillées.
     *
     * @var array:Entity
     */
    private $_listEntitiesUnlockedInstances = array();

    /**
     * Lit la liste des ID des entités déverrouillées.
     *
     * @return string
     */
    public function getListEntitiesUnlocked()
    {
        return $this->_listEntitiesUnlocked;
    }

    /**
     * Lit la liste des instances des entités déverrouillées.
     *
     * @return Entity
     */
    public function getListEntitiesUnlockedInstances()
    {
        return $this->_listEntitiesUnlockedInstances;
    }

    /**
     * Ajoute une entité à la liste des entités déverrouillées.
     *
     * @param string|Entity $id
     * @return void
     */
    public function addListEntitiesUnlocked($id)
    {
        $instance = $this->convertIdToTypedObjectInstance($id);
        if (!is_a($id, 'Entity')) {
            return;
        }
        $id = $instance->getID();

        $this->_listEntitiesUnlocked[$id] = $id;
        $this->_listEntitiesUnlockedInstances[$id] = $instance;
    }

    /**
     * Retire une entité de la liste des entités déverrouillées.
     *
     * @param string|Entity $id
     * @return void
     */
    public function removeListEntitiesUnlocked($id)
    {
        if (is_a($id, 'Node')) {
            $id = $id->getID();
        }

        unset($this->_listEntitiesUnlocked[$id]);
        unset($this->_listEntitiesUnlockedInstances[$id]);
    }

    /**
     * Efface toute la liste des entités déverrouillées.
     *
     * @return void
     */
    public function flushListEntitiesUnlocked()
    {
        $this->_listEntitiesUnlocked = array();
        $this->_listEntitiesUnlockedInstances = array();
    }


    /**
     * ID du groupe en cours.
     *
     * @var string
     */
    private $_currentGroup = '';

    /**
     * Instance du groupe en cours.
     *
     * @var Group|null
     */
    private $_currentGroupInstance = null;

    /**
     * Recherche la group en cours d'utilisation.
     *
     * Si pas d'argument de définition de l'objet, et si pas dans le cache, l'ID est mis à 0.
     *
     * @return void
     */
    private function _findCurrentGroup()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        if (filter_has_var(INPUT_GET, self::COMMAND_SELECT_GROUP)) {
            $arg_grp = trim(filter_input(INPUT_GET, self::COMMAND_SELECT_GROUP, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        } else {
            $arg_grp = trim(filter_input(INPUT_POST, self::COMMAND_SELECT_GROUP, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        }

        // Si la variable est un objet avec ou sans liens.
        if ($arg_grp != ''
            && (strlen($arg_grp) >= self::NEBULE_MINIMUM_ID_SIZE
                || $arg_grp == '0'
            )
            && ctype_xdigit($arg_grp)
            && ($this->getIO()->checkObjectPresent($arg_grp)
                || $this->getIO()->checkLinkPresent($arg_grp)
                || $arg_grp == '0'
            )
        ) {
            // Ecrit le groupe dans la variable.
            $this->_currentGroup = $arg_grp;
            $this->_currentGroupInstance = $this->newGroup($arg_grp);
            // Ecrit le groupe dans la session.
            $this->setSessionStore('nebuleSelectedGroup', $arg_grp);
        } else {
            // Sinon vérifie si une valeur n'est pas mémorisée dans la session.
            $cache = $this->getSessionStore('nebuleSelectedGroup');
            // Si il existe une variable de session pour le groupe en cours, la lit.
            if ($cache !== false
                && $cache != ''
            ) {
                $this->_currentGroup = $cache;
                $this->_currentGroupInstance = $this->newGroup($cache);
            } else // Sinon désactive le cache.
            {
                $this->_currentGroup = '0'; // $this->_currentObject;
                $this->_currentGroupInstance = $this->newGroup('0'); // $this->_currentObjectInstance;
                // Ecrit le groupe dans la session.
                $this->setSessionStore('nebuleSelectedGroup', $this->_currentGroup);
            }
            unset($cache);
        }
        unset($arg_grp);

        $this->_metrology->addLog('Find current group ' . $this->_currentGroup, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    /**
     * Donne l'ID du groupe en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return string
     */
    public function getCurrentGroup()
    {
        return $this->_currentGroup;
    }

    /**
     * Donne l'instance du groupe en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return Group
     */
    public function getCurrentGroupInstance()
    {
        return $this->_currentGroupInstance;
    }



    // Gestion de la conversation en cours.

    /**
     * ID de la conversation en cours.
     *
     * @var string
     */
    private $_currentConversation = '';

    /**
     * Instance de la conversation en cours.
     *
     * @var Conversation|null
     */
    private $_currentConversationInstance = null;

    /**
     * Recherche la conversation en cours d'utilisation.
     *
     * Si pas d'argument de définition de l'objet, et si pas dans le cache, l'ID est mis à 0.
     *
     * @return void
     */
    private function _findCurrentConversation()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        if (filter_has_var(INPUT_GET, self::COMMAND_SELECT_CONVERSATION)) {
            $arg_cvt = trim(filter_input(INPUT_GET, self::COMMAND_SELECT_CONVERSATION, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        } else {
            $arg_cvt = trim(filter_input(INPUT_POST, self::COMMAND_SELECT_CONVERSATION, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        }

        // Si la variable est un objet avec ou sans liens.
        if ($arg_cvt != ''
            && (strlen($arg_cvt) >= self::NEBULE_MINIMUM_ID_SIZE
                || $arg_cvt == '0'
            )
            && ctype_xdigit($arg_cvt)
            && ($this->getIO()->checkObjectPresent($arg_cvt)
                || $this->getIO()->checkLinkPresent($arg_cvt)
                || $arg_cvt == '0'
            )
        ) {
            // Ecrit la conversation dans la variable.
            $this->_currentConversation = $arg_cvt;
            $this->_currentConversationInstance = $this->newConversation($arg_cvt);
            // Ecrit la conversation dans la session.
            $this->setSessionStore('nebuleSelectedConversation', $arg_cvt);
        } else {
            // Sinon vérifie si une valeur n'est pas mémorisée dans la session.
            $cache = $this->getSessionStore('nebuleSelectedConversation');
            // Si il existe une variable de session pour la conversation en cours, la lit.
            if ($cache !== false
                && $cache != ''
            ) {
                $this->_currentConversation = $cache;
                $this->_currentConversationInstance = $this->newConversation($cache);
            } else // Sinon désactive le cache.
            {
                $this->_currentConversation = '0'; // $this->_currentObject;
                $this->_currentConversationInstance = $this->newConversation('0'); // $this->_currentObjectInstance;
                // Ecrit la conversation dans la session.
                $this->setSessionStore('nebuleSelectedConversation', $this->_currentConversation);
            }
            unset($cache);
        }
        unset($arg_cvt);

        $this->_metrology->addLog('Find current conversation ' . $this->_currentConversation, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    /**
     * Donne l'ID de la conversation en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return string
     */
    public function getCurrentConversation()
    {
        return $this->_currentConversation;
    }

    /**
     * Donne l'instance de la conversation en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return Conversation
     */
    public function getCurrentConversationInstance()
    {
        return $this->_currentConversationInstance;
    }



    // Gestion de la monnaie en cours.

    /**
     * ID de la monnaie en cours.
     *
     * @var string
     */
    private $_currentCurrency = '';

    /**
     * Instance de la monnaie en cours.
     *
     * @var Currency|null
     */
    private $_currentCurrencyInstance = null;

    /**
     * Recherche la monnaie en cours d'utilisation.
     *
     * Si pas d'argument de définition de l'objet, et si pas dans le cache, l'ID est mis à 0.
     *
     * @return void
     */
    private function _findCurrentCurrency()
    {
        // Si pas autorisé, retourne ID=0.
        if (!$this->getOption('permitCurrency')) {
            $this->_currentCurrency = '0';
            $this->_currentCurrencyInstance = $this->newCurrency('0');
            // Ecrit la monnaie dans la session.
            $this->setSessionStore('nebuleSelectedCurrency', $this->_currentCurrency);
            return;
        }

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        if (filter_has_var(INPUT_GET, self::COMMAND_SELECT_CURRENCY)) {
            $arg = trim(filter_input(INPUT_GET, self::COMMAND_SELECT_CURRENCY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        } else {
            $arg = trim(filter_input(INPUT_POST, self::COMMAND_SELECT_CURRENCY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        }

        // Si la variable est un objet avec ou sans liens.
        if ($arg != ''
            && (strlen($arg) >= self::NEBULE_MINIMUM_ID_SIZE
                || $arg == '0'
            )
            && ctype_xdigit($arg)
            && ($this->getIO()->checkObjectPresent($arg)
                || $this->getIO()->checkLinkPresent($arg)
                || $arg == '0'
            )
        ) {
            // Ecrit la monnaie dans la variable.
            $this->_currentCurrency = $arg;
            $this->_currentCurrencyInstance = $this->newCurrency($arg);
            // Ecrit la monnaie dans la session.
            $this->setSessionStore('nebuleSelectedCurrency', $arg);
        } else {
            // Sinon vérifie si une valeur n'est pas mémorisée dans la session.
            $cache = $this->getSessionStore('nebuleSelectedCurrency');
            // Si il existe une variable de session pour la monnaie en cours, la lit.
            if ($cache !== false
                && $cache != ''
            ) {
                $this->_currentCurrency = $cache;
                $this->_currentCurrencyInstance = $this->newCurrency($cache);
            } else // Sinon désactive le cache.
            {
                $this->_currentCurrency = '0';
                $this->_currentCurrencyInstance = $this->newCurrency('0');
                // Ecrit la monnaie dans la session.
                $this->setSessionStore('nebuleSelectedCurrency', $this->_currentCurrency);
            }
            unset($cache);
        }
        unset($arg);

        $this->_metrology->addLog('Find current currency ' . $this->_currentCurrency, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    /**
     * Donne l'ID de la monnaie en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return string
     */
    public function getCurrentCurrency()
    {
        return $this->_currentCurrency;
    }

    /**
     * Donne l'instance de la monnaie en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return Currency
     */
    public function getCurrentCurrencyInstance()
    {
        return $this->_currentCurrencyInstance;
    }



    // Gestion du sac de jetons en cours.

    /**
     * ID du sac de jetons en cours.
     *
     * @var string
     */
    private $_currentTokenPool = '';

    /**
     * Instance du sac de jetons en cours.
     *
     * @var TokenPool|null
     */
    private $_currentTokenPoolInstance = null;

    /**
     * Recherche le sac de jetons en cours d'utilisation.
     *
     * Si pas d'argument de définition de l'objet, et si pas dans le cache, l'ID est mis à 0.
     *
     * @return void
     */
    private function _findCurrentTokenPool()
    {
        // Si pas autorisé, retourne ID=0.
        if (!$this->getOption('permitCurrency')) {
            $this->_currentTokenPool = '0';
            $this->_currentTokenPoolInstance = $this->newTokenPool('0');
            // Ecrit le sac de jetons dans la session.
            $this->setSessionStore('nebuleSelectedTokenPool', $this->_currentTokenPool);
            return;
        }

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        if (filter_has_var(INPUT_GET, self::COMMAND_SELECT_TOKENPOOL)) {
            $arg = trim(filter_input(INPUT_GET, self::COMMAND_SELECT_TOKENPOOL, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        } else {
            $arg = trim(filter_input(INPUT_POST, self::COMMAND_SELECT_TOKENPOOL, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        }

        // Si la variable est un objet avec ou sans liens.
        if ($arg != ''
            && (strlen($arg) >= self::NEBULE_MINIMUM_ID_SIZE
                || $arg == '0'
            )
            && ctype_xdigit($arg)
            && ($this->getIO()->checkObjectPresent($arg)
                || $this->getIO()->checkLinkPresent($arg)
                || $arg == '0'
            )
        ) {
            // Ecrit le sac de jetons dans la variable.
            $this->_currentTokenPool = $arg;
            $this->_currentTokenPoolInstance = $this->newTokenPool($arg);
            // Ecrit le sac de jetons dans la session.
            $this->setSessionStore('nebuleSelectedTokenPool', $arg);
        } else {
            // Sinon vérifie si une valeur n'est pas mémorisée dans la session.
            $cache = $this->getSessionStore('nebuleSelectedTokenPool');
            // Si il existe une variable de session pour le sac de jetons en cours, la lit.
            if ($cache !== false
                && $cache != ''
            ) {
                $this->_currentTokenPool = $cache;
                $this->_currentTokenPoolInstance = $this->newTokenPool($cache);
            } else // Sinon désactive le cache.
            {
                $this->_currentTokenPool = '0';
                $this->_currentTokenPoolInstance = $this->newTokenPool('0');
                // Ecrit le sac de jetons dans la session.
                $this->setSessionStore('nebuleSelectedTokenPool', $this->_currentTokenPool);
            }
            unset($cache);
        }
        unset($arg);

        $this->_metrology->addLog('Find current token pool ' . $this->_currentTokenPool, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    /**
     * Donne l'ID du sac de jetons en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return string
     */
    public function getCurrentTokenPool()
    {
        return $this->_currentTokenPool;
    }

    /**
     * Donne l'instance du sac de jetons en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return TokenPool
     */
    public function getCurrentTokenPoolInstance()
    {
        return $this->_currentTokenPoolInstance;
    }



    // Gestion du jeton en cours.

    /**
     * ID du jeton en cours.
     *
     * @var string
     */
    private $_currentToken = '';

    /**
     * Instance du jeton en cours.
     *
     * @var Token|null
     */
    private $_currentTokenInstance = null;

    /**
     * Recherche le jeton en cours d'utilisation.
     *
     * Si pas d'argument de définition de l'objet, et si pas dans le cache, l'ID est mis à 0.
     *
     * @return void
     */
    private function _findCurrentToken()
    {
        // Si pas autorisé, retourne ID=0.
        if (!$this->getOption('permitCurrency')) {
            $this->_currentToken = '0';
            $this->_currentTokenInstance = $this->newToken('0');
            // Ecrit le jeton dans la session.
            $this->setSessionStore('nebuleSelectedToken', $this->_currentToken);
            return;
        }

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        if (filter_has_var(INPUT_GET, self::COMMAND_SELECT_TOKEN)) {
            $arg = trim(filter_input(INPUT_GET, self::COMMAND_SELECT_TOKEN, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        } else {
            $arg = trim(filter_input(INPUT_POST, self::COMMAND_SELECT_TOKEN, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        }

        // Si la variable est un objet avec ou sans liens.
        if ($arg != ''
            && (strlen($arg) >= self::NEBULE_MINIMUM_ID_SIZE
                || $arg == '0'
            )
            && ctype_xdigit($arg)
            && ($this->getIO()->checkObjectPresent($arg)
                || $this->getIO()->checkLinkPresent($arg)
                || $arg == '0'
            )
        ) {
            // Ecrit le jeton dans la variable.
            $this->_currentToken = $arg;
            $this->_currentTokenInstance = $this->newToken($arg);
            // Ecrit le jeton dans la session.
            $this->setSessionStore('nebuleSelectedToken', $arg);
        } else {
            // Sinon vérifie si une valeur n'est pas mémorisée dans la session.
            $cache = $this->getSessionStore('nebuleSelectedToken');
            // Si il existe une variable de session pour le jeton en cours, la lit.
            if ($cache !== false
                && $cache != ''
            ) {
                $this->_currentToken = $cache;
                $this->_currentTokenInstance = $this->newToken($cache);
            } else // Sinon désactive le cache.
            {
                $this->_currentToken = '0';
                $this->_currentTokenInstance = $this->newToken('0');
                // Ecrit le jeton dans la session.
                $this->setSessionStore('nebuleSelectedToken', $this->_currentToken);
            }
            unset($cache);
        }
        unset($arg);

        $this->_metrology->addLog('Find current token ' . $this->_currentToken, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    /**
     * Donne l'ID du jeton en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return string
     */
    public function getCurrentToken()
    {
        return $this->_currentToken;
    }

    /**
     * Donne l'instance du jeton en cours.
     *
     * Si non définit, l'ID est à 0.
     *
     * @return Token
     */
    public function getCurrentTokenInstance()
    {
        return $this->_currentTokenInstance;
    }


    /**
     * Vérification du niveau de cohérence et d'utilisation de l'instance.
     * - à 0, il y a un problème grave, le maître manque ;
     * - de 1 à 4, il manque une entité importante ;
     * - à 32, il manque l'entité de l'instance locale ;
     * - à 64, l'instance est prête mais non utilisée ;
     * - à 128, l'instance est prête et utilisée. Une entité courante a été trouvée.
     *
     * @return integer
     */
    public function checkInstance()
    {
        // Vérifie que le maître est une entité et est bien celui définit par la constante.
        if (!$this->_puppetmasterInstance instanceof Entity) return 0;
        if ($this->_puppetmasterInstance->getID() != $this->getOption('puppetmaster')) return 0;
        // Vérifie que le maître de la sécurité est une entité et a été trouvé.
        if (!$this->_securityMasterInstance instanceof Entity) return 1;
        if ($this->_securityMasterInstance->getID() == '0') return 1;
        // Vérifie que le maître du code est une entité et a été trouvé.
        if (!$this->_codeMasterInstance instanceof Entity) return 2;
        if ($this->_codeMasterInstance->getID() == '0') return 2;
        // Vérifie que le maître de l'annuaire est une entité et a été trouvé.
        if (!$this->_directoryMasterInstance instanceof Entity) return 3;
        if ($this->_directoryMasterInstance->getID() == '0') return 3;
        // Vérifie que le maître du temps est une entité et a été trouvé.
        if (!$this->_timeMasterInstance instanceof Entity) return 4;
        if ($this->_timeMasterInstance->getID() == '0') return 4;

        // Vérifie que l'entité de l'instance nebule est une entité et a été trouvée.
        if (!$this->_instanceEntityInstance instanceof Entity) return 32;
        if ($this->_instanceEntityInstance->getID() == '0') return 32;

        // Vérifie qu'une entité courante existe et est une entité.
        if (!$this->_currentEntityInstance instanceof Entity) return 64;
        if ($this->_currentEntityInstance->getID() == '0') return 64;

        // Tout est bon et l'instance est utilisée.
        return 128;
    }


    /**
     * Le maître du tout.
     *
     * @var string
     */
    private $_puppetmaster = '';

    /**
     * L'instance du maître du tout.
     *
     * @var Entity|null
     */
    private $_puppetmasterInstance = null;

    /**
     * Récupération du maître.
     *
     * Définit par une option ou en dur dans une constante.
     *
     * @return null
     */
    private function _findPuppetmaster()
    {
        $this->_puppetmaster = $this->getOption('puppetmaster');
        $this->_puppetmasterInstance = $this->newEntity($this->_puppetmaster);
        $this->_metrology->addLog('Find puppetmaster ' . $this->_puppetmaster, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    /**
     * Donne l'ID du maître du tout.
     *
     * @return string
     */
    public function getPuppetmaster()
    {
        return $this->_puppetmaster;
    }

    /**
     * Donne l'instance du maître du tout.
     *
     * @return Entity|NULL
     */
    public function getPuppetmasterInstance()
    {
        return $this->_puppetmasterInstance;
    }


    /**
     * Recherche une entité pour un rôle.
     *
     * Ne tien compte que des liens du puppetmaster uniquement.
     *
     * @param $type string
     * @return string
     */
    private function _findEntityByType($type)
    {
        if ($type == '') {
            return $this->_puppetmaster;
        }

        $typeID = $this->_crypto->hash($type);
        $typeInstance = $this->newObject($typeID);

        // Recherche les liens signés du maître du tout de type f avec source et méta le rôle recherché.
        $list = $typeInstance->readLinksFilterFull(
            $this->_puppetmaster,
            '',
            'f',
            $typeID,
            '',
            $typeID);

        if (sizeof($list) == 0) {
            return $this->_puppetmaster;
        }

        $link = reset($list);
        unset($list);
        return $link->getHashTarget();
    }


    /**
     * L'ID du maître de la sécurité.
     */
    private $_securityMaster = '';

    /**
     * L'instance du maître de la sécurité.
     */
    private $_securityMasterInstance = null;

    /**
     * Récupération du maître de la sécurité.
     */
    private function _findSecurityMaster()
    {
        if ($this->_securityMaster != '') {
            return;
        }

        $type = self::REFERENCE_NEBULE_OBJET_ENTITE_MAITRE_SECURITE;
        $this->_securityMaster = $this->_findEntityByType($type);
        $this->_securityMasterInstance = $this->newEntity($this->_securityMaster);

        $this->_metrology->addLog('Find security master ' . $this->_securityMaster, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    public function getSecurityAuthority()
    {
        return $this->_securityMaster;
    }

    public function getSecurityAuthorityInstance()
    {
        return $this->_securityMasterInstance;
    }

    /**
     * L'ID du maître du code.
     */
    private $_codeMaster;

    /**
     * L'instance du maître du code.
     */
    private $_codeMasterInstance;

    /**
     * Récupération du maître du code.
     */
    private function _findCodeMaster()
    {
        if ($this->_codeMaster != '') {
            return;
        }

        $type = self::REFERENCE_NEBULE_OBJET_ENTITE_MAITRE_CODE;
        $this->_codeMaster = $this->_findEntityByType($type);
        $this->_codeMasterInstance = $this->newEntity($this->_codeMaster);

        $this->_metrology->addLog('Find code master ' . $this->_codeMaster, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    public function getCodeAuthority()
    {
        return $this->_codeMaster;
    }

    public function getCodeAuthorityInstance()
    {
        return $this->_codeMasterInstance;
    }

    /**
     * Le maître de l'annuaire.
     */
    private $_directoryMaster;

    /**
     * L'instance du maître de l'annuaire.
     */
    private $_directoryMasterInstance;

    /**
     * Récupération du maître de l'annuaire.
     */
    private function _findDirectoryMaster()
    {
        if ($this->_directoryMaster != '') {
            return;
        }

        $type = self::REFERENCE_NEBULE_OBJET_ENTITE_MAITRE_ANNUAIRE;
        $this->_directoryMaster = $this->_findEntityByType($type);
        $this->_directoryMasterInstance = $this->newEntity($this->_directoryMaster);

        $this->_metrology->addLog('Find directory master ' . $this->_directoryMaster, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    public function getDirectoryAuthority()
    {
        return $this->_directoryMaster;
    }

    public function getDirectoryAuthorityInstance()
    {
        return $this->_directoryMasterInstance;
    }

    /**
     * Le maître du temps.
     */
    private $_timeMaster;

    /**
     * L'instance du maître du temps.
     */
    private $_timeMasterInstance;

    /**
     * Récupération du maître du temps.
     */
    private function _findTimeMaster()
    {
        if ($this->_timeMaster != '') {
            return;
        }

        $type = self::REFERENCE_NEBULE_OBJET_ENTITE_MAITRE_TEMPS;
        $this->_timeMaster = $this->_findEntityByType($type);
        $this->_timeMasterInstance = $this->newEntity($this->_timeMaster);

        $this->_metrology->addLog('Find time master ' . $this->_timeMaster, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    public function getTimeAuthority()
    {
        return $this->_timeMaster;
    }

    public function getTimeAuthorityInstance()
    {
        return $this->_timeMasterInstance;
    }

    /**
     * Liste des ID des autorités.
     * @var array
     */
    private $_authorities = array();

    /**
     * Liste des instances des autorités.
     * @var array
     */
    private $_authoritiesInstances = array();

    /**
     * Liste des ID des autorités locales.
     * @var array:string
     */
    private $_localAuthorities = array();

    /**
     * Liste des instance des autorités locales.
     * @var array:Entity
     */
    private $_localAuthoritiesInstances = array();

    /**
     * Liste des ID des autorités locales primaires.
     * @var array:string
     */
    private $_localPrimaryAuthorities = array();

    /**
     * Liste des instance des autorités locales primaires.
     * @var array:Entity
     */
    private $_localPrimaryAuthoritiesInstances = array();

    /**
     * Liste des entités signataires des autorités locales.
     * @var array:string
     */
    private $_localAuthoritiesSigners = array();

    /**
     * Liste des ID des entités avec des rôles.
     * @var array
     */
    private $_specialEntities = array();


    /**
     * L'entité locale du serveur est-elle autorité locale ?
     * @var boolean
     */
    private $_permitInstanceEntityAsAuthority = false;

    /**
     * L'entité locale par défaut est-elle autorité locale ?
     * @var boolean
     */
    private $_permitDefaultEntityAsAuthority = false;

    /**
     * Ajoute les autorités locales par défaut.
     *
     * @return void
     */
    private function _findLocalAuthorities()
    {
        // Ajoute les entités de nebule.
        $this->_authorities[$this->_puppetmaster] = $this->_puppetmaster;
        $this->_authoritiesInstances[$this->_puppetmaster] = $this->_puppetmasterInstance;
        $this->_specialEntities[$this->_puppetmaster] = $this->_puppetmaster;
        $this->_authorities[$this->_securityMaster] = $this->_securityMaster;
        $this->_authoritiesInstances[$this->_securityMaster] = $this->_securityMasterInstance;
        $this->_specialEntities[$this->_securityMaster] = $this->_securityMaster;
        $this->_authorities[$this->_codeMaster] = $this->_codeMaster;
        $this->_authoritiesInstances[$this->_codeMaster] = $this->_codeMasterInstance;
        $this->_specialEntities[$this->_codeMaster] = $this->_codeMaster;
        $this->_localAuthorities[$this->_codeMaster] = $this->_codeMaster;
        $this->_localAuthoritiesInstances[$this->_codeMaster] = $this->_codeMasterInstance;
        $this->_localAuthoritiesSigners[$this->_codeMaster] = $this->_puppetmaster;
        $this->_specialEntities[$this->_directoryMaster] = $this->_directoryMaster;
        $this->_specialEntities[$this->_timeMaster] = $this->_timeMaster;
    }

    /**
     * Ajoute si autorisé l'entité instance du serveur comme autorité locale.
     * Désactivé automatiquement en mode récupération.
     *
     * @return void
     */
    private function _addInstanceEntityAsAuthorities()
    {
        // Ajoute si nécessaire l'entité du serveur.
        if (!$this->_modeRescue)
            $this->_permitInstanceEntityAsAuthority = $this->getOption('permitInstanceEntityAsAuthority');
        else
            $this->_permitInstanceEntityAsAuthority = false;

        if ($this->_permitInstanceEntityAsAuthority) {
            $this->_authorities[$this->_instanceEntity] = $this->_instanceEntity;
            $this->_authoritiesInstances[$this->_instanceEntity] = $this->_instanceEntityInstance;
            $this->_specialEntities[$this->_instanceEntity] = $this->_instanceEntity;
            $this->_localAuthorities[$this->_instanceEntity] = $this->_instanceEntity;
            $this->_localAuthoritiesInstances[$this->_instanceEntity] = $this->_instanceEntityInstance;
            $this->_localAuthoritiesSigners[$this->_instanceEntity] = '0';
            $this->_localPrimaryAuthorities[$this->_instanceEntity] = $this->_instanceEntity;
            $this->_localPrimaryAuthoritiesInstances[$this->_instanceEntity] = $this->_instanceEntityInstance;

            $this->_metrology->addLog('Add instance entity as authority', Metrology::LOG_LEVEL_DEBUG); // Log
        }
    }

    /**
     * Ajoute si autorisé l'entité par défaut comme autorité locale.
     * Désactivé automatiquement en mode récupération.
     *
     * @return void
     */
    private function _addDefaultEntityAsAuthorities()
    {
        // Ajoute si nécessaire l'entité par défaut.
        if (!$this->_modeRescue)
            $this->_permitDefaultEntityAsAuthority = $this->getOption('permitDefaultEntityAsAuthority');
        else
            $this->_permitDefaultEntityAsAuthority = false;

        if ($this->_permitDefaultEntityAsAuthority) {
            $this->_authorities[$this->_defaultEntity] = $this->_defaultEntity;
            $this->_authoritiesInstances[$this->_defaultEntity] = $this->_defaultEntityInstance;
            $this->_specialEntities[$this->_defaultEntity] = $this->_defaultEntity;
            $this->_localAuthorities[$this->_defaultEntity] = $this->_defaultEntity;
            $this->_localAuthoritiesInstances[$this->_defaultEntity] = $this->_defaultEntityInstance;
            $this->_localAuthoritiesSigners[$this->_defaultEntity] = '0';
            $this->_localPrimaryAuthorities[$this->_defaultEntity] = $this->_defaultEntity;
            $this->_localPrimaryAuthoritiesInstances[$this->_defaultEntity] = $this->_defaultEntityInstance;

            $this->_metrology->addLog('Add default entity as authority', Metrology::LOG_LEVEL_DEBUG); // Log
        }
    }

    /**
     * Ajoute des autres entité marqués comme autorités locales.
     *
     * @return void
     */
    private function _addLocalAuthorities()
    {
        // Vérifie si les entités autorités locales sont autorisées.
        if (!$this->getOption('permitLocalSecondaryAuthorities'))
            return;

        $refAuthority = $this->_crypto->hash(self::REFERENCE_NEBULE_OBJET_ENTITE_AUTORITE_LOCALE);

        // Liste les liens de l'entité instance du serveur..
        $list = array();
        if ($this->_permitInstanceEntityAsAuthority) {
            $list = $this->_instanceEntityInstance->readLinksFilterFull(
                $this->_instanceEntity,
                '',
                'f',
                $this->_instanceEntity,
                '',
                $refAuthority
            );
        }

        foreach ($list as $link) {
            $target = $link->getHashTarget();
            $instance = $this->newEntity($target);
            $this->_localAuthorities[$target] = $target;
            $this->_localAuthoritiesInstances[$target] = $instance;
            $this->_specialEntities[$target] = $target;
            $this->_localAuthoritiesSigners[$target] = $link->getHashSigner();
            $this->_authorities[$target] = $target;
            $this->_authoritiesInstances[$target] = $instance;
        }

        // Liste les liens de l'entité instance du serveur..
        $list = array();
        if ($this->_permitDefaultEntityAsAuthority) {
            $list = $this->_instanceEntityInstance->readLinksFilterFull(
                $this->_defaultEntity,
                '',
                'f',
                $this->_instanceEntity,
                '',
                $refAuthority
            );
        }

        foreach ($list as $link) {
            $target = $link->getHashTarget();
            $instance = $this->newEntity($target);
            $this->_localAuthorities[$target] = $target;
            $this->_localAuthoritiesInstances[$target] = $instance;
            $this->_specialEntities[$target] = $target;
            $this->_localAuthoritiesSigners[$target] = $link->getHashSigner();
            $this->_authorities[$target] = $target;
            $this->_authoritiesInstances[$target] = $instance;
        }
        unset($list);
    }

    /**
     * Lit la liste des ID des autorités.
     *
     * @return array:string
     */
    public function getAuthorities()
    {
        return $this->_authorities;
    }

    /**
     * Lit la liste des instance des autorités.
     *
     * @return array:Entity
     */
    public function getAuthoritiesInstance()
    {
        return $this->_authoritiesInstances;
    }

    /**
     * Lit la liste des ID des autorités locales.
     *
     * @return array:string
     */
    public function getLocalAuthorities()
    {
        return $this->_localAuthorities;
    }

    /**
     * Lit la liste des instance des autorités locales.
     *
     * @return array:Entity
     */
    public function getLocalAuthoritiesInstance()
    {
        return $this->_localAuthoritiesInstances;
    }

    /**
     * Lit la liste des autorités locales déclarants des autorités locales.
     *
     * @return array:string
     */
    public function getLocalAuthoritiesSigners()
    {
        return $this->_localAuthoritiesSigners;
    }

    /**
     * Lit la liste des ID des autorités locales.
     *
     * @return array:string
     */
    public function getLocalPrimaryAuthorities()
    {
        return $this->_localPrimaryAuthorities;
    }

    /**
     * Lit la liste des instance des autorités locales.
     *
     * @return array:Entity
     */
    public function getLocalPrimaryAuthoritiesInstance()
    {
        return $this->_localPrimaryAuthoritiesInstances;
    }

    /**
     * Lit la liste des ID des entités avec des rôles.
     *
     * @return array:string
     */
    public function getSpecialEntities()
    {
        return $this->_specialEntities;
    }

    /**
     * Retourne si l'entité est autorité locale.
     *
     * @param Entity|string $entity
     * @return boolean
     */
    public function getIsLocalAuthority($entity)
    {
        if (is_a($entity, 'Node'))
            $entity = $entity->getID();
        if ($entity == '0')
            return false;

        foreach ($this->_localAuthorities as $authority) {
            if ($entity == $authority)
                return true;
        }
        return false;
    }


    /**
     * Liste des entités de recouvrement.
     * @var array:string
     */
    private $_recoveryEntities = array();

    /**
     * Liste des instances des entités de recouvrement.
     * @var array:Entity
     */
    private $_recoveryEntitiesInstances = array();

    /**
     * Liste des autorités locales déclarants les entités de recouvrement.
     * @var array:string
     */
    private $_recoveryEntitiesSigners = array();

    /**
     * L'entité locale du serveur est-elle entité de recouvrement locale ?
     * @var boolean
     */
    private $_permitInstanceEntityAsRecovery = false;

    /**
     * L'entité locale par défaut est-elle entité de recouvrement locale ?
     * @var boolean
     */
    private $_permitDefaultEntityAsRecovery = false;

    /**
     * Ajoute si autorisé l'entité instance du serveur comme entité de recouvrement locale.
     *
     * @return void
     */
    private function _addInstanceEntityAsRecovery()
    {
        // Vérifie si les entités de recouvrement sont autorisées.
        if (!$this->getOption('permitRecoveryEntities'))
            return;

        $this->_permitInstanceEntityAsRecovery = $this->getOption('permitInstanceEntityAsRecovery');

        if ($this->_permitInstanceEntityAsRecovery) {
            $this->_recoveryEntities[$this->_instanceEntity] = $this->_instanceEntity;
            $this->_recoveryEntitiesInstances[$this->_instanceEntity] = $this->_instanceEntityInstance;
            $this->_recoveryEntitiesSigners[$this->_instanceEntity] = '0';

            $this->_metrology->addLog('Add instance entity as recovery', Metrology::LOG_LEVEL_DEBUG); // Log
        }
    }

    /**
     * Ajoute si autorisé l'entité par défaut comme entité de recouvrement locale.
     *
     * @return void
     */
    private function _addDefaultEntityAsRecovery()
    {
        // Vérifie si les entités de recouvrement sont autorisées.
        if (!$this->getOption('permitRecoveryEntities'))
            return;

        $this->_permitDefaultEntityAsRecovery = $this->getOption('permitDefaultEntityAsRecovery');

        if ($this->_permitDefaultEntityAsRecovery) {
            $this->_recoveryEntities[$this->_defaultEntity] = $this->_defaultEntity;
            $this->_recoveryEntitiesInstances[$this->_defaultEntity] = $this->_defaultEntityInstance;
            $this->_recoveryEntitiesSigners[$this->_defaultEntity] = '0';

            $this->_metrology->addLog('Add default entity as recovery', Metrology::LOG_LEVEL_DEBUG); // Log
        }
    }

    /**
     * Recherche les entités de recouvrement valables.
     *
     * @return void
     */
    private function _findRecoveryEntities()
    {
        $this->_recoveryEntities = array();
        $this->_recoveryEntitiesInstances = array();

        // Vérifie si les entités de recouvrement sont autorisées.
        if (!$this->getOption('permitRecoveryEntities'))
            return;

        $refRecovery = $this->_crypto->hash(self::REFERENCE_NEBULE_OBJET_ENTITE_RECOUVREMENT);

        // Liste les liens de l'entité instance du serveur..
        $list = array();
        if ($this->_permitInstanceEntityAsAuthority) {
            $list = $this->_instanceEntityInstance->readLinksFilterFull(
                $this->_instanceEntity,
                '',
                'f',
                $this->_instanceEntity,
                '',
                $refRecovery
            );
        }

        foreach ($list as $link) {
            $target = $link->getHashTarget();
            $instance = $this->newEntity($target);
            $this->_recoveryEntities[$target] = $target;
            $this->_recoveryEntitiesInstances[$target] = $instance;
            $this->_recoveryEntitiesSigners[$target] = $link->getHashSigner();
        }

        // Liste les liens de l'entité instance du serveur..
        $list = array();
        if ($this->_permitDefaultEntityAsAuthority) {
            $list = $this->_instanceEntityInstance->readLinksFilterFull(
                $this->_defaultEntity,
                '',
                'f',
                $this->_instanceEntity,
                '',
                $refRecovery
            );
        }

        foreach ($list as $link) {
            $target = $link->getHashTarget();
            $instance = $this->newEntity($target);
            $this->_recoveryEntities[$target] = $target;
            $this->_recoveryEntitiesInstances[$target] = $instance;
            $this->_recoveryEntitiesSigners[$target] = $link->getHashSigner();
        }
        unset($list);
    }

    /**
     * Lit la liste des ID des entités de recouvrement.
     *
     * @return array:string
     */
    public function getRecoveryEntities()
    {
        return $this->_recoveryEntities;
    }

    /**
     * Lit la liste des instance des entités de recouvrement.
     *
     * @return array:Entity
     */
    public function getRecoveryEntitiesInstance()
    {
        return $this->_recoveryEntitiesInstances;
    }

    /**
     * Lit la liste des autorités locales déclarants les entités de recouvrement.
     *
     * @return array:string
     */
    public function getRecoveryEntitiesSigners()
    {
        return $this->_recoveryEntitiesSigners;
    }

    /**
     * Retourne si l'entité est entité de recouvrement.
     *
     * @param Entity|string $entity
     * @return boolean
     */
    public function getIsRecoveryEntity($entity)
    {
        if (is_a($entity, 'Node'))
            $entity = $entity->getID();
        if ($entity == '0')
            return false;

        foreach ($this->_recoveryEntities as $recovery) {
            if ($entity == $recovery)
                return true;
        }
        return false;
    }


    /**
     * Export l'objets des entrées/sorties.
     *
     * @return io
     */
    public function getIO()
    {
        return $this->_io;
    }

    /**
     * Export l'objets de la crypto.
     *
     * @return Crypto
     */
    public function getCrypto()
    {
        return $this->_crypto;
    }

    /**
     * Export l'objets du calcul social.
     *
     * @return Social
     */
    public function getSocial()
    {
        return $this->_social;
    }

    /**
     * Export l'objets de la métrologie.
     *
     * @return Metrology
     */
    public function getMetrologyInstance()
    {
        return $this->_metrology;
    }


    /**
     * Retourne la liste des instances de toutes les entités loacles.
     *
     * @return array:Entity
     */
    public function getListEntitiesInstances()
    {
        $hashType = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE);
        $hashEntity = $this->_crypto->hash('application/x-pem-file');
        $hashEntityObject = $this->newObject($hashEntity);

        // Liste les liens.
        $links = $hashEntityObject->readLinksFilterFull('', '', 'l', '', $hashEntity, $hashType);
        unset($hashType, $hashEntity, $hashEntityObject);

        // Filtre les entités sur le contenu de l'objet de la clé publique. @todo
        $result = array();
        $id = '';
        $instance = null;
        foreach ($links as $link) {
            $id = $link->getHashSource();
            $instance = $this->newEntity($id);
            if ($instance->getIsPublicKey())
                $result[$id] = $instance;
        }

        unset($links, $link, $id, $instance);
        return $result;
    }

    /**
     * Retourne la liste des ID de toutes les entités loacles.
     *
     * @return array:string
     */
    public function getListEntitiesID()
    {
        // Liste les instances.
        $list = $this->getListEntitiesInstances();
        $result = array();

        // Filtre les entités sur le contenu de l'objet de la clé publique. @todo
        foreach ($list as $instance) {
            $id = $instance->getID();
            $result[$id] = $id;
        }

        unset($list, $instance);
        return $result;
    }


    /**
     * Variable de mode de récupération.
     *
     * @var boolean
     */
    private $_modeRescue = false;

    /**
     * Extrait si on est en mode de récupération.
     *
     * @return null
     */
    private function _findModeRescue()
    {
        if ($this->getOption('modeRescue')
            || ($this->getOption('permitOnlineRescue')
                && (filter_has_var(INPUT_GET, nebule::COMMAND_RESCUE)
                    || filter_has_var(INPUT_POST, nebule::COMMAND_RESCUE)
                )
            )
        )
            $this->_modeRescue = true;
    }

    /**
     * Retourne si le mode de récupération est activé.
     * @return boolean
     */
    public function getModeRescue()
    {
        return $this->_modeRescue;
    }


    /**
     * Extrait et analyse un lien.
     *
     * Accepte une chaine de caractère représentant un lien.
     * En fonction du nombre de champs, c'est interprété :
     * 2 champs : 0_0_0_action_source_0_0
     * 3 champs : 0_0_0_action_source_target_0
     * 4 champs : 0_0_0_action_source_target_meta
     * 5 champs : 0_0_date_action_source_target_meta
     * 6 champs : 0_signer_date_action_source_target_meta
     * 7 champs : signe_signer_date_action_source_target_meta
     * Sinon    : 0_0_0_0_0_0_0
     *
     * Retourne un tableau des constituants du lien :
     * [signature, signataire, date, action, source, destination, méta]
     * Les champs non renseignés sont à '0'.
     *
     * @param string $link : lien à extraire.
     * @return array:string : un tableau des champs (signature, signataire, date, action, source, destination, méta).
     */
    public function flatLinkExtractAsArray($link)
    {
        // Variables.
        $list = array();
        $date = date(DATE_ATOM);
        $ent = $this->_currentEntity;

        // Extraction du lien.
        $arg1 = strtok($link, '_');
        $arg2 = strtok('_');
        $arg3 = strtok('_');
        $arg4 = strtok('_');
        $arg5 = strtok('_');
        $arg6 = strtok('_');
        $arg7 = strtok('_');

        // Nettoyage du lien.
        if ($arg1 != '' && $arg2 != '' && $arg3 != '' && $arg4 != '' && $arg5 != '' && $arg6 != '' && $arg7 != '') {
            // Forme : signe_signer_date_action_source_target_meta
            $list = array($arg1, $arg2, $arg3, $arg4, $arg5, $arg6, $arg7);
        } elseif ($arg1 != '' && $arg2 != '' && $arg3 != '' && $arg4 != '' && $arg5 != '' && $arg6 != '' && $arg7 == '') {
            // Forme : 0_signer_date_action_source_target_meta
            $list = array('0', $arg1, $arg2, $arg3, $arg4, $arg5, $arg6);
        } elseif ($arg1 != '' && $arg2 != '' && $arg3 != '' && $arg4 != '' && $arg5 != '' && $arg6 == '' && $arg7 == '') {
            // Forme : 0_0_date_action_source_target_meta
            $list = array('0', $ent, $arg1, $arg2, $arg3, $arg4, $arg5);
        } elseif ($arg1 != '' && $arg2 != '' && $arg3 != '' && $arg4 != '' && $arg5 == '' && $arg6 == '' && $arg7 == '') {
            // Forme : 0_0_0_action_source_target_meta
            $list = array('0', $ent, $date, $arg1, $arg2, $arg3, $arg4);
        } elseif ($arg1 != '' && $arg2 != '' && $arg3 != '' && $arg4 == '' && $arg5 == '' && $arg6 == '' && $arg7 == '') {
            // Forme : 0_0_0_action_source_target_0
            $list = array('0', $ent, $date, $arg1, $arg2, $arg3, '0');
        } elseif ($arg1 != '' && $arg2 != '' && $arg3 == '' && $arg4 == '' && $arg5 == '' && $arg6 == '' && $arg7 == '') {
            // Forme : 0_0_0_action_source_0_0 : le minimum !
            $list = array('0', $ent, $date, $arg1, $arg2, '0', '0');
        } else {
            $list = array('0', '0', '0', '0', '0', '0', '0');
        }

        unset($date, $arg1, $arg2, $arg3, $arg4, $arg5, $arg6, $arg7);
        return $list;
    }

    /**
     * Extrait et analyse un lien.
     * @param string $link : lien à extraire.
     * @return Link : une instance de lien.
     * @todo
     *
     * Accepte une chaine de caractère représentant un lien.
     * En fonction du nombre de champs, c'est interprété :
     * 2 champs : 0_0_0_action_source_0_0
     * 3 champs : 0_0_0_action_source_target_0
     * 4 champs : 0_0_0_action_source_target_meta
     * 5 champs : 0_0_date_action_source_target_meta
     * 6 champs : 0_signer_date_action_source_target_meta
     * 7 champs : signe_signer_date_action_source_target_meta
     * Sinon    : 0_0_0_0_0_0_0
     *
     * Retourne une instance du lien.
     *
     */
    public function flatLinkExtractAsInstance($link)
    {
        // Vérifier compatibilité avec liens incomplets...

        // Extrait le lien.
        $linkArray = $this->flatLinkExtractAsArray($link);

        // Création du lien.
        $flatLink = $linkArray[0] . '_' . $linkArray[1] . '_' . $linkArray[2] . '_' . $linkArray[3] . '_' . $linkArray[4] . '_' . $linkArray[5] . '_' . $linkArray[6];
        $linkInstance = $this->newLink($flatLink);

        unset($linkArray, $flatLink);
        return $linkInstance;
    }


    /**
     * Comparateur de dates.
     * @param string $date1
     * @param string $date2
     * @todo
     *
     */
    public function dateCompare($date1, $date2)
    {
        if ($date1 == '') return false;
        if ($date2 == '') return false;
        // Extrait les éléments d'une date.
        $d1 = date_parse($date1);
        if ($d1 === false) return 0;
        $d2 = date_parse($date2);
        if ($d2 === false) return 0;
        // Année
        if ($d1['year'] > $d2['year']) return 1;
        if ($d1['year'] < $d2['year']) return -1;
        // Mois
        if ($d1['month'] === false) return 0;
        if ($d2['month'] === false) return 0;
        if ($d1['month'] > $d2['month']) return 1;
        if ($d1['month'] < $d2['month']) return -1;
        // Jour
        if ($d1['day'] === false) return 0;
        if ($d2['day'] === false) return 0;
        if ($d1['day'] > $d2['day']) return 1;
        if ($d1['day'] < $d2['day']) return -1;
        // Heure
        if ($d1['hour'] === false) return 0;
        if ($d2['hour'] === false) return 0;
        if ($d1['hour'] > $d2['hour']) return 1;
        if ($d1['hour'] < $d2['hour']) return -1;
        // Minute
        if ($d1['minute'] === false) return 0;
        if ($d2['minute'] === false) return 0;
        if ($d1['minute'] > $d2['minute']) return 1;
        if ($d1['minute'] < $d2['minute']) return -1;
        // Seconde
        if ($d1['second'] === false) return 0;
        if ($d2['second'] === false) return 0;
        if ($d1['second'] > $d2['second']) return 1;
        if ($d1['second'] < $d2['second']) return -1;
        // Fraction de seconde
        if ($d1['fraction'] === false) return 0;
        if ($d2['fraction'] === false) return 0;
        if ($d1['fraction'] > $d2['fraction']) return 1;
        if ($d1['fraction'] < $d2['fraction']) return -1;
        return 0;
        // A faire... comparateur universel sur multiples formats de dates...
    }


    /**
     * Détermine si on doit vider le cache des objets et effacer la session utilisateur.
     *
     * @return null
     */
    private function _findFlushCache()
    {
        global $bootstrap_flush;

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        //if ( filter_has_var(INPUT_GET, self::COMMAND_FLUSH) )
        if ($bootstrap_flush) {
            $this->_metrology->addLog('Ask flush cache', Metrology::LOG_LEVEL_NORMAL); // Log
            // Enregistre la demande de le pas alimenter le cache des entités/objets et liens.
            $this->_flushCache = true;

            /*$this->_metrology->addLog('Flush user session', Metrology::LOG_LEVEL_NORMAL); // Log
			// Flush la session utilisateur.
			session_start();
			session_unset();
			session_destroy();
			session_write_close();
			setcookie(session_name(), '', 0, '/');
			session_regenerate_id(true);
			// Reouvre une nouvelle session pour la suite.
			session_start();
			session_write_close();*/
        }
    }

    /**
     * Retourne si le cache des objets et la session utilisateur ont été effacés.
     *
     * @return boolean
     */
    public function getFlushCache()
    {
        return $this->_flushCache;
    }


    /**
     * Crée et écrit un objet avec du texte.
     * @param string $text
     * @param boolean $protect
     */
    public function createTextAsObject(string &$text, bool $protect = false, bool $obfuscate = false)
    {
        // Vérifie que l'écriture est autorisée.
        if ($this->getOption('permitWrite')
            && $this->getOption('permitWriteObject')
            && $this->getOption('permitWriteLink')
            && $this->_currentEntityUnlocked
            && strlen($text) != 0
        ) {
            // Calcule l'ID de l'objet à créer.
            $id = $this->_crypto->hash($text);

            // Vérifie si l'ID n'existe pas déjà.
            if ($this->_io->checkObjectPresent($id))
                return $id;

            // Ecrit l'objet.
            $instance = new Node($this, '0', $text, $protect, $obfuscate);
            $id = $instance->getID();
            if ($id == '0')
                return false;

            // Définition de la date.
            $date = date(DATE_ATOM);
            $signer = $this->_currentEntity;

            // Crée le lien de type d'objet.
            $action = 'l';
            $source = $id;
            $target = $this->getCrypto()->hash('text/plain');
            $meta = $this->getCrypto()->hash(self::REFERENCE_NEBULE_OBJET_TYPE);
            $link = '_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
            $newLink = new Link($this->_nebuleInstance, $link);

            // Signe le lien.
            $newLink->sign();

            // Si besoin, obfuscation du lien.
            if ($obfuscate)
                $link->obfuscate();
            // Ecrit le lien.
            $newLink->write();

            unset($signer, $date, $action, $source, $target, $meta, $link, $newLink);

            return $id;
        } else
            return false;
    }


    /**
     * Vérifie le minimum vital pour nebule.
     * @return boolean
     * @todo
     *
     */
    private function _nebuleCheckEnvironment()
    {
        return true;
        // A faire...
    }

    /**
     * Initialise l'environnement minimum pour nebule.
     * @return void
     * @todo
     *
     */
    private function _nebuleInitEnvironment()
    {
        // A faire...
    }


    /**
     * Recherche des liens par rapport à une référence qui est le type d'objet.
     * La recherche se fait dans les liens de l'objet type.
     * Cette recherche est utilisée pour retrouver les groupes et les conversations.
     *
     * Toutes les références et propriétés sont hachées avec un algorithme fixe.
     *
     * $entity Permet de ne sélectionner que les liens générés par une entité.
     *
     * @param string|Node $type
     * @param string $socialClass
     * @param string|Entity $entity
     * @return array:Link
     * @todo ajouter un filtre sur le type mime des objets.
     *
     */
    public function getListLinksByType($type, $entity = '', $socialClass = '')
    {
        /**
         * Résultat de la recherche de liens à retourner.
         * @var array:Link $result
         */
        $result = array();

        /**
         * Empreinte du type d'objet à rechercher.
         * @var string $hashType
         */
        $hashType = '';

        /**
         * Empreinte de l'entité pour la recherche.
         * @var string $hashEntity
         */
        $hashEntity = '';

        // Si le type est une instance, récupère l'ID de l'instance de l'objet du type.
        if (is_a($type, 'Node')) {
            $hashType = $type->getID();
        } else {
            // Si le type est un ID (héxadécimal), l'utilise directement. Sinon calcul l'empreinte du type.
            if (ctype_xdigit($type))
                $hashType = $type;
            else
                $hashType = $this->_crypto->hash($type, self::REFERENCE_CRYPTO_HASH_ALGORITHM);
            // $type doit être une instance d'objet au final.
            $type = $this->newObject($hashType);
        }
        // Si l'ID de l'instance du type est null ou vide, quitte en renvoyant un résultat vide.
        if ($hashType == '0'
            || $hashType == ''
        )
            return $result;

        // Si l'entité est une instance, récupère l'ID de l'instance de l'entité.
        if (is_a($entity, 'Node')) {
            $hashEntity = $entity->getID();
        } else {
            // Si l'entité est un ID (héxadécimal), l'utilise directement. Sinon calcul l'empreinte de l'entité.
            if (ctype_xdigit($entity)
                && $this->getIO()->checkLinkPresent($entity)
                && $this->getIO()->checkObjectPresent($entity)
            )
                $hashEntity = $entity;
            else
                $hashEntity = '';
        }

        // Lit les liens de l'objet de référence.
        $result = $type->readLinksFilterFull(
            $hashEntity,
            '',
            'l',
            '',
            $hashType,
            $this->_crypto->hash(self::REFERENCE_NEBULE_OBJET_TYPE, self::REFERENCE_CRYPTO_HASH_ALGORITHM)
        );

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($result, $socialClass);

        // retourne le résultat.
        return $result;
    }

    /**
     * Recherche des ID d'objets par rapport à une référence qui est le type d'objet.
     *
     * $entity Permet de ne sélectionner que les liens générés par une entité.
     *
     * @param string|Node $type
     * @param string $socialClass
     * @param string|Entity $entity
     * @return array:Link
     */
    public function getListIdByType($type = '', $entity = '', $socialClass = '')
    {
        /**
         * Résultat de la recherche de liens à retourner.
         * @var array:Link $result
         */
        $result = $this->getListLinksByType($type, $entity, $socialClass);

        // Extrait les ID.
        foreach ($result as $i => $l)
            $result[$i] = $l->getHashSource();

        // retourne le résultat.
        return $result;
    }

    /**
     * Extrait la liste des liens définissant les groupes d'objets.
     *
     * $entity Permet de ne sélectionner que les groupes générés par une entité.
     *
     * @param string $socialClass
     * @param string|Entity $entity
     * @return array:Link
     */
    public function getListGroupsLinks($entity = '', $socialClass = '')
    {
        return $this->getListLinksByType(self::REFERENCE_NEBULE_OBJET_GROUPE, $entity, $socialClass);
    }

    /**
     * Extrait la liste des ID des groupes d'objets.
     *
     * $entity Permet de ne sélectionner que les groupes générés par une entité.
     *
     * @param string|entity $entity
     * @param string $socialClass
     * @return array
     */
    public function getListGroupsID($entity = '', $socialClass = '')
    {
        return $this->getListIdByType(self::REFERENCE_NEBULE_OBJET_GROUPE, $entity, $socialClass);
    }

    /**
     * Extrait la liste des liens définissant les conversations.
     *
     * Précalcul le hash de l'objet définissant une conversation.
     * Extrait l'ID de l'entité, si demandé.
     * Liste les liens définissants les différentes conversations.
     * Retourne la liste.
     *
     * $entity : Permet de ne sélectionner que les conversations générés par une entité.
     *
     * @param string|entity $entity
     * @return array
     */
    public function getListConversationsLinks($entity = '', $socialClass = '')
    {
        return $this->getListLinksByType(self::REFERENCE_NEBULE_OBJET_CONVERSATION, $entity, $socialClass);
    }

    /**
     * Extrait la liste des ID des conversations.
     * Géré comme des groupes d'objets.
     *
     * $entity Permet de ne sélectionner que les conversations générées par une entité.
     *
     * @param string|entity $entity
     * @param string $socialClass
     * @return array
     */
    public function getListConversationsID($entity = '', $socialClass = '')
    {
        return $this->getListIdByType(self::REFERENCE_NEBULE_OBJET_CONVERSATION, $entity, $socialClass);
    }


    /**
     * Contient l'état de validité du ticket des actions.
     * @var boolean
     */
    private $_validTicket = false;

    /**
     * Lit le ticket pour les actions et le valide si il est connu et non utilisé.
     * Le ticket reconnu est marqué dans la liste des ticket afin d'interdire le rejeu.
     * Le ticket inconnu n'est pas marqué afin d'empêcher une attaque par remplissage.
     *
     * Pour que certaines actions puissent être validées, un ticket doit être présenté dans l'URL.
     * Le ticket doit être connu, valide et non utilisé.
     *
     * @return null
     */
    private function _findActionTicket()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        $ticket = '0';
        // Lit et nettoye le contenu de la variable GET.
        $arg_get = trim(filter_input(INPUT_GET, self::COMMAND_SELECT_TICKET, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
        // Lit et nettoye le contenu de la variable POST.
        $arg_post = trim(filter_input(INPUT_POST, self::COMMAND_SELECT_TICKET, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

        // Vérifie les variables.
        if ($arg_get != ''
            && strlen($arg_get) >= self::NEBULE_MINIMUM_ID_SIZE
            && ctype_xdigit($arg_get)
        ) {
            $ticket = $arg_get;
        } elseif ($arg_post != ''
            && strlen($arg_post) >= self::NEBULE_MINIMUM_ID_SIZE
            && ctype_xdigit($arg_post)
        ) {
            $ticket = $arg_post;
        }
        unset($arg_get, $arg_post);

        // Vérifie le ticket.
        session_start();
        if ($ticket == '0'
            || $this->_flushCache
        ) {
            // Le ticket est null, aucun ticket trouvé en argument.
            // Aucune action ne doit être réalisée.
            $this->_metrology->addLog('Ticket: none', Metrology::LOG_LEVEL_DEBUG); // Log
            $this->_validTicket = false;
        } elseif (isset($_SESSION['Ticket'][$ticket])
            && $_SESSION['Ticket'][$ticket] !== true
        ) {
            // Le ticket est déjà connu mais est déjà utilisé, c'est un rejeu.
            // Aucune action ne doit être réalisée.
            $this->_metrology->addLog('Ticket: replay ' . $ticket, Metrology::LOG_LEVEL_ERROR); // Log
            $this->_validTicket = false;
            $_SESSION['Ticket'][$ticket] = false;
        } elseif (isset($_SESSION['Ticket'][$ticket])
            && $_SESSION['Ticket'][$ticket] === true
        ) {
            // Le ticket est connu et n'est pas utilisé, c'est bon.
            // Il est marqué maintenant comme utilisé.
            // Les actions peuvent être réalisées.
            $this->_metrology->addLog('Ticket: valid ' . $ticket, Metrology::LOG_LEVEL_DEBUG); // Log
            $this->_validTicket = true;
            $_SESSION['Ticket'][$ticket] = false;
        } else {
            // Le ticket est inconnu.
            // Pas de mémorisation.
            // Aucune action ne doit être réalisée.
            $this->_metrology->addLog('Ticket: error ' . $ticket, Metrology::LOG_LEVEL_ERROR); // Log
            $this->_validTicket = false;
        }
        session_write_close();
        unset($ticket);
    }

    /**
     * Génère un ticket pour valider une action et interdire le rejeu d'action.
     * Stock le ticket pour vérification ultérieure.
     * Retourne le ticket avec la ligne pour insertion directe dans une url.
     *
     * Pour que certaines actions puissent être validées, un ticket doit être présenté dans l'URL.
     * Le ticket doit être connu, valide et non utilisé.
     *
     * @return string
     */
    public function getActionTicket()
    {
        return '&' . self::COMMAND_SELECT_TICKET . '=' . $this->getActionTicketValue();
    }

    /**
     * Génère un ticket pour valider une action et interdire le rejeu d'action.
     * Stock le ticket pour vérification ultérieure.
     * Retourne la valeur du ticket.
     *
     * La valeur de référence est pseudo-aléatoire mais suffisante pour résister
     *   à une attaque le temps d'une session utilisateur.
     *
     * Pour que certaines actions puissent être validées, un ticket doit être présenté dans l'URL.
     * Le ticket doit être connu, valide et non utilisé.
     *
     * @return string
     */
    public function getActionTicketValue()
    {
        session_start();
        $data = $this->_crypto->getPseudoRandom(2048);
        $ticket = $this->_crypto->hash($data);
        unset($data);
        $_SESSION['Ticket'][$ticket] = true;
        session_write_close();
        return $ticket;
    }

    /**
     * Vérifie que le ticket est connu, valide et non utilisé.
     *
     * Pour que certaines actions puissent être validées, un ticket doit être présenté dans l'URL.
     * Le ticket doit être connu, valide et non utilisé.
     *
     * @return boolean
     */
    public function checkActionTicket()
    {
        return $this->_validTicket;
    }


    /**
     * Extrait l'argument pour continuer un affichage en ligne à partir d'un objet particulier.
     * Rtourne tout type de chaine de texte nécessaire à l'affichage,
     *   ou une chaine vide si pas d'argument valable trouvé.
     *
     * @return string
     */
    public function getDisplayNextObject()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        $this->_metrology->addLog('Extract display next object', Metrology::LOG_LEVEL_DEBUG); // Log

        // Lit et nettoye le contenu de la variable GET.
        $arg = trim(filter_input(INPUT_GET, Displays::DEFAULT_NEXT_COMMAND, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

        // Extraction du lien et stockage pour traitement.
        if ($arg != ''
            && strlen($arg) >= self::NEBULE_MINIMUM_ID_SIZE
            && ctype_xdigit($arg)
        ) {
            return $arg;
        }
        return '';
    }


    /**
     * Détermine si c'est un objet.
     * Retourne une instance appropriée en fonction du type d'objet.
     *
     * @param string|Node|Conversation|Group|Entity|Currency|TokenPool|Token|Wallet $id
     * @return Node|Conversation|Group|Entity|Currency|TokenPool|Token|Wallet
     */
    public function convertIdToTypedObjectInstance($id)
    {
        if (is_a($id, 'Node')
            || is_a($id, 'Group')
            || is_a($id, 'Entity')
            || is_a($id, 'Conversation')
            || is_a($id, 'Currency')
            || is_a($id, 'TokenPool')
            || is_a($id, 'Token')
            || is_a($id, 'Wallet')
        ) {
            return $id;
        }

        $social = 'all';

        if ($id == '0'
            || $id == ''
        ) {
            $instance = $this->_nebuleInstance->newObject('0');
        } else {
            $instance = $this->_nebuleInstance->newObject($id);
            if ($instance->getIsEntity($social)) {
                $instance = $this->_nebuleInstance->newEntity($id);
            } elseif ($instance->getIsWallet($social)) {
                $instance = $this->_nebuleInstance->newWallet($id);
            } elseif ($instance->getIsToken($social)) {
                $instance = $this->_nebuleInstance->newToken($id);
            } elseif ($instance->getIsTokenPool($social)) {
                $instance = $this->_nebuleInstance->newTokenPool($id);
            } elseif ($instance->getIsCurrency($social)) {
                $instance = $this->_nebuleInstance->newCurrency($id);
            } elseif ($instance->getIsConversation($social)) {
                $instance = $this->_nebuleInstance->newConversation($id);
            } elseif ($instance->getIsGroup($social)) {
                $instance = $this->_nebuleInstance->newGroup($id);
            } else {
                $protected = $instance->getMarkProtected();
                if ($protected) {
                    $instance = $this->_nebuleInstance->newObject($instance->getID());
                }
                if ($instance->getType('all') == nebule::REFERENCE_OBJECT_ENTITY) {
                    $instance = $this->_nebuleInstance->newEntity($id);
                }
            }
        }

        return $instance;
    }


    /**
     * Extrait une valeur associée à une clé dans un objet, typiquement une variable dans un code.
     *
     * Retourne false si non trouvé.
     *
     * @param string $id
     * @param string $key
     * @return string
     */
    public function _readFileValue($id, $key, $size = 0)
    {
        if ($key == '') {
            return false;
        }

        if ($size == 0) {
            $size = $this->getOption('ioReadMaxData');
        }

        $value = false;
        $readValue = $this->_nebuleInstance->getIO()->objectRead($id);
        $startValue = strpos($readValue, $key);
        $trimLine = substr($readValue, $startValue, $size);
        $arrayValue = explode('"', $trimLine);
        if ($arrayValue[1] != null) {
            $value = $arrayValue[1];
        } else {
            $arrayValue = explode("'", $trimLine);
            if ($arrayValue[1] != null) {
                $value = $arrayValue[1];
            }
        }
        return $value;
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Object.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID d'un objet, ou '0' si c'est un objet nebule à créer ;
 * - un texte contenant les données, si c'est un objet nebule à créer ;
 * - l'option de protection par défaut de l'objet à créer (booléen).
 *
 * L'ID d'un objet est forcément un texte en hexadécimal.
 * ------------------------------------------------------------------------------------------
 */
class Node
{
    const CRYPTO_SESSION_KEY_SIZE = 117; // @todo utilisé par setProtected(), à refaire pour le cas général.

    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_id',
        '_fullname',
        '_cachePropertyLink',
        '_cachePropertiesLinks',
        '_cachePropertyID',
        '_cachePropertiesID',
        '_cacheProperty',
        '_cacheProperties',
        '_cacheMarkDanger',
        '_cacheMarkWarning',
        '_cacheMarkProtected',
        '_idProtected',
        '_idUnprotected',
        '_idProtectedKey',
        '_idUnprotectedKey',
        '_markProtectedChecked',
        '_cacheCurrentEntityUnlocked',
        '_usedUpdate',
        '_isEntity',
        '_isGroup',
        '_isConversation',
        '_isCurrency',
        '_isTokenPool',
        '_isToken',
        '_isWallet',
    );

    /**
     * Instance de la bilbiothèque nebule en PHP POO.
     *
     * @var nebule $_nebuleInstance
     */
    protected nebule $_nebuleInstance;

    /**
     * Instance des I/O (entrées/sorties).
     *
     * @var ioInterface $_io
     */
    protected ioInterface $_io;

    /**
     * Instance de la cryptographie.
     *
     * @var CryptoInterface $_crypto
     */
    protected CryptoInterface $_crypto;

    /**
     * Instance sociale.
     *
     * @var SocialInterface $_social
     */
    protected SocialInterface $_social;

    /**
     * Instance de la métrologie.
     *
     * @var Metrology $_metrology
     */
    protected Metrology $_metrology;

    /**
     * Identifiant de l'objet.
     * Si à 0, l'objet est invalide.
     *
     * @var string $_id
     */
    protected string $_id;

    /**
     * Le nom complet.
     * Forme : prénom préfix/nom.suffix surnom
     *
     * @var string $_fullname
     */
    protected string $_fullname;

    /**
     * Cache.
     *
     * @var array $_cachePropertyLink
     */
    protected array $_cachePropertyLink = array();

    /**
     * Cache.
     *
     * @var array $_cachePropertiesLinks
     */
    protected array $_cachePropertiesLinks = array();

    /**
     * Cache.
     *
     * @var array $_cachePropertyID
     */
    protected array $_cachePropertyID = array();

    /**
     * Cache.
     *
     * @var array $_cachePropertiesID
     */
    protected array $_cachePropertiesID = array();

    /**
     * Cache.
     *
     * @var array $_cacheProperty
     */
    protected array $_cacheProperty = array();

    /**
     * Cache.
     *
     * @var array $_cacheProperties
     */
    protected array $_cacheProperties = array();

    /**
     * Cache.
     *
     * @var string $_cacheUpdate
     */
    protected string $_cacheUpdate = '';

    /**
     * Cache.
     *
     * @var boolean $_cacheMarkDanger
     */
    protected bool $_cacheMarkDanger = false;

    /**
     * Cache.
     *
     * @var boolean $_cacheMarkWarning
     */
    protected bool $_cacheMarkWarning = false;

    /**
     * Cache.
     *
     * @var boolean $_cacheMarkProtected
     */
    protected bool $_cacheMarkProtected = false;

    /**
     * Identifiant de l'objet ayant le contenu protégé (chiffré).
     *
     * @var string $_idProtected
     */
    protected string $_idProtected = '0';

    /**
     * Identifiant de l'objet ayant le contenu non protégé (en clair).
     *
     * @var string $_idUnprotected
     */
    protected string $_idUnprotected = '0';

    /**
     * Identifiant de l'objet ayant le contenu de la clé protégée de déchiffrement de l'objet.
     *
     * @var string $_idProtectedKey
     */
    protected string $_idProtectedKey = '0';

    /**
     * Identifiant de l'objet ayant le contenu de la clé non protégée de déchiffrement de l'objet.
     *
     * @var string $_idUnprotectedKey
     */
    protected string $_idUnprotectedKey = '0';

    /**
     * Marqueur de détection de la protection de l'objet.
     *
     * @var boolean $_markProtectedChecked
     */
    protected bool $_markProtectedChecked = false;

    /**
     *
     * @var bool $_cacheCurrentEntityUnlocked
     */
    protected bool|null $_cacheCurrentEntityUnlocked = null;

    /**
     * Copie des données non encodées.
     * Ne pas mettre en cache de session PHP.
     *
     * @var string|null
     */
    protected $_data = null;

    /**
     * Des données non encodées sont présentes.
     * Ne pas mettre en cache de session PHP.
     *
     * @var string
     */
    protected $_haveData = false;

    /**
     * Copie des données encodées.
     * Ne pas mettre en cache de session PHP.
     *
     * @var string|null
     */
    protected $_code = '';

    /**
     * Des données encodées sont présentes.
     * Ne pas mettre en cache de session PHP.
     *
     * @var boolean
     */
    protected $_haveCode = false;

    /**
     *
     * @var array
     */
    protected $_usedUpdate = array();

    /**
     * Constructeur.
     * Toujours transmettre l'instance de la librairie nebule.
     * Si l'objet existe, juste préciser l'ID de celui-ci.
     * Si c'est un nouvel objet à créer, mettre l'ID à 0 et transmettre les données du nouvel objet dans data.
     * Si c'est un nouvel objet, préciser si il doit être protégé tout de suite avec protect à true.
     *
     * @param nebule  $nebuleInstance
     * @param string  $id
     * @param string  $data
     * @param boolean $protect
     */
    public function __construct(nebule $nebuleInstance, string $id, string $data = '', bool $protect, bool $obfuscated = false)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();

        $id = trim(strtolower($id));

        if (is_string($id)
            && $id != '0'
            && $id != ''
            && ctype_xdigit($id)
        ) {
            $this->_id = $id;
            $this->_metrology->addLog('New instance object ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.
            $this->_getMarkProtected();
            $this->_cacheCurrentEntityUnlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();

            // Pré-détermine certains contenus.
            $this->_getCommunContents();
        } elseif ($id == '0'
            && is_string($data)
            && $data != ''
        ) {
            $this->_createNewObject($data, $protect, $obfuscated);
            $this->_cacheCurrentEntityUnlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();
        } else {
            $this->_id = '0';
        }
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->_id;
    }

    /**
     * Retourne les variables à sauvegarder dans la session php lors d'une mise en sommeil de l'instance.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return self::SESSION_SAVED_VARS;
    }

    /**
     * Foncion de réveil de l'instance et de ré-initialisation de certaines variables non sauvegardées.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();
        $this->_cacheMarkDanger = false;
        $this->_cacheMarkWarning = false;
        $this->_data = '';
        $this->_haveData = false;
        $this->_cacheUpdate = '';

        // Pré-détermine certains contenus.
        $this->_getCommunContents();
    }

    protected function _createNewObject($data, $protect, $obfuscated)
    {
        $this->_metrology->addLog(__METHOD__, Metrology::LOG_LEVEL_FUNCTION); // Log

        $this->_markProtectedChecked = false;

        // Vérifie que l'on puisse créer un objet.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            // calcul l'ID.
            $this->_id = $this->_crypto->hash($data);
            if ($protect) {
                $this->_metrology->addLog('Create protected object ' . $this->_id, Metrology::LOG_LEVEL_DEBUG);
            } else {
                $this->_metrology->addLog('Create object ' . $this->_id, Metrology::LOG_LEVEL_DEBUG);
            }

            // Mémorise les données.
            $this->_data = $data;
            $this->_haveData = true;
            $data = null;

            // Création lien de hash.
            $signer = $this->_nebuleInstance->getCurrentEntity();
            $date = date(DATE_ATOM);

            // Création lien de hash.
            $date2 = $date;
            if ($obfuscated) {
                $date2 = '0';
            }
            $action = 'l';
            $source = $this->_id;
            $target = $this->_crypto->hash($this->_crypto->hashAlgorithmName());
            $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_HASH);
            $link = '0_' . $signer . '_' . $date2 . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->signWrite();

            // Création du lien d'annulation de suppression.
            $action = 'x';
            $source = $this->_id;
            $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_0_0';
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->sign();
            if ($obfuscated) {
                $newLink->obfuscate();
            }
            $newLink->write();

            // Si l'objet doit être protégé.
            if ($protect) {
                $this->setProtected($obfuscated);
            } else {
                // Sinon écrit l'objet directement.
                $this->write();
            }
        } else {
            $this->_metrology->addLog('Create object error no autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_id = '0';
            return false;
        }
        return true;
    }

    /**
     * Retourne l'ID de l'objet.
     *
     * @return string
     */
    public function getID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_id;
    }

    /**
     * Retourne la couleur primaire de l'objet.
     *
     * @return string
     */
    public function getPrimaryColor()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return substr($this->_id . '000000', 0, 6);
    }

    /**
     * Retourne l'algorithme de hash.
     * @return string
     * @todo
     *
     */
    public function getHashAlgo()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $algo = $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_HASH, 'all');
        $this->_metrology->addLog('Object ' . $this->_id . ' hash = ' . $algo, Metrology::LOG_LEVEL_DEBUG); // Log

        if ($algo != '') {
            return $algo;
        }
        // else
        return '';
    }

    /**
     * Test si l'objet est présent.
     *
     * @return boolean
     */
    public function checkPresent()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $result = false;
        if ($this->_id == '0') {
            return false;
        }
        // Si l'objet est protégé.
        if ($this->_getMarkProtected()) {
            $result = $this->_nebuleInstance->getIO()->checkObjectPresent($this->_idProtected);
        } else {
            $result = $this->_nebuleInstance->getIO()->checkObjectPresent($this->_id);
        }
        return $result;
    }

    /**
     * Test si l'objet a des liens.
     *
     * @return boolean
     */
    public function checkObjectHaveLinks()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_io->checkLinkPresent($this->_id);
    }


    /**
     * Pré-détermine certains contenus.
     * Sans ces contenus, certaines fonctions ne se terminent pas bien pour ces objets.
     *
     * @return void
     */
    protected function _getCommunContents()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '5d5b09f6dcb2d53a5fffc60c4ac0d55fabdf556069d6631545f42aa6e3500f2e') {
            $this->_data = 'sha256';
            $this->_haveData = true;
        }
    }


    /**
     * Faire une recherche de liens type l en fonction de l'objet méta.
     * Typiquement utilisé pour une recherche de propriétés d'un objet.
     *
     * Fait une recherche sur de multiples algorithmes de hash au besoin.
     * @param array $list
     * @param string $meta
     * @todo
     *
     */
    private function _getLinksByMeta(&$list, $meta)
    {
        $this->_getLinksByMetaByHash($list, $meta);

        // Fait une recherche sur d'autres types de hash si celui par défaut ne renvoie rien.
        if (sizeof($list) == 0
            && $this->_nebuleInstance->getOption('permitListOtherHash')
        ) {
            // A faire...
        }
    }

    /**
     * Faire une recherche de liens type l en fonction de l'objet méta et d'un algorithme de hash donné.
     *
     * @param array $list
     * @param string $meta
     * @param string $hashAlgo
     */
    private function _getLinksByMetaByHash(&$list, $meta)
    {
        $list = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->_id,
            '',
            $this->_crypto->hash($meta, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM)
        );
    }

    /**
     * Lit une propriété de l'objet nebule dans ses liens.
     * Retourne la liste des liens définissants la propriété.
     *
     * @param string $type
     * @param string $socialClass
     * @return array
     */
    public function getPropertiesLinks($type, $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($type == '') {
            return array();
        }

        // Si déjà recherché, donne le résultat en cache.
        if (isset($this->_cachePropertiesLinks[$type][$socialClass])) {
            return $this->_cachePropertiesLinks[$type][$socialClass];
        }

        // Liste les liens à la recherche de la propriété.
        $list = array();
        $this->_getLinksByMeta($list, $type);

        if (sizeof($list) == 0) {
            return array();
        }

        // Trie la liste, pour les liens venants de plusieurs objets.
        $date = array();
        foreach ($list as $k => $r) {
            $date[$k] = $r->getDate();
        }
        array_multisort($date, SORT_STRING, SORT_ASC, $list);

        // Fait un tri par pertinence sociale.
        $this->_social->arraySocialFilter($list, $socialClass);

        // Mémorise le résultat dans le cache.
        $this->_cachePropertiesLinks[$type][$socialClass] = $list;

        // Résultat.
        return $list;
    }

    /**
     * Lit une propriété de l'objet nebule dans ses liens.
     * Retourne le lien unique définissant la propriété.
     * Retourne une chaine vide si pas de lien de propriété trouvé.
     *
     * @param string $type
     * @param string $socialClass
     * @return link
     */
    public function getPropertyLink($type, $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($type == '') {
            return '';
        }

        // Si déjà recherché, donne le résultat en cache.
        if (isset($this->_cachePropertyLink[$type][$socialClass])) {
            return $this->_cachePropertyLink[$type][$socialClass];
        }

        $propertyLink = '';

        // Liste les liens à la recherche de la propriété.
        $list = $this->getPropertiesLinks($type, $socialClass);

        if (sizeof($list) == 0) {
            return '';
        }

        // Extrait le dernier de la liste.
        $propertyLink = end($list);
        unset($list);

        // Mémorise le résultat dans le cache.
        $this->_cachePropertyLink[$type][$socialClass] = $propertyLink;

        // Résultat.
        return $propertyLink;
    }

    /**
     * Lit une propriété de l'objet nebule dans ses liens.
     * Retourne une chaine de texte de _une seule_ ligne, ou une chaine vide si problème.
     *
     * @param string $type
     * @param string $socialClass
     * @return string
     */
    public function getPropertyID($type, $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($type == '') {
            return '';
        }

        // Si déjà recherché, donne le résultat en cache.
        if (isset($this->_cachePropertyID[$type][$socialClass])) {
            return $this->_cachePropertyID[$type][$socialClass];
        }

        $property = '';

        // Liste les liens à la recherche de la propriété.
        $link = $this->getPropertyLink($type, $socialClass);

        if (!is_a($link, 'link')) {
            return '';
        }

        // Extrait l'ID de l'objet de propriété.
        $property = $link->getHashTarget_disabled();
        unset($link);

        // Mémorise le résultat dans le cache.
        $this->_cachePropertyID[$type][$socialClass] = $property;

        // Résultat.
        return $property;
    }

    /**
     * Lit les propriétés de l'objet nebule dans ses liens.
     * Retourne un tableau de chaines de texte de une seule ligne, ou un tableau de une chaine vide si problème.
     *
     * @param string $type
     * @param string $socialClass
     * @return array
     */
    public function getPropertiesID($type, $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($type == '') {
            return array();
        }

        // Si déjà recherché, donne le résultat en cache.
        if (isset($this->_cachePropertiesID[$type][$socialClass])) {
            return $this->_cachePropertiesID[$type][$socialClass];
        }

        $properties = array();

        // Liste les liens à la recherche de la propriété.
        $list = array();
        $this->_getLinksByMeta($list, $type);

        if (sizeof($list) == 0) {
            return array();
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($list, $socialClass);

        // Extrait les ID des objets de propriété.
        foreach ($list as $i => $l) {
            $properties[$i] = $l->getHashTarget();
        }
        unset($list);

        // Mémorise le résultat dans le cache.
        $this->_cachePropertiesID[$type][$socialClass] = $properties;

        // Résultat.
        return $properties;
    }

    /**
     * Lit une propriété de l'objet nebule dans ses liens.
     * Retourne une chaine de texte de _une seule_ ligne, ou une chaine vide si problème.
     *
     * @param string $type
     * @param string $socialClass
     * @return string
     */
    public function getProperty($type, $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($type == '') {
            return '';
        }

        // Si déjà recherché, donne le résultat en cache.
        if (isset($this->_cacheProperty[$type][$socialClass])) {
            return $this->_cacheProperty[$type][$socialClass];
        }

        $property = '';

        // Liste les liens à la recherche de la propriété.
        $link = $this->getPropertyLink($type, $socialClass);

        if ($link == ''
            || !is_a($link, 'link')
        ) {
            return '';
        }

        // Extrait le contenu de l'objet de propriété.
        $property = $this->_readOneLineOtherObject($link->getHashTarget_disabled());
        unset($link);

        // Mémorise le résultat dans le cache.
        $this->_cacheProperty[$type][$socialClass] = $property;

        // Résultat.
        return $property;
    }

    /**
     * Lit les propriétés de l'objet nebule dans ses liens.
     * Retourne un tableau de chaines de texte de une seule ligne, ou un tableau de une chaine vide si problème.
     *
     * @param string $type
     * @param string $socialClass
     * @return array
     */
    public function getProperties($type, $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($type == '') {
            return array();
        }

        // Si déjà recherché, donne le résultat en cache.
        if (isset($this->_cacheProperties[$type][$socialClass])) {
            return $this->_cacheProperties[$type][$socialClass];
        }

        $properties = array();

        // Liste les liens à la recherche de la propriété.
        $links = array();
        $this->_getLinksByMeta($links, $type);

        if (sizeof($links) == 0) {
            return array();
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Extrait le contenu des objets de propriété.
        foreach ($links as $i => $l) {
            $properties[$i] = $this->_readOneLineOtherObject($l->getHashTarget());
        }
        unset($links);

        // Mémorise le résultat dans le cache.
        if (sizeof($properties) != 0 && false) // @todo la mise en cache ne fonctionne pas !!!
        {
            $this->_cacheProperties[$type][$socialClass] = $properties;
        }

        // Résultat.
        return $properties;
    }

    /**
     * Lit si l'objet a une propriété particulière.
     *
     * @param string $type
     * @param string $property
     * @param string $socialClass
     * @return boolean
     */
    public function getHaveProperty(string $type, string $property, string $socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait la liste des propriétés.
        $list = $this->getProperties($type, $socialClass);

        // Cherche dans la liste la propriété de groupe.
        foreach ($list as $item) {
            if ($item == $property) {
                return true;
            }
        }

        // Si la propriété n'est pas trouvée.
        return false;
    }

    /**
     * Recherche les ID des entités qui ont signé une propriété de l'objet.
     * Si la propriété est vide, retourne les signataires de toute propriété.
     *
     * @param string $type
     * @return array:string
     */
    public function getPropertySigners($type = '')
    {
        $signers = array();

        // Si le type de l'objet est précisé, le converti en ID.
        if ($type != '') {
            $type = $this->_crypto->hash($type, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }

        $signers = array();

        // Extraction des entités signataires.
        $links = $this->getPropertiesLinks(nebule::REFERENCE_NEBULE_OBJET_TYPE, 'all');

        foreach ($links as $link) {
            if ($type == ''
                || ($type != ''
                    && $link->getHashTarget() == $type
                )
            ) {
                $signers[$link->getHashSigner()] = $link->getHashSigner();
            }
        }
        unset($links);

        return $signers;
    }

    /**
     * Recherche une propriété de l'objet est sgnée par une entité.
     * Si la propriété est vide, vérifie pour toute propriété.
     *
     * @param string $entity
     * @param string $type
     * @return boolean
     */
    public function getPropertySignedBy($entity, $type = '')
    {
        // Si le type de l'objet est précisé, le converti en ID.
        if ($type != '') {
            $type = $this->_crypto->hash($type, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }

        // extrait l'ID de l'entité si c'est un objet.
        if (is_a($entity, 'Node')) {
            $entity = $entity->getID();
        }

        // Extraction des entités signataires.
        $links = $this->getPropertiesLinks(nebule::REFERENCE_NEBULE_OBJET_TYPE, 'all');

        foreach ($links as $link) {
            if ($type == ''
                || ($type != ''
                    && $link->getHashTarget() == $type
                )
            ) {
                if ($link->getHashSigner() == $entity) {
                    return true;
                }
            }
        }
        unset($links);

        return false;
    }

    /**
     * Ecrit la propriété de l'objet correspondant au type.
     * @param string $type
     * @param string $property
     * @param boolean $protect
     * @param boolean $obfuscated
     * @return boolean
     * @todo
     *
     */
    public function setProperty(string $type, string $property, $protect = false, $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($type == '') {
            return false;
        }
        if ($property == '') {
            return false;
        }

        // Prépare l'objet de la propriété.
        $id = $this->_nebuleInstance->createTextAsObject($property, $protect, $obfuscated);
        if ($id === false) {
            return false;
        }

        // Création lien de propriété.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $this->_id;
        $target = $id;
        $meta = $this->_crypto->hash($type, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();
        if ($obfuscated) {
            $newLink->obfuscate();
        }
        $newLink->write();

        // Supprime le résultat dans le cache.
        /*		if ( isset($this->_cacheProperty[$type]) )
		{
			foreach ( $this->_cacheProperty[$type] as $i => $v )
			{
				unset($this->_cacheProperty[$type][$i]);
			}
		}
		if ( isset($this->_cacheProperties[$type]) )
		{
			foreach ( $this->_cacheProperties[$type] as $i => $v )
			{
				unset($this->_cacheProperties[$type][$i]);
			}
		}*/
        // @todo   ------------------------------------------------------------------------------- A revoir...
        $this->_cacheProperty = array();
        $this->_cacheProperties = array();

        // Résultat.
        return true;
    }

    /**
     * Lit l'ID du type mime.
     * @param string $socialClass
     * @return string
     */
    public function getTypeID($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getPropertyID(nebule::REFERENCE_NEBULE_OBJET_TYPE, $socialClass);
    }

    /**
     * Lit le type mime.
     * @param string $socialClass
     * @return string
     */
    public function getType($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_TYPE, $socialClass);
    }

    /**
     * Ecriture du type mime.
     * @param string $type
     * @return boolean
     */
    public function setType($type)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->setProperty(nebule::REFERENCE_NEBULE_OBJET_TYPE, $type);
    }

    /**
     * Lit la taille.
     * @param string $socialClass
     * @return string
     */
    public function getSize($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return filter_var($this->getProperty(nebule::REFERENCE_NEBULE_OBJET_TAILLE, $socialClass), FILTER_SANITIZE_NUMBER_INT);
    }

    /**
     * Lit l'empreinte homomorphe.
     * @param string $socialClass
     * @return string
     */
    public function getHomomorphe($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_HOMOMORPHE, $socialClass);
    }

    /**
     * Lit l'empreinte (ID).
     * @return string
     */
    public function getHash()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_id;
    }

    /**
     * Lit la date de création.
     * @param string $socialClass
     * @return string
     */
    public function getDate($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_DATE, $socialClass);
    }

    /**
     * Lecture du nom.
     * @param string $socialClass
     * @return string
     */
    public function getName($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $name = $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_NOM, $socialClass);
        if ($name == '') {
            // Si le nom n'est pas trouvé, retourne l'ID.
            $name = $this->_id;
        }
        return $name;
    }

    /**
     * Ecriture du nom.
     * @param string $name
     * @return boolean
     */
    public function setName($name)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->setProperty(nebule::REFERENCE_NEBULE_OBJET_NOM, $name, $this->_getMarkProtected());
    }

    /**
     * Lecture du préfix.
     * @param string $socialClass
     * @return string
     */
    public function getPrefixName($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_PREFIX, $socialClass);
    }

    /**
     * Ecriture du préfix.
     * @param string $name
     * @return boolean
     */
    public function setPrefix($prefix)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->setProperty(nebule::REFERENCE_NEBULE_OBJET_PREFIX, $prefix, $this->_getMarkProtected());
    }

    /**
     * Lecture du suffix.
     * @param string $socialClass
     * @return string
     */
    public function getSuffixName($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_SUFFIX, $socialClass);
    }

    /**
     * Ecriture du suffix.
     * @param string $name
     * @return boolean
     */
    public function setSuffix($suffix)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->setProperty(nebule::REFERENCE_NEBULE_OBJET_SUFFIX, $suffix, $this->_getMarkProtected());
    }

    /**
     * Lecture du prénom.
     * @param string $socialClass
     * @return string
     */
    public function getFirstname($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_PRENOM, $socialClass);
    }

    /**
     * Ecriture du prénom.
     * @param string $name
     * @return boolean
     */
    public function setFirstname($firstname)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->setProperty(nebule::REFERENCE_NEBULE_OBJET_SUFFIX, $firstname, $this->_getMarkProtected());
    }

    /**
     * Lecture du surnom.
     * @param string $socialClass
     * @return string
     */
    public function getSurname($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_SURNOM, $socialClass);
    }

    /**
     * Ecriture du surnom.
     * @param string $name
     * @return boolean
     */
    public function setSurname($surname)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->setProperty(nebule::REFERENCE_NEBULE_OBJET_SURNOM, $surname, $this->_getMarkProtected());
    }

    /**
     * Lecture du nom complet.
     *
     * @param string $socialClass
     * @return string
     */
    public function getFullName($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if (isset($this->_fullname)
            && trim($this->_fullname) != ''
        ) {
            return $this->_fullname;
        }

        // Recherche des éléments.
        $name = $this->getName($socialClass);
        $prefix = $this->getPrefixName($socialClass);
        $firstname = $this->getFirstname($socialClass);
        $suffix = $this->getSuffixName($socialClass);
        $surname = $this->getSurname($socialClass);

        // Reconstitution du nom complet : prénom préfixe/nom.suffixe surnom
        $fullname = $name;
        if ($prefix != '') {
            $fullname = $prefix . '/' . $fullname;
        }
        if ($suffix != '') {
            $fullname = $fullname . '.' . $suffix;
        }
        if ($firstname != '') {
            $fullname = $firstname . ' ' . $fullname;
        }
        if ($surname != '') {
            $fullname = $fullname . ' ' . $surname;
        }
        $this->_fullname = $fullname;

        // Resultat.
        return $fullname;
    }

    /**
     * Lecture des multiples localisations.
     *
     * @param string $socialClass
     * @return array
     */
    public function getLocalisations($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperties(nebule::REFERENCE_NEBULE_OBJET_LOCALISATION, $socialClass);
    }

    /**
     * Lecture de la localisation.
     * @param string $socialClass
     * @return string
     */
    public function getLocalisation($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_LOCALISATION, $socialClass);
    }

    /**
     * Ecriture de la localisation.
     * @param string $localisation
     * @return boolean
     */
    public function setLocalisation($localisation)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->setProperty(nebule::REFERENCE_NEBULE_OBJET_LOCALISATION, $localisation);
    }


    /**
     * Variable si l'objet est marqué comme une entité.
     * @var boolean
     */
    protected $_isEntity = false;

    /**
     * Lit si l'objet est une entité.
     *
     * @param string $socialClass
     * @return boolean
     */
    public function getIsEntity($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_isEntity) {
            return true;
        }

        $type = $this->getType($socialClass);
        $objHead = $this->readOneLineAsText(Entity::ENTITY_MAX_SIZE);
        $this->_isEntity = ($type == nebule::REFERENCE_OBJECT_ENTITY && strpos($objHead, nebule::REFERENCE_ENTITY_HEADER) !== false);

        unset($objHead);
        return $this->_isEntity;
    }


    /**
     * Variable si l'objet est marqué comme un groupe.
     * @var boolean
     */
    protected $_isGroup = false;

    /**
     * Lit si l'objet est un groupe.
     *
     * @param string $socialClass
     * @return boolean
     */
    public function getIsGroup($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_isGroup) {
            return true;
        }

        $this->_isGroup = $this->getHaveProperty(nebule::REFERENCE_NEBULE_OBJET_TYPE, nebule::REFERENCE_NEBULE_OBJET_GROUPE, $socialClass);

        return $this->_isGroup;
    }

    /**
     * Retourne la liste des liens vers les groupes dont l'objet est membre.
     *
     * @param string $socialClass
     * @return array:Link
     */
    public function getListIsMemberOnGroupLinks($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            '',
            $this->id,
            ''
        );

        // Tri sur les appartenances aux groupes ou équivalent.
        foreach ($links as $i => $link) {
            if ($link->getHashSource() != $link->getHashMeta()) {
                unset($links[$i]);
            }
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Tri les objets de type groupe.
        foreach ($links as $i => $link) {
            $instance = $this->_nebuleInstance->newGroup($link->getHashSource());
            if (!$instance->getIsGroup('all')) {
                unset($links[$i]);
            }
        }

        return $links;
    }

    /**
     * Retourne la liste des ID vers les groupes dont l'objet est membre.
     *
     * @param string $socialClass
     * @return array:string
     */
    public function getListIsMemberOnGroupID($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $list = array();

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            '',
            $this->id,
            ''
        );

        // Tri sur les appartenances aux groupes ou équivalent.
        foreach ($links as $i => $link) {
            if ($link->getHashSource() != $link->getHashMeta()) {
                unset($links[$i]);
            }
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Tri les objets de type groupe.
        foreach ($links as $i => $link) {
            $instance = $this->_nebuleInstance->newGroup($link->getHashSource());
            if ($instance->getIsGroup('all')) {
                $list[$link->getHashSource()] = $link->getHashSource();
            }
        }

        return $list;
    }


    /**
     * Variable si l'objet est marqué comme une conversation.
     * @var boolean
     */
    protected $_isConversation = false;

    /**
     * Lit si l'objet est une conversation.
     *
     * @return boolean
     */
    public function getIsConversation($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_isConversation) {
            return true;
        }

        $this->_isConversation = $this->getHaveProperty(nebule::REFERENCE_NEBULE_OBJET_TYPE, nebule::REFERENCE_NEBULE_OBJET_CONVERSATION, $socialClass);

        return $this->_isConversation;
    }

    /**
     * Retourne la liste des liens vers les conversations dont l'objet est membre.
     * S'appuie sur la fonction dédiée aux groupes.
     *
     * @param string $socialClass
     * @return array:Link
     */
    public function getListIsMemberOnConversationLinks($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            '',
            $this->id,
            ''
        );

        // Tri sur les appartenances aux groupes ou équivalent.
        foreach ($links as $i => $link) {
            if ($link->getHashSource() != $link->getHashMeta()) {
                unset($links[$i]);
            }
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Tri les objets de type groupe.
        foreach ($links as $i => $link) {
            $instance = $this->_nebuleInstance->newConversation($link->getHashSource());
            if (!$instance->getIsConversation('all')) {
                unset($links[$i]);
            }
        }

        return $links;
    }

    /**
     * Retourne la liste des ID vers les conversations dont l'objet est membre.
     * S'appuie sur la fonction dédiée aux groupes.
     *
     * @param string $socialClass
     * @return array:string
     */
    public function getListIsMemberOnConversationID($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $list = array();

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            '',
            $this->id,
            ''
        );

        // Tri sur les appartenances aux groupes ou équivalent.
        foreach ($links as $i => $link) {
            if ($link->getHashSource() != $link->getHashMeta()) {
                unset($links[$i]);
            }
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Tri les objets de type groupe.
        foreach ($links as $i => $link) {
            $instance = $this->_nebuleInstance->newConversation($link->getHashSource());
            if ($instance->getIsConversation('all')) {
                $list[$link->getHashSource()] = $link->getHashSource();
            }
        }

        return $list;
    }


    /**
     * Variable si l'objet est marqué comme une monnaie.
     * @var boolean
     */
    protected $_isCurrency = false;

    /**
     * Lit si l'objet est une monnaie.
     *
     * @return boolean
     */
    public function getIsCurrency($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_isCurrency) {
            return true;
        }

        $this->_isCurrency = $this->getHaveProperty(nebule::REFERENCE_NEBULE_OBJET_TYPE, nebule::REFERENCE_NEBULE_OBJET_MONNAIE, $socialClass);

        return $this->_isCurrency;
    }


    /**
     * Variable si l'objet est marqué comme un sac de jetons.
     * @var boolean
     */
    protected $_isTokenPool = false;

    /**
     * Lit si l'objet est un sac de jetons.
     *
     * @return boolean
     */
    public function getIsTokenPool($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_isTokenPool) {
            return true;
        }

        $this->_isTokenPool = $this->getHaveProperty(nebule::REFERENCE_NEBULE_OBJET_TYPE, nebule::REFERENCE_NEBULE_OBJET_MONNAIE_SAC, $socialClass);

        return $this->_isTokenPool;
    }


    /**
     * Variable si l'objet est marqué comme un jeton.
     * @var boolean
     */
    protected $_isToken = false;

    /**
     * Lit si l'objet est un jeton.
     *
     * @return boolean
     */
    public function getIsToken($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_isToken) {
            return true;
        }

        $this->_isToken = $this->getHaveProperty(nebule::REFERENCE_NEBULE_OBJET_TYPE, nebule::REFERENCE_NEBULE_OBJET_MONNAIE_JETON, $socialClass);

        return $this->_isToken;
    }


    /**
     * Variable si l'objet est marqué comme un portefeuille.
     * @var boolean
     */
    protected $_isWallet = false;

    /**
     * Lit si l'objet est un portefeuille.
     *
     * @return boolean
     */
    public function getIsWallet($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_isWallet) {
            return true;
        }

        $this->_isWallet = $this->getHaveProperty(nebule::REFERENCE_NEBULE_OBJET_TYPE, nebule::REFERENCE_NEBULE_OBJET_MONNAIE_PORTEFEUILLE, $socialClass);

        return $this->_isWallet;
    }


    /**
     * Lit les marques de Danger.
     * @return boolean
     * @todo
     *
     */
    public function getMarkDanger()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_cacheMarkDanger) {
            return true;
        }

        // Liste les liens à la recherche de la propriété.
        $list = $this->readLinksFilterFull(
            '',
            '',
            'f',
            $this->_crypto->hash(nebule::REFERENCE_NEBULE_DANGER),
            $this->_id,
            '');

        // Fait une recherche sur d'autres types de hash si celui par défaut ne renvoie rien.
        if (sizeof($list) == 0
            && $this->_nebuleInstance->getOption('permitListOtherHash')
        ) {
            // A faire...
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($list);

        // Si pas marqué, tout va bien. Résultat négatif.
        if (sizeof($list) == 0) {
            return false;
        }

        // Sinon.
        // Mémorise le résultat dans le cache.
        $this->_cacheMarkDanger = true;

        // Résultat positif.
        return true;
    }

    /**
     * Ecrit une marque de Danger.
     * @return boolean
     */
    public function setMarkDanger()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_cacheMarkDanger) {
            return true;
        }

        // Création lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $this->_id;
        $target = $this->_crypto->hash(nebule::REFERENCE_NEBULE_DANGER);
        $meta = '';
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->signWrite();

        $this->_cacheMarkDanger = true;
        return true;
    }

    /**
     * Lit les marques de Warning.
     * @return boolean
     * @todo
     *
     */
    public function getMarkWarning()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_cacheMarkWarning) {
            return true;
        }

        // Liste les liens à la recherche de la propriété.
        $list = $this->readLinksFilterFull(
            '',
            '',
            'f',
            $this->_crypto->hash(nebule::REFERENCE_NEBULE_WARNING),
            $this->_id,
            '');

        // Fait une recherche sur d'autres types de hash si celui par défaut ne renvoie rien.
        if (sizeof($list) == 0
            && $this->_nebuleInstance->getOption('permitListOtherHash')
        ) {
            // A faire...
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($list);

        // Si pas marqué, tout va bien. Résultat négatif.
        if (sizeof($list) == 0) {
            return false;
        }

        // Sinon.
        // Mémorise le résultat dans le cache.
        $this->_cacheMarkWarning = true;

        // Résultat positif.
        return true;
    }

    /**
     * Ecrit une marque de Warning.
     * @return boolean
     */
    public function setMarkWarning()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->_cacheMarkWarning) {
            return true;
        }

        // Création lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $this->_id;
        $target = $this->_crypto->hash(nebule::REFERENCE_NEBULE_WARNING);
        $meta = '';
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->signWrite();

        $this->_cacheMarkWarning = true;
        return true;
    }


    /**
     * Lit les marques de protection, c'est à dire un lien de chiffrement pour l'objet.
     * Fait une recherche complète.
     * @return boolean
     */
    public function getMarkProtected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $this->_getMarkProtected();
        return $this->_cacheMarkProtected;
    }

    /**
     * Lit les marques de protection, c'est à dire un lien de chiffrement pour l'objet.
     * Fait une recherche sommaire et rapide.
     * @return boolean
     */
    public function getMarkProtectedFast()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_markProtectedChecked === true) {
            return $this->_cacheMarkProtected;
        }

        if ($this->_id == '0') {
            return false;
        }

        // Liste les liens à la recherche de la propriété.
        $listS = $this->readLinksFilterFull('', '', 'k', $this->_id, '', '');
        $listT = $this->readLinksFilterFull('', '', 'k', '', $this->_id, '');

        // Si pas marqué, résultat négatif.
        if (sizeof($listS) == 0
            && sizeof($listT) == 0
        ) {
            return false;
        }
        return true;
    }

    /**
     * Lit les marques de protection, c'est à dire un lien de chiffrement pour l'objet.
     * Force la relecture de la marque de protection. A utiliser par exemple après une synchronisation.
     * @return boolean
     */
    public function getReloadMarkProtected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Réinitialisation.
        $this->_markProtectedChecked = false;
        $this->_cacheMarkProtected = false;
        $this->_idProtected = '0';
        $this->_idUnprotected = '0';
        $this->_idProtectedKey = '0';
        $this->_idUnprotectedKey = '0';

        // Recherche.
        $this->_getMarkProtected();
        return $this->_cacheMarkProtected;
    }

    /**
     * Lit les marques de protection, c'est à dire un lien de chiffrement pour l'objet.
     * Extrait toutes les valeurs nécéssaires au déchiffrement.
     * @return boolean
     * @todo
     *
     */
    protected function _getMarkProtected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_markProtectedChecked === true
            && $this->_cacheCurrentEntityUnlocked === $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            if ($this->_cacheMarkProtected === true) {
                $this->_metrology->addLog('Object protected - cache - protected', Metrology::LOG_LEVEL_DEBUG); // Log
            } else {
                $this->_metrology->addLog('Object protected - cache - not protected', Metrology::LOG_LEVEL_DEBUG); // Log
            }
            return $this->_cacheMarkProtected;
        }

        if ($this->_id == '0') {
            return false;
        }

        // Mémorise l'état de connexion de l'entité courante.
        $this->_cacheCurrentEntityUnlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();

        // Liste les liens à la recherche de la propriété.
        $listS = $this->readLinksFilterFull(
            '',
            '',
            'k',
            $this->_id,
            '',
            '');
        $listT = $this->readLinksFilterFull(
            '',
            '',
            'k',
            '',
            $this->_id,
            '');

        // Fait une recherche sur d'autres types de hash si celui par défaut ne renvoie rien.
        if (sizeof($listS) == 0
            && $this->_nebuleInstance->getOption('permitListOtherHash')
        ) {
            // A faire...
        }
        if (sizeof($listT) == 0
            && $this->_nebuleInstance->getOption('permitListOtherHash')
        ) {
            // A faire...
        }

        // Si pas marqué, résultat négatif.
        if (sizeof($listS) == 0
            && sizeof($listT) == 0
        ) {
            $this->_cacheMarkProtected = false;
            $this->_idProtected = '0';
            $this->_idUnprotected = $this->_id;
            $this->_idProtectedKey = '0';
            $this->_idUnprotectedKey = '0';
            $this->_metrology->addLog('Object protected - not protected', Metrology::LOG_LEVEL_DEBUG); // Log
            return false;
        }

        // Sinon.
        $this->_markProtectedChecked = true;
        $result = false;

        if (sizeof($listS) == 0) {
            $this->_metrology->addLog('Object protected - id protected = ' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log
            $this->_idProtected = $this->_id;

            // Recherche la clé utilisée pour l'entité en cours.
            foreach ($listT as $linkSym) {
                // Si lien de chiffrement et l'objet source est l'objet en cours non protégé.
                if ($linkSym->getAction() == 'k'
                    && $linkSym->getHashTarget() == $this->_idProtected
                ) {
                    // Lit l'objet de clé de chiffrement symétrique et ses liens.
                    $instanceSym = $this->_nebuleInstance->newObject($linkSym->getHashMeta());
                    $linksAsym = $instanceSym->readLinksUnfiltred();
                    unset($instanceSym);
                    foreach ($linksAsym as $linkAsym) {
                        // Si lien de chiffrement.
                        $targetA = $linkAsym->getHashTarget();
                        if ($linkAsym->getAction() == 'k'
                            && $linkAsym->getHashTarget() != $this->_idProtected
                            && $this->_nebuleInstance->getIO()->checkObjectPresent($targetA)
                        ) {
                            $result = true;
                            $this->_idUnprotected = $linkSym->getHashSource();
                            $this->_metrology->addLog('Object protected - id unprotected = ' . $this->_idUnprotected, Metrology::LOG_LEVEL_DEBUG); // Log
                            $this->_idUnprotectedKey = $linkAsym->getHashSource();
                            if ($linkAsym->getHashMeta() == $this->_nebuleInstance->getCurrentEntity()) {
                                $this->_idProtectedKey = $targetA;
                                break 2;
                            }
                        }
                    }
                    unset($linksAsym, $linkAsym);
                }
            }
            unset($listT, $linkSym);
        } else {
            $this->_metrology->addLog('Object protected - id unprotected = ' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log
            $this->_idUnprotected = $this->_id;

            // Recherche la clé utilisée pour l'entité en cours.
            foreach ($listS as $linkSym) {
                $targetS = $linkSym->getHashTarget();
                // Si lien de chiffrement et l'objet source est l'objet en cours non protégé.
                if ($linkSym->getAction() == 'k'
                    && $linkSym->getHashSource() == $this->_idUnprotected
                    && $this->_nebuleInstance->getIO()->checkObjectPresent($targetS)
                ) {
                    // Lit l'objet de clé de chiffrement symétrique et ses liens.
                    $instanceSym = $this->_nebuleInstance->newObject($linkSym->getHashMeta());
                    $linksAsym = $instanceSym->readLinksUnfiltred();
                    unset($instanceSym);
                    foreach ($linksAsym as $linkAsym) {
                        $targetA = $linkAsym->getHashTarget();
                        // Si lien de chiffrement.
                        if ($linkAsym->getAction() == 'k'
                            && $linkAsym->getHashSource() != $this->_idUnprotected
                            && $linkAsym->getHashMeta() == $this->_nebuleInstance->getCurrentEntity()
                            && $this->_nebuleInstance->getIO()->checkObjectPresent($targetA)
                        ) {
                            $result = true;
                            $this->_idProtected = $targetS;
                            $this->_metrology->addLog('Object protected - id protected = ' . $this->_idProtected, Metrology::LOG_LEVEL_DEBUG); // Log
                            $this->_idUnprotectedKey = $linkAsym->getHashSource();
                            if ($linkAsym->getHashMeta() == $this->_nebuleInstance->getCurrentEntity()) {
                                $this->_idProtectedKey = $targetA;
                                break 2;
                            }
                        }
                    }
                    unset($linksAsym, $linkAsym);
                }
            }
            unset($listS, $linkSym);
        }

        // Résultat.
        $this->_cacheMarkProtected = $result;
        return $result;
    }

    /**
     * Lit l'ID de l'objet chiffré.
     * @return boolean
     */
    public function getProtectedID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $this->_getMarkProtected();
        return $this->_idProtected;
    }

    /**
     * Lit l'ID de l'objet non chiffré.
     * @return boolean
     */
    public function getUnprotectedID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $this->_getMarkProtected();
        return $this->_idUnprotected;
    }

    /**
     * Protège l'objet.
     *
     * @param boolean $obfuscated
     * @return boolean
     */
    public function setProtected($obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return false;
        }
        if (!$this->_io->checkObjectPresent($this->_id)
            && !$this->_haveData
        ) {
            return false;
        }

        // Vérifie si pas déjà protégé.
        if ($this->_getMarkProtected()) {
            return true;
        }

        $this->_metrology->addLog('Ask protect object ' . $this->_id, Metrology::LOG_LEVEL_DEBUG);

        // Vérifie que l'écriture d'objets et de liens est permise.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            // Génération de la clé de chiffrement.
            // Doit être au maximum de la taille de la clé de l'entité cible (exprimé en bits) moins 11 octets.
            // CF : http://php.net/manual/fr/function.openssl-public-encrypt.php
            // @todo à faire pour le cas général.
            $keySize = self::CRYPTO_SESSION_KEY_SIZE; // En octets.
            $key = $this->_crypto->getStrongRandom($keySize);
            if (strlen($key) != $keySize) {
                return false;
            }
            $keyID = $this->_crypto->hash($key);
            $this->_metrology->addLog('Protect object, key : ' . $keyID, Metrology::LOG_LEVEL_DEBUG);

            // Si des donnnées sont disponibles, on les lit.
            if ($this->_haveData) {
                $data = $this->_data;
            } else {
                // Sinon, on lit le contenu de l'objet. @todo à remplacer par getContent...
                $limit = $this->_nebuleInstance->getOption('ioReadMaxData');
                $data = $this->_nebuleInstance->getIO()->objectRead($this->_id, $limit);

                // Vérification de quota de lecture. @todo à revoir...
                if (strlen($data) >= $limit) {
                    unset($data);
                    $this->_haveData = false;
                    $this->_data = null;
                    return false;
                }
                unset($limit);

                // Vérification de l'empreinte des données. Doit être identique à l'ID.
                // A faire pour le cas général.
                $hash = $this->_crypto->hash($data);
                if ($hash != $this->_id) {
                    unset($data);
                    $this->_haveData = false;
                    $this->_data = null;
                    return false;
                }
                unset($hash);
            }

            // Chiffrement (symétrique) du contenu.
            $code = $this->_crypto->crypt($data, $key);
            unset($data, $keySize);

            // Vérification de bon chiffrement.
            if ($code === false) {
                return false;
            }

            // Chiffrement (asymétrique) de la clé de chiffrement du contenu.
            $codeKey = $this->_crypto->cryptTo($key, $this->_nebuleInstance->getCurrentEntityInstance()->getPublicKey());

            // Vérification de bon chiffrement.
            if ($codeKey === false) {
                return false;
            }

            // Ecrit le contenu chiffré.
            $codeInstance = new Node($this->_nebuleInstance, '0', $code, false);
            $codeID = $codeInstance->getID();
            $this->_metrology->addLog('Protect object, code : ' . $codeID, Metrology::LOG_LEVEL_DEBUG);

            // Vérification de bonne écriture.
            if ($codeID == '0') {
                return false;
            }

            // Ecrit la clé de session chiffrée.
            $codeKeyInstance = new Node($this->_nebuleInstance, '0', $codeKey, false);
            $codeKeyID = $codeKeyInstance->getID();
            $this->_metrology->addLog('Protect object, code key : ' . $codeKeyID, Metrology::LOG_LEVEL_DEBUG);

            // Vérification de bonne écriture.
            if ($codeKeyID == '0') {
                return false;
            }

            $signer = $this->_nebuleInstance->getCurrentEntity();
            $date = date(DATE_ATOM);

            // Crée le lien de type d'empreinte de la clé.
            $action = 'l';
            $source = $keyID;
            $target = $this->_crypto->hash($this->_crypto->hashAlgorithmName());
            $meta = $this->_crypto->hash('nebule/objet/hash');
            $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->signWrite();

            // Création du type mime des données chiffrées.
            $text = 'application/x-encrypted/' . $this->_crypto->symetricAlgorithmName();
            $textID = $this->_nebuleInstance->createTextAsObject($text);
            if ($textID !== false) {
                // Crée le lien de type d'empreinte.
                $action = 'l';
                $source = $codeID;
                $target = $textID;
                $meta = $this->_crypto->hash('nebule/objet/type');
                $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $newLink = new Link($this->_nebuleInstance, $link);
                $newLink->sign();
                if ($obfuscated) {
                    $newLink->obfuscate();
                }
                $newLink->write();
            }

            // Création du type mime de la clé chiffrée.
            $text = 'application/x-encrypted/' . $this->_crypto->asymetricAlgorithmName();
            $textID = $this->_nebuleInstance->createTextAsObject($text);
            if ($textID !== false) {
                // Crée le lien de type d'empreinte.
                $action = 'l';
                $source = $codeKeyID;
                $target = $textID;
                $meta = $this->_crypto->hash('nebule/objet/type');
                $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $newLink = new Link($this->_nebuleInstance, $link);
                $newLink->sign();
                if ($obfuscated) {
                    $newLink->obfuscate();
                }
                $newLink->write();
            }

            // Création du lien de chiffrement symétrique.
            $action = 'k';
            $source = $this->_id;
            $target = $codeID;
            $meta = $keyID;
            $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->sign();
            if ($obfuscated) {
                $newLink->obfuscate();
            }
            $newLink->write();

            // Création du lien de chiffrement asymétrique.
            $action = 'k';
            $source = $keyID;
            $target = $codeKeyID;
            $meta = $signer;
            $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->sign();
            if ($obfuscated) {
                $newLink->obfuscate();
            }
            $newLink->write();

            // Supprime l'objet qui a été marqué protégé.
            $this->_metrology->addLog('Delete unprotected object ' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log
            $deleteObject = true;

            // Création lien.
            $signer = $this->_nebuleInstance->getCurrentEntity();
            $date = date(DATE_ATOM);
            $source = $this->_id;
            $link = '0_' . $signer . '_' . $date . '_d_' . $source . '_0_0';
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->sign();
            if ($obfuscated) {
                $newLink->obfuscate();
            }
            $newLink->write();

            // Lit les liens.
            $links = $this->readLinksUnfiltred();
            $entity = $this->_nebuleInstance->getCurrentEntity();
            foreach ($links as $link) {
                // Vérifie si l'entité signataire du lien est l'entité courante.
                if ($link->getHashSigner() != $entity) {
                    // Si ce n'est pas l'entité courante, quitte.
                    $this->_metrology->addAction('delobj', $this->_id, false);
                    $deleteObject = false;
                }
            }

            if ($deleteObject) {
                // Supprime l'objet.
                $r = $this->_io->objectDelete($this->_id);

                // Métrologie.
                $this->_metrology->addAction('delobj', $this->_id, $r);
            }

            // Mémorisation de l'état de protection.
            $this->_markProtectedChecked = true;
            $this->_cacheMarkProtected = true;
            $this->_idProtected = $codeID;
            $this->_idUnprotected = $this->_id;
            $this->_idProtectedKey = $codeKeyID;
            $this->_idUnprotectedKey = $keyID;

            // Si autorisé, partage la protection avec les entités de recouvrement.
            if ($this->_nebuleInstance->getOption('permitRecoveryEntities')) {
                $listEntities = $this->_nebuleInstance->getRecoveryEntitiesInstance();
                foreach ($listEntities as $entity) {
                    if (is_a($entity, 'Entity')
                        && $entity->getID() != '0'
                        && $entity->getIsPublicKey()
                        && $entity != $this->_nebuleInstance->getCurrentEntity()
                    ) {
                        // Chiffrement (asymétrique) de la clé de chiffrement du contenu.
                        $codeKey = $this->_crypto->cryptTo($key, $entity->getPublicKey());

                        // Vérification de bon chiffrement.
                        if ($codeKey === false) {
                            $this->_metrology->addLog('Error (1) share protection to recovery ' . $entity->getID(), Metrology::LOG_LEVEL_ERROR); // Log
                            continue;
                        }

                        // Ecrit la clé de session chiffrée.
                        $codeKeyInstance = new Node($this->_nebuleInstance, '0', $codeKey, false);
                        $codeKeyID = $codeKeyInstance->getID();
                        $this->_metrology->addLog('Protect object, code key : ' . $codeKeyID, Metrology::LOG_LEVEL_DEBUG);

                        // Vérification de bonne écriture.
                        if ($codeKeyID == '0') {
                            $this->_metrology->addLog('Error (2) share protection to recovery ' . $entity->getID(), Metrology::LOG_LEVEL_ERROR); // Log
                            continue;
                        }

                        // Création du type mime de la clé chiffrée.
                        $text = 'application/x-encrypted/' . $this->_crypto->asymetricAlgorithmName();
                        $textID = $this->_nebuleInstance->createTextAsObject($text);
                        if ($textID !== false) {
                            // Crée le lien de type d'empreinte.
                            $action = 'l';
                            $source = $codeKeyID;
                            $target = $textID;
                            $meta = $this->_crypto->hash('nebule/objet/type');
                            $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                            $newLink = new Link($this->_nebuleInstance, $link);
                            $newLink->sign();
                            if ($obfuscated) {
                                $newLink->obfuscate();
                            }
                            $newLink->write();
                        }

                        // Création du lien de chiffrement asymétrique.
                        $action = 'k';
                        $source = $keyID;
                        $target = $codeKeyID;
                        $meta = $entity->getID();
                        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                        $newLink = new Link($this->_nebuleInstance, $link);
                        $newLink->sign();
                        if ($obfuscated) {
                            $newLink->obfuscate();
                        }
                        $newLink->write();

                        $this->_metrology->addLog('Set protection shared to recovery ' . $entity->getID(), Metrology::LOG_LEVEL_DEBUG); // Log
                    }
                }
            }
            unset($links, $entity, $link, $deleteObject, $newLink, $signer, $date, $source);

            return true;
        }
    }

    /**
     * Déprotège l'objet.
     * @return boolean
     */
    public function setUnprotected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que l'objet est protégé et que l'on peut y acceder.
        if (!$this->_getMarkProtected()) {
            return false;
        }
        if ($this->_idProtected == '0') {
            return false;
        }
        if ($this->_idUnprotected == '0') {
            return false;
        }
        if ($this->_idProtectedKey == '0') {
            return false;
        }
        if ($this->_idUnprotectedKey == '0') {
            return false;
        }

        $this->_metrology->addLog('Set unprotected ' . $this->_id, Metrology::LOG_LEVEL_NORMAL); // Log

        // @todo

        return false;
    }

    /**
     * Protège l'objet pour une entité.
     *
     * L'objet devient illisible en verrouillant l'entité courante !
     *
     * @param $entity entity|string
     * @return boolean
     */
    public function setProtectedTo($entity)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // @todo
    }

    /**
     * Transmet la protection de l'objet à une entité.
     *
     * @param $entity entity|string
     * @return boolean
     */
    public function shareProtectionTo($entity)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if (is_string($entity)) {
            $entity = $this->_nebuleInstance->newEntity($entity);
        }
        if (!is_a($entity, 'entity')) {
            $entity = $this->_nebuleInstance->newEntity($entity->getID());
        }
        if (!$entity->getIsEntity('all')) {
            return false;
        }

        // Vérifie que l'objet est protégé et que l'on peut y acceder.
        if (!$this->_getMarkProtected()
            || $this->_idProtected == '0'
            || $this->_idUnprotected == '0'
            || $this->_idProtectedKey == '0'
            || $this->_idUnprotectedKey == '0'
        ) {
            return false;
        }

        $this->_metrology->addLog('Set protected to ' . $entity->getID(), Metrology::LOG_LEVEL_DEBUG); // Log

        // Lit la clé chiffrée. @todo à remplacer par getContent ...
        $limit = $this->_nebuleInstance->getOption('ioReadMaxData');
        $codeKey = $this->_nebuleInstance->getIO()->objectRead($this->_idProtectedKey, $limit);
        // Calcul l'empreinte de la clé chiffrée.
        $hash = $this->_crypto->hash($codeKey);
        if ($hash != $this->_idProtectedKey) {
            $this->_metrology->addLog('Error get protected key content : ' . $this->_idProtectedKey, Metrology::LOG_LEVEL_NORMAL); // Log
            $this->_metrology->addLog('Protected key content hash : ' . $hash, Metrology::LOG_LEVEL_NORMAL); // Log
            return false;
        }

        // Déchiffrement (asymétrique) de la clé de chiffrement du contenu.
        $key = $this->_nebuleInstance->getCurrentEntityInstance()->decrypt($codeKey);
        // Calcul l'empreinte de la clé.
        $hash = $this->_crypto->hash($key);
        if ($hash != $this->_idUnprotectedKey) {
            $this->_metrology->addLog('Error get unprotected key content : ' . $this->_idUnprotectedKey, Metrology::LOG_LEVEL_NORMAL); // Log
            $this->_metrology->addLog('Unprotected key content hash : ' . $hash, Metrology::LOG_LEVEL_NORMAL); // Log
            return false;
        }

        // Chiffrement (asymétrique) de la clé de chiffrement du contenu.
        $codeKey = $this->_crypto->cryptTo($key, $entity->getPublicKey());

        // Vérification de bon chiffrement.
        if ($codeKey === false) {
            return false;
        }

        // Ecrit la clé chiffrée.
        $codeKeyInstance = new Node($this->_nebuleInstance, '0', $codeKey, false);
        $codeKeyID = $codeKeyInstance->getID();
        $this->_metrology->addLog('Protect object, code key : ' . $codeKeyID, Metrology::LOG_LEVEL_NORMAL); // Log

        // Vérification de bonne écriture.
        if ($codeKeyID == '0') {
            return false;
        }

        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);

        // Création du type mime de la clé chiffrée.
        $text = 'application/x-encrypted/' . $this->_crypto->asymetricAlgorithmName();
        $textID = $this->_nebuleInstance->createTextAsObject($text);
        if ($textID !== false) {
            // Crée le lien de type d'empreinte.
            $action = 'l';
            $source = $codeKeyID;
            $target = $textID;
            $meta = $this->_crypto->hash('nebule/objet/type');
            $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
            $newLink = new Link($this->_nebuleInstance, $link);
            // Signe le lien.
            $newLink->sign();
            // Ecrit le lien.
            $newLink->write();
        }

        // Création du lien de chiffrement asymétrique.
        $action = 'k';
        $source = $this->_idUnprotectedKey;
        $target = $codeKeyID;
        $meta = $entity->getID();
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        // Signe le lien.
        $newLink->sign();
        // Ecrit le lien.
        $newLink->write();

        return true;
    }

    /**
     * Transmet l'annulation de la protection de l'objet à une entité.
     * Ne marche pas si il y a eu plusieurs protections/déprotections/protections/... !!!
     * @param $entity entity|string
     * @return boolean
     * @todo
     *
     */
    public function cancelShareProtectionTo($entity)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if (is_string($entity)) {
            $entity = $this->_nebuleInstance->newEntity($entity);
        }
        if (!is_a($entity, 'entity')) {
            $entity = $this->_nebuleInstance->newEntity($entity->getID());
        }
        if (!$entity->getIsEntity('all')) {
            return false;
        }

        // Vérifie que l'objet est protégé et que l'on peut y acceder.
        if (!$this->_getMarkProtected()) {
            return false;
        }
        if ($this->_idProtected == '0') {
            return false;
        }
        if ($this->_idUnprotected == '0') {
            return false;
        }
        if ($this->_idProtectedKey == '0') {
            return false;
        }
        if ($this->_idUnprotectedKey == '0') {
            return false;
        }

        // Vérifie que la protection n'est pas partagée à une entité de recouvrement.
        if (!$this->_nebuleInstance->getOption('permitRecoveryRemoveEntity')
            && $this->_nebuleInstance->getIsRecoveryEntity($entity->getID())
        ) {
            return false;
        }

        $this->_metrology->addLog('Cancel share protection to ' . $entity->getID(), Metrology::LOG_LEVEL_NORMAL); // Log

        // Recherche l'objet de clé de chiffrement pour l'entité.
        $links = $entity->readLinksFilterFull(
            $this->_nebuleInstance->getCurrentEntity(),
            '',
            'k',
            $this->_idUnprotectedKey,
            '',
            $entity->getID());

        if (sizeof($links) == 0) {
            return true;
        }

        foreach ($links as $item) {
            $idKey = $item->getHashSource();
            $idProtectedKey = $item->getHashTarget();
            if ($idKey != '0' && $idProtectedKey != '0') {
                // Création du lien d'annulation de chiffrement asymétrique.
                $signer = $this->_nebuleInstance->getCurrentEntity();
                $date = date(DATE_ATOM);
                $action = 'x';
                $source = $idKey;
                $target = $idProtectedKey;
                $meta = $entity->getID();
                $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $newLink = new Link($this->_nebuleInstance, $link);
                // Signe le lien.
                $newLink->sign();
                // Ecrit le lien.
                $newLink->write();

                // Suppression de la clé de chiffrement protégée.
                $object = $this->_nebuleInstance->newObject($idProtectedKey);
                //$object->deleteObject();
                $signerLinks = $object->readLinksFilterFull('', '', '', '', '', '');
                $delete = true;
                foreach ($signerLinks as $itemSigner) {
                    // Si un lien a été généré par une autre entité, c'est que l'objet est encore utilisé.
                    if ($itemSigner->getHashSigner() != $signer && $itemSigner->getHashSigner() != $this->_nebuleInstance->getCurrentEntity()) {
                        $delete = false;
                    }
                }
                if ($delete) {
                    $this->_io->objectDelete($idProtectedKey);
                }
                unset($object, $signerLinks, $itemSigner, $delete);
            }
        }
        unset($links);

        return true;
    }


    /**
     * Lit une émotion pour l'objet.
     *
     * La sélection d'une classe sociale particulière permet de faire un filtre sur la recherche.
     * Les classes sociales intéressantes :
     *  - self : mes émotions sur l'objet ;
     *  - notself : les émotions de toutes les entités sauf moi sur l'objet ;
     *  - all : les émotions de toutes les entités sur l'objet.
     *
     * @param string $emotion
     * @param string $socialClass
     * @param string|Node $context
     * @return boolean
     */
    public function getMarkEmotion($emotion, $socialClass = '', $context = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->getMarkEmotionSize($emotion, $socialClass, $context) == 0) {
            return false;
        }
        return true;
    }

    /**
     * Lit la liste des entités qui ont marqué une émotion pour l'objet.
     * @param string $emotion
     * @param string $socialClass
     * @param string|Node $context
     * @return array:Link
     * @todo hash alternatifs.
     *
     * Par défaut, le contexte de recherche est vide.
     * Dans ce cas, on ne garde que les liens avec comme contexte l'entité qui a signé le lien.
     *
     */
    public function getMarkEmotionList($emotion, $socialClass = '', $context = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $list = array();

        // Nettoyage du contexte.
        if (is_a($context, 'entity')
            || is_a($context, 'Node')
            || is_a($context, 'group')
            || is_a($context, 'conversation')
        ) {
            $context = $context->getID();
        }
        if (!is_string($context)
            || $context == '0'
            || !ctype_xdigit($context)
        ) {
            $context = '';
        }

        // Vérifie que l'émotion existe.
        if ($emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET
        ) {
            return $list;
        }

        $hashEmotion = $this->_crypto->hash($emotion);

        // Liste les liens à la recherche de la propriété.
        $list = $this->readLinksFilterFull(
            '',
            '',
            'f',
            $this->_id,
            $hashEmotion,
            $context);

        // Nettoyage.
        foreach ($list as $i => $link) {
            // Si méta à 0, supprime le lien.
            if ($link->getHashMeta() == '0') {
                unset($list[$i]);
            }
        }
        unset($link);

        // Fait une recherche sur d'autres types de hash si celui par défaut ne renvoie rien.
        if (sizeof($list) == 0
            && $this->_nebuleInstance->getOption('permitListOtherHash')
        ) {
            // A faire...
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($list, $socialClass);

        return $list;
    }

    /**
     * Lit le nombre d'entités qui ont marqué une émotion pour l'objet.
     *
     * @param string $emotion
     * @param string $socialClass
     * @param string|Node $context
     * @return array:Link
     */
    public function getMarkEmotionSize($emotion, $socialClass = '', $context = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $list = $this->getMarkEmotionList($emotion, $socialClass, $context);
        return sizeof($list);
    }

    /**
     * Lit toute les émotions pour l'objet.
     *
     * @param string $socialClass
     * @param string|Node $context
     * @return array:string
     */
    public function getMarkEmotions($socialClass = '', $context = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $result = array();

        $result[nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE] = $this->getMarkEmotion(nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE, $socialClass, $context);
        $result[nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE] = $this->getMarkEmotion(nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE, $socialClass, $context);
        $result[nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR] = $this->getMarkEmotion(nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR, $socialClass, $context);
        $result[nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE] = $this->getMarkEmotion(nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE, $socialClass, $context);
        $result[nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE] = $this->getMarkEmotion(nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE, $socialClass, $context);
        $result[nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT] = $this->getMarkEmotion(nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT, $socialClass, $context);
        $result[nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE] = $this->getMarkEmotion(nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE, $socialClass, $context);
        $result[nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET] = $this->getMarkEmotion(nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET, $socialClass, $context);

        return $result;
    }

    /**
     * Ecrit une émotion pour l'objet.
     *
     * La marque d'un émotion sur l'objet est un lien de type f avec :
     *  - source : l'ID de l'objet
     *  - cible : le hash de l'émotion
     *  - méta : le signataire ou l'objet de contexte (conversation par exemple)
     *
     * Le lien peut être dissimulé.
     *
     * L'émotion peut être rattachée en contexte à
     *  - une autre entité @param string $emotion
     * @param boolean $obfuscate
     * @param string $context
     * @return boolean
     * @todo à revoir...
     *  - ou un objet particulier
     * Cela permet par défaut de discriminer précisément lorsque l'émotion concerne l'objet
     *   ou si l'émotion se réfère à un contexte particulier de l'objet comme une conversation.
     * Par défaut le contexte est l'entité en cours, l'émotion est attaché à cet objet directement.
     *
     */
    public function setMarkEmotion($emotion, $obfuscate = false, $context = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que l'émotion existe.
        if ($emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET
        ) {
            return false;
        }

        // Nettoyage du contexte.
        if (is_a($context, 'entity')
            || is_a($context, 'Node')
            || is_a($context, 'group')
            || is_a($context, 'conversation')
        ) {
            $context = $context->getID();
        }
        if (!is_string($context)
            || $context == '0'
            || $context == ''
            || !ctype_xdigit($context)
        ) {
            $context = $this->_nebuleInstance->getCurrentEntity();
        }

        // Création du lien.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'f';
        $source = $this->_id;
        $target = $this->_crypto->hash($emotion);
        $meta = $context;
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();
        if ($obfuscate) {
            $newLink->obfuscate();
        }
        $newLink->write();

        return true;
    }

    /**
     * Supprime une émotion pour l'objet.
     *
     * Le lien de suppression peut être dissimulé et ainsi laisser publique l'émotion.
     * L'émotion peut être rattachée à une autre entité.
     *
     * @param string $emotion
     * @param boolean $obfuscate
     * @param string $entity
     * @return boolean
     */
    public function unsetMarkEmotion($emotion, $obfuscate = false, $entity = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que l'émotion existe.
        if ($emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE
            && $emotion != nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET
        ) {
            return false;
        }

        // Nettoyage de l'entité demandé.
        if (is_a($entity, 'entity')
            || is_a($entity, 'Node')
            || is_a($entity, 'group')
            || is_a($entity, 'conversation')
        ) {
            $entity = $entity->getID();
        }
        if (!is_string($entity)
            || $entity == '0'
            || $entity == ''
            || !ctype_xdigit($entity)
        ) {
            $entity = $this->_nebuleInstance->getCurrentEntity();
        }

        // Création du lien.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'x';
        $source = $this->_id;
        $target = $this->_crypto->hash($emotion);
        $meta = $entity;
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();
        if ($obfuscate) {
            $newLink->obfuscate();
        }
        $newLink->write();

        return true;
    }


    /**
     * Lit à quelles entités à été transmis la protection de l'objet.
     *
     * @return array:string
     */
    public function getProtectedTo()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $result = array();
        if (!$this->_getMarkProtected()) {
            return $result;
        }

        // Lit les liens de chiffrement de l'objet, chiffrement symétrique.
        $linksSym = $this->readLinksFilterFull('', '', 'k', $this->_idUnprotected, '', '');
        foreach ($linksSym as $linkSym) {
            // Si lien de chiffrement.
            if ($linkSym->getHashMeta() != '0') {
                // Lit l'objet de clé de chiffrement symétrique et ses liens.
                $instanceSym = $this->_nebuleInstance->newObject($linkSym->getHashMeta());
                $linksAsym = $instanceSym->readLinksFilterFull(
                    '',
                    '',
                    'k',
                    $linkSym->getHashMeta(),
                    '',
                    ''
                );
                unset($instanceSym);
                foreach ($linksAsym as $linkAsym) {
                    // Si lien de chiffrement.
                    if ($linkAsym->getHashMeta() != '0') {
                        $result[] = $linkAsym->getHashMeta();
                    }
                }
                unset($linksAsym, $linkAsym);
            }
        }
        unset($linksSym, $linkSym);
        return $result;
    }


    /**
     * Vérifie la consistance de l'objet.
     *
     * Retourne true  si l'objet a déjà été vérifié.
     * Retourne false si l'objet n'est pas présent.
     * Retourne false si la fonction de hash n'est pas reconnue ou invalide, l'objet n'est pas vérifié.
     * Retourne false si l'extraction de l'objet échoue, l'objet n'est pas vérifié.
     * Retourne false si l'objet n'est pas valide, il est supprimé.
     * Retourne true  si l'empreinte de l'objet est valide.
     *
     * En cas de type de hash inconnu ou invalide, et si l'option permitDeleteObjectOnUnknownHash est à true,
     *   choisi l'algorithme de hash par défaut comme dernière chance.
     *   Si l'empreinte ne correspond pas, l'objet sera supprimé.
     *
     * @return boolean
     */
    public function checkConsistency()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_haveData) {
            return true;
        }

        if (!$this->_io->checkObjectPresent($this->_id)) {
            return false;
        }

        // Si c'est l'objet 0, le supprime.
        if ($this->_id == '0') {
            $this->_data = null;
            $this->_metrology->addLog('Delete object 0', Metrology::LOG_LEVEL_NORMAL); // Log
            $this->_io->objectDelete('0');
            return false;
        }

        // Détermine l'algorithme de hash.
        $hashAlgo = $this->getHashAlgo();
        if (!$this->_crypto->checkHashAlgorithm($hashAlgo)
            && $this->_nebuleInstance->getOption('permitSynchronizeLink')
        ) {
            // Essaie une synchronisation rapide des liens.
            $this->syncLinks(false);
        }
        $hashAlgo = $this->getHashAlgo();
        if (!$this->_crypto->checkHashAlgorithm($hashAlgo)) {
            if ($this->_nebuleInstance->getOption('permitDeleteObjectOnUnknownHash')) {
                // Si pas trouvé d'algorithme valide, utilise celui par défaut.
                $hashAlgo = $this->_crypto->hashAlgorithmName();
            } else {
                return false;
            }
        }

        // Extrait le contenu de l'objet, si possible.
        $this->_metrology->addObjectRead(); // Metrologie.
        $this->_data = $this->_io->objectRead($this->_id);
        if ($this->_data === false) {
            $this->_metrology->addLog('Cant read object ' . $this->_id, Metrology::LOG_LEVEL_ERROR); // Log
            $this->_data = null;
            return false;
        }
        $this->_metrology->addLog('Object size ' . $this->_id . ' ' . strlen($this->_data) . '/' . $maxLimit, Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie la taille.
        if (strlen($this->_data) >= $limit
            && $limit < $maxLimit
        ) {
            $this->_data = null;
            return false;
        }

        // Calcul l'empreinte.
        $hash = $this->_crypto->hash($this->_data, $hashAlgo);
        if ($hash == $this->_id) // Si l'objet est valide.
        {
            $this->_metrology->addObjectVerify(); // Metrologie.
            $this->_haveData = true;
            return true;
        }

        // Si la vérification est désactivée, quitte.
        if (!$this->_nebuleInstance->getOption('permitCheckObjectHash')) {
            $this->_metrology->addLog('Warning - Invalid object hash ' . $this->_id, Metrology::LOG_LEVEL_ERROR); // Log
            $this->_haveData = true;
            return true;
        }

        // Sinon l'objet est présent mais invalide, le supprime.
        $this->_data = null;
        $this->_metrology->addLog('Delete unconsistency object ' . $this->_id . ' ' . $hashAlgo . ':' . $hash, Metrology::LOG_LEVEL_NORMAL); // Log
        $this->_io->objectDelete($this->_id);
        return false;
    }

    /**
     * Lit le contenu de l'objet.
     * Retourne une chaine vide si l'empreinte des données diffère de l'ID.
     *
     * @param integer $limit limite de lecture du contenu de l'objet.
     * @return string
     */
    public function getContent($limit = 0)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_haveData) {
            return $this->_data;
        }

        if ($this->_getMarkProtected()) {
            return $this->_getProtectedContent($limit);
        } else {
            return $this->_getUnprotectedContent($limit);
        }
    }

    /**
     * Lit le contenu de l'objet sans essayer de le déchiffrer.
     * Retourne une chaine vide si l'empreinte des données diffère de l'ID.
     *
     * @param integer $limit limite de lecture du contenu de l'objet.
     * @return string
     */
    public function getContentAsUnprotected($limit = 0)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_getUnprotectedContent($limit);
    }

    /**
     * Lit sans déchiffrer un contenu (non protégé).
     *
     * @param integer $limit limite de lecture du contenu de l'objet.
     * @return string|null
     */
    protected function _getUnprotectedContent($limit = 0)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_haveData) {
            return $this->_data;
        }

        if (!$this->_io->checkObjectPresent($this->_id)) {
            return null;
        }

        // Si c'est l'objet 0, le supprime.
        if ($this->_id == '0') {
            $this->_data = null;
            $this->_metrology->addLog('Delete object 0', Metrology::LOG_LEVEL_NORMAL); // Log
            $this->_io->objectDelete('0');
            return null;
        }

        // Détermine l'algorithme de hash.
        $hashAlgo = $this->getHashAlgo();
        if (!$this->_crypto->checkHashAlgorithm($hashAlgo)
            && $this->_nebuleInstance->getOption('permitSynchronizeLink')
        ) {
            // Essaie une synchronisation rapide des liens.
            $this->syncLinks(false);
        }
        $hashAlgo = $this->getHashAlgo();
        if (!$this->_crypto->checkHashAlgorithm($hashAlgo)) {
            if ($this->_nebuleInstance->getOption('permitDeleteObjectOnUnknownHash')) {
                // Si pas trouvé d'algorithme valide, utilise celui par défaut.
                $hashAlgo = $this->_crypto->hashAlgorithmName();
            } else {
                return null;
            }
        }

        // Prépare la limite de lecture.
        $maxLimit = $this->_nebuleInstance->getOption('ioReadMaxData');
        if ($limit == 0
            || $limit > $maxLimit
        ) {
            $limit = $maxLimit;
        }

        // Extrait le contenu de l'objet, si possible.
        $this->_metrology->addObjectRead(); // Metrologie.
        $this->_data = $this->_io->objectRead($this->_id, $limit);
        if ($this->_data === false) {
            $this->_metrology->addLog('Cant read object ' . $this->_id, Metrology::LOG_LEVEL_ERROR); // Log
            $this->_data = null;
            return null;
        }
        $this->_metrology->addLog('Object read size ' . $this->_id . ' ' . strlen($this->_data) . '/' . $maxLimit, Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie la taille. Si trop grand mais qu'une limite est imposé, quitte sans vérifier l'empreinte.
        if (strlen($this->_data) >= $limit
            && $limit < $maxLimit
        ) {
            $this->_data = null;
            return null;
        }

        // Calcul l'empreinte.
        $hash = $this->_crypto->hash($this->_data, $hashAlgo);
        if ($hash == $this->_id) // Si l'objet est valide.
        {
            $this->_metrology->addObjectVerify(); // Metrologie.
            $this->_haveData = true;
            return $this->_data;
        }

        // Si la vérification est désactivée, quitte.
        if (!$this->_nebuleInstance->getOption('permitCheckObjectHash')) {
            $this->_metrology->addLog('Warning - Invalid object hash ' . $this->_id, Metrology::LOG_LEVEL_ERROR); // Log
            $this->_haveData = true;
            return $this->_data;
        }

        // Sinon l'objet est présent mais invalide, le supprime.
        $this->_data = null;
        $this->_metrology->addLog('Delete unconsistency object ' . $this->_id . ' ' . $hashAlgo . ':' . $hash, Metrology::LOG_LEVEL_NORMAL); // Log
        $this->_io->objectDelete($this->_id);
        return null;
    }

    /**
     * Lit et déchiffre un contenu protégé.
     * @param integer $limit limite de lecture du contenu de l'objet.
     * @param boolean $permitTroncate permet de faire une lecture partiel des gros objets, donc non vérifié.
     * @return string|null
     * @todo à revoir en entier !
     *
     */
    protected function _getProtectedContent($limit = 0)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_haveData) {
            return $this->_data;
        }

        // Si non protégé, retourne le contenu de l'objet.
        if (!$this->_getMarkProtected()
            || $this->_idProtected == '0'
            || $this->_idUnprotected == '0'
            || $this->_idProtectedKey == '0'
            || $this->_idUnprotectedKey == '0'
        ) {
            return $this->_getUnprotectedContent($limit);
        }

//		if ( $limit == 0 )
//			$limit = $this->_nebuleInstance->getOption('ioReadMaxData');

        $permitTroncate = false; // @todo à retirer.

        $this->_metrology->addLog('Get protected content : ' . $this->_idUnprotected, Metrology::LOG_LEVEL_DEBUG); // Log

        // Lit la clé chiffrée.
        $codeKey = $this->_io->objectRead($this->_idProtectedKey, 0);
        // Calcul l'empreinte de la clé chiffrée.
        $hash = $this->_crypto->hash($codeKey);
        if ($hash != $this->_idProtectedKey) {
            $this->_metrology->addLog('Error get protected key content : ' . $this->_idProtectedKey, Metrology::LOG_LEVEL_ERROR);
            $this->_metrology->addLog('Protected key content hash : ' . $hash, Metrology::LOG_LEVEL_ERROR);
            return null;
        }

        // Déchiffrement (asymétrique) de la clé de chiffrement du contenu.
        $key = $this->_nebuleInstance->getCurrentEntityInstance()->decrypt($codeKey);
        // Calcul l'empreinte de la clé.
        $hash = $this->_crypto->hash($key);
        if ($hash != $this->_idUnprotectedKey) {
            $this->_metrology->addLog('Error get unprotected key content : ' . $this->_idUnprotectedKey, Metrology::LOG_LEVEL_ERROR);
            $this->_metrology->addLog('Unprotected key content hash : ' . $hash, Metrology::LOG_LEVEL_ERROR);
            return null;
        }

        // Lit l'objet chiffré.
        $code = $this->_io->objectRead($this->_idProtected, $limit);
        // Calcul l'empreinte des données.
        $hash = $this->_crypto->hash($code);
        if ($hash != $this->_idProtected) {
            $this->_metrology->addLog('Error get protected data content : ' . $this->_idProtected, Metrology::LOG_LEVEL_ERROR);
            $this->_metrology->addLog('Protected data content hash : ' . $hash, Metrology::LOG_LEVEL_ERROR);
            return null;
        }

        $data = $this->_crypto->decrypt($code, $key);
        // Calcul l'empreinte des données.
        $hash = $this->_crypto->hash($data);
        if ($hash != $this->_idUnprotected) {
            $this->_metrology->addLog('Error get unprotected data content : ' . $this->_idUnprotected, Metrology::LOG_LEVEL_ERROR);
            $this->_metrology->addLog('Unprotected data content hash : ' . $hash, Metrology::LOG_LEVEL_ERROR);
            return null;
        }

        unset($code, $key, $codeKey, $hash);
        return $data;
    }

    /**
     * Vide le cache de données du contenu de l'objet.
     * Ca ne supprime pas l'objet ou son contenu mais juste la copie du contenu en mémoire.
     *
     * Cette fonction peut être utilisé lorsque l'on veut réduire la mémoire utilisée quand on manipule beaucoup d'objets un peu volumineux.
     *
     * @return void
     */
    public function flushDataCache()
    {
        $this->_data = null;
        $this->_haveData = false;
        $this->_code = null;
        $this->_haveCode = false;
    }

    /**
     * Lit la première ligne du contenu d'un (autre) objet nebule, extrait une chaine de texte imprimable.
     *
     * @param string $id
     * @return string
     */
    protected function _readOneLineOtherObject($id)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($id == ''
            || !$this->_io->checkObjectPresent($id)
        ) {
            return '';
        }

        $instance = $this->_nebuleInstance->newObject($id);
        $text = mb_convert_encoding(substr(trim(strtok(filter_var($instance->getContent(0), FILTER_SANITIZE_STRING), "\n")), 0, 1024), 'UTF-8');
        unset($instance);
        return $text;
    }

    /**
     * Lit la première ligne du contenu de l'objet nebule, extrait une chaine de texte imprimable.
     *
     * @param integer $limit
     * @return string
     */
    public function readOneLineAsText($limit = 0)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if (!$this->_io->checkObjectPresent($this->_id)) {
            return '';
        }

        if ($limit == 0) {
            $limit = $this->_nebuleInstance->getOption('ioReadMaxData');
        }
        if ($limit < 4) {
            $limit = 4;
        }

        $text = mb_convert_encoding(trim(strtok(filter_var($this->getContent($limit), FILTER_SANITIZE_STRING), "\n")), 'UTF-8');
        if (strlen($text) > $limit) {
            $text = substr($text, 0, ($limit - 3)) . '...';
        }

        return $text;
    }

    /**
     * Lit le contenu de l'objet nebule, extrait une chaine de texte imprimable.
     *
     * @param integer $limit
     * @return string
     */
    public function readAsText($limit = 0)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if (!$this->_io->checkObjectPresent($this->_id)) {
            return '';
        }
        if ($limit < 4) {
            $limit = 4;
        }

        $text = mb_convert_encoding(trim(filter_var($this->getContent($limit + 4), FILTER_SANITIZE_STRING)), 'UTF-8');
        if (strlen($text) > $limit) {
            $text = substr($text, 0, ($limit - 3)) . '...';
        }
        return $text;
    }

    /**
     * Lit les liens.
     * Retourne un tableau d'objets de type Link ou un tableau vide si ça se passe mal.
     * Pas de filtre sur l'extraction des liens.
     * Trie les liens par date.
     *
     * @return array|boolean
     */
    public function readLinksUnfiltred()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $permitListInvalidLinks = $this->_nebuleInstance->getOption('permitListInvalidLinks');
        $linkVersion = 'nebule/liens/version/' . $this->_nebuleInstance->getOption('defaultLinksVersion'); // Version de lien.
        $linksResult = array();
        if (!$this->_io->checkLinkPresent($this->_id)) {
            return $linksResult;
        }
        $i = 0;

        // Lit les liens.
        $links = $this->_io->linksRead($this->_id);
        $this->_metrology->addLog('Object links count read ' . $this->_id . ' ' . sizeof($links), Metrology::LOG_LEVEL_DEBUG); // Log

        // Analyse les liens et les convertis en tableau d'objets de type lien.
        foreach ($links as $link) {
            if (substr($link, 0, 21) == 'nebule/liens/version/') {
                $linkVersion = trim(substr($link, 0, 25)); // Mémorise la version mais ne valide pas la ligne comme lien.
            } else {
                $l = $this->_nebuleInstance->newLink($link, $linkVersion);
                // Si c'est bon,
                if ($l->getValid()
                    || $permitListInvalidLinks
                ) {
                    $linksResult[$i] = $l;        // on l'écrit dans le tableau des résultats.
                    $i++;
                } else unset($l);                    // Sinon un détruit le lien.
            }
        }
        unset($permitListInvalidLinks, $linkVersion, $i, $links, $link);

        // Tri les liens par date.
        if (sizeof($linksResult) != 0) {
            foreach ($linksResult as $n => $t) {
                $linkdate[$n] = $t->getDate_disabled();
            }
            array_multisort($linkdate, SORT_STRING, SORT_ASC, $linksResult);
            unset($n, $t);
        }

        return $linksResult;
    }


    /**
     * Lit les liens avec un filtrage simple.
     *
     * Retourne un tableau de liens ou un tableau vide si ça se passe mal.
     * Un filtre simple est réalisé lors de l'extraction des liens.
     * Les liens marqués supprimés, càd marqués par un autre lien type x à une date égale ou +, sont enlevés.
     * Les liens de type x ne sont pas retournés.
     * Le paramètre $filter doit correspondre à au moins un des champs :
     * - signataire
     * - action
     * - date
     * - source
     * - destination
     * - méta
     * Trie les liens par date.
     *
     * @param string $filter
     * @return array:Link
     */
    public function readLinksFilterOnce($filter)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $permitListInvalidLinks = $this->_nebuleInstance->getOption('permitListInvalidLinks');
        $linkVersion = 'nebule/liens/version/' . $this->_nebuleInstance->getOption('defaultLinksVersion'); // Version de lien.
        $linksResult = array();
        if (!$this->_io->checkLinkPresent($this->_id)) {
            return $linksResult;
        }
        $i = 0;

        // Lit les liens.
        $links = $this->_io->linksRead($this->_id);
        $this->_metrology->addLog('Object links count read ' . $this->_id . ' ' . sizeof($links), Metrology::LOG_LEVEL_DEBUG); // Log

        // Analyse les liens, les filtre et les convertis en tableau d'objets de type lien.
        // Si la liste des liens n'est pas vide.
        if (sizeof($links) != 0) {
            foreach ($links as $link) {
                // Ce traitement sur champs brutes est une optimisation du temps de traitement. Le gain est de 1 à 10.
                // Extrait les champs du lien.
                $j = 1;                        // Indice du champs lu, de 1 à 7.
                $c = array();                    // Table des champs lus.
                $e = strtok(trim($link), '_');    // Lecture du champs.
                while ($e !== false)            // Extrait le lien.
                {
                    $c[$j] = trim($e);
                    if ($j < 8) {
                        $e = strtok('_');
                    } else {
                        $e = false;
                    }
                    $j++;
                }

                if (substr($link, 0, 21) == 'nebule/liens/version/') {
                    $linkVersion = trim(substr($link, 0, 25)); // Mémorise la version mais ne valide pas la ligne comme lien.
                } elseif ($j == 8) {
                    // Filtre les liens.
                    if ($c[1] == $filter
                        || $c[2] == $filter
                        || $c[3] == $filter
                        || $c[4] == $filter
                        || $c[4] == 'x'
                        || $c[5] == $filter
                        || $c[6] == $filter
                        || $c[7] == $filter
                    ) {
                        // Crée une instance de lien.
                        $linkInstance = $this->_nebuleInstance->newLink($link, $linkVersion);
                        // Si le lien est valide ou que l'on permet les liens invalides.
                        if (is_a($linkInstance, 'Link') && ($linkInstance->getValid() || $permitListInvalidLinks)) {
                            $okWriteNew = true;
                            // Si la taille du tableau des résultats n'est pas nulle.
                            if (sizeof($linksResult) != 0) {
                                // On recherche et compare le nouveau lien avec chacun des anciens liens.
                                foreach ($linksResult as $k => $t) {
                                    // Si le nouveau lien est identique.
                                    if ( // $t->getHashSigner() == $c[2]				!!! A VOIR !!!
                                        $t->getAction() == $c[4]
                                        && $t->getHashSource() == $c[5]
                                        && $t->getHashTarget() == $c[6]
                                        && $t->getHashMeta() == $c[7]
                                    ) {
                                        // Si le nouveau lien est plus récent.
                                        if ($t->getHashSigner() == $c[2]
                                            && $this->_nebuleInstance->dateCompare($t->getDate(), $c[3]) <= 0
                                        ) {
                                            // Et si ce n'est pas exactement le même.
                                            if ($t->getDate() != $c[3]) {
                                                // On l'écrit dans le tableau des résultats à la place du lien plus ancien.
                                                $linksResult[$k] = $linkInstance;
                                            }
                                            // Le lien n'a pas besoin d'être écrit.
                                            $okWriteNew = false;
                                        }
                                        // Sinon c'est que le lien est plus ancien.
                                    }
                                }
                            }
                            // Si le lien est nouveau et non marqué supprimé.
                            if ($okWriteNew) {
                                // On écrit le lien dans le tableau des résultats.
                                $linksResult[$i] = $linkInstance;
                                $i++;
                            }
                        }
                    }
                    unset($okWriteNew);
                }
            }
            unset($link, $linkInstance, $c, $e, $j);
        }
        unset($permitListInvalidLinks, $linkVersion, $i, $links);

        // Tri les liens par date.
        if (sizeof($linksResult) != 0) {
            foreach ($linksResult as $n => $t) {
                $linkdate[$n] = $t->getDate_disabled();
            }
            array_multisort($linkdate, SORT_STRING, SORT_ASC, $linksResult);
            unset($linkdate, $n, $t);
        }

        // Supprime les liens marqués supprimés.
        if (sizeof($linksResult) != 0) {
            // Liste tous les liens.
            // Ils sont triés par date.
            foreach ($linksResult as $n1 => $t1) {
                if ($t1->getAction_disabled() != 'x') {
                    // Si ce n'est pas un lien x.
                    foreach ($linksResult as $t2) {
                        if ($t2->getAction_disabled() == 'x'
                            && $t1->getHashSource_disabled() == $t2->getHashSource_disabled()
                            && $t1->getHashTarget_disabled() == $t2->getHashTarget_disabled()
                            && $t1->getHashMeta_disabled() == $t2->getHashMeta_disabled()
                            && $this->_nebuleInstance->dateCompare($t1->getDate_disabled(), $t2->getDate_disabled()) <= 0
                        ) {
                            unset($linksResult[$n1]);
                        }
                    }
                }
            }
            unset($n1, $t1, $t2);
        }

        // Supprime les liens x.
        if (sizeof($linksResult) != 0) {
            // Liste tous les liens.
            foreach ($linksResult as $n => $t) {
                if ($t->getAction_disabled() == 'x') {
                    // Si lien x, le supprime.
                    unset($linksResult[$n]);
                }
            }
            unset($n, $t);
        }

        return $linksResult;
    }


    /** Lit les liens.
     * Retourne un tableau d'objets de type Link ou un tableau vide si ça se passe mal.
     * Un filtre simple est réalisé lors de l'extraction des liens.
     * Les liens marqués supprimés, càd marqués par un autre lien type x à une date égale ou +, sont enlevés.
     * Les liens de type x ne sont pas retournés.
     * Les paramètres doivent correspondre à la valeur des champs correspondants :
     * - signataire
     * - action
     * - date
     * - source
     * - destination
     * - méta
     * Un paramètre vide '' équivaut à toute valeur du champs.
     * Trie les liens par date.
     *
     * @param string $signer
     * @param string $date
     * @param string $action
     * @param string $source
     * @param string $target
     * @param string $meta
     * @return array|Link
     */
    public function readLinksFilterFull($signer = '', $date = '', $action = '', $source = '', $target = '', $meta = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $permitListInvalidLinks = $this->_nebuleInstance->getOption('permitListInvalidLinks');
        $linkVersion = 'nebule/liens/version/' . $this->_nebuleInstance->getOption('defaultLinksVersion'); // Version de lien par défaut.
        $linksResult = array();
        if (!$this->_io->checkLinkPresent($this->_id)) {
            return $linksResult;
        }
        $i = 0;

        // Analyse des champs à ne pas prendre en compte.
        $allSigner = false;
        $allDate = false;
        $allAction = false;
        $allSource = false;
        $allTarget = false;
        $allMeta = false;
        if ($signer == '') {
            $allSigner = true;
        }
        if ($date == '') {
            $allDate = true;
        }
        if ($action == '') {
            $allAction = true;
        }
        if ($source == '') {
            $allSource = true;
        }
        if ($target == '') {
            $allTarget = true;
        }
        if ($meta == '') {
            $allMeta = true;
        }

        // Lit les liens.
        $links = $this->_io->linksRead($this->_id);
        $this->_metrology->addLog('Object links count read ' . $this->_id . ' ' . sizeof($links), Metrology::LOG_LEVEL_DEBUG); // Log

        // Analyse les liens, les filtre et les convertis en tableau d'objets de type lien.
        // Si la liste des liens n'est pas vide.
        if (sizeof($links) != 0) {
            foreach ($links as $link) {
                // Ce traitement sur champs brutes est une optimisation du temps de traitement. Le gain est de 1 à 10.
                // Extrait les champs du lien.
                $j = 1;                        // Indice du champs lu, de 1 à 7.
                $c = array();                    // Table des champs lus.
                $e = strtok(trim($link), '_');    // Lecture du champs.
                while ($e !== false)            // Extrait le lien.
                {
                    $c[$j] = trim($e);
                    if ($j < 8) {
                        $e = strtok('_');
                    } else {
                        $e = false;
                    }
                    $j++;
                }

                if (substr($link, 0, 21) == 'nebule/liens/version/') {
                    // Mémorise la version mais ne valide pas la ligne comme lien.
                    $linkVersion = trim(substr($link, 0, 25));
                } elseif ($j == 8) {
                    // Filtre les liens.
                    if (($allSigner || $c[2] == $signer)
                        && ($allDate || $c[3] == $date)
                        && ($allAction || $c[4] == $action || $c[4] == 'x')
                        && ($allSource || $c[5] == $source)
                        && ($allTarget || $c[6] == $target)
                        && ($allMeta || $c[7] == $meta)
                    ) {
                        // Crée une instance de lien.
                        $linkInstance = $this->_nebuleInstance->newLink($link, $linkVersion);
                        // Si le lien est valide ou que l'on permet les liens invalides.
                        if (is_a($linkInstance, 'Link')
                            && ($linkInstance->getValid() || $permitListInvalidLinks)
                        ) {
                            $okWriteNew = true;
                            // Si la taille du tableau des résultats n'est pas nulle.
                            if (sizeof($linksResult) != 0) {
                                // On recherche et compare le nouveau lien avec chacun des anciens liens.
                                foreach ($linksResult as $k => $t) {
                                    // Si le nouveau lien est identique.
                                    if ($t->getHashSigner() == $c[2]
                                        && $t->getAction() == $c[4]
                                        && $t->getHashSource() == $c[5]
                                        && $t->getHashTarget() == $c[6]
                                        && $t->getHashMeta() == $c[7]
                                    ) {
                                        // Si le nouveau lien est plus récent.
                                        if ($t->getHashSigner() == $c[2]
                                            && $this->_nebuleInstance->dateCompare($t->getDate(), $c[3]) <= 0
                                        ) {
                                            // Et si ce n'est pas exactement le même.
                                            if ($t->getDate() != $c[3]) {
                                                // On l'écrit dans le tableau des résultats à la place du lien plus ancien.
                                                $linksResult[$k] = $linkInstance;
                                            }
                                            // Le lien n'a pas besoin d'être écrit.
                                            $okWriteNew = false;
                                        }
                                        // Sinon c'est que le lien est plus ancien.
                                    }
                                }
                            }
                            // Si le lien est nouveau et non marqué supprimé.
                            if ($okWriteNew) {
                                // On écrit le lien dans le tableau des résultats.
                                $linksResult[$i] = $linkInstance;
                                $i++;
                            }
                        }
                    }
                    unset($okWriteNew);
                }
            }
            unset($link, $linkInstance, $c, $e, $j);
        }
        unset($permitListInvalidLinks, $linkVersion, $i, $links);

        // Tri les liens par date.
        if (sizeof($linksResult) != 0) {
            $linkdate = array();
            foreach ($linksResult as $n => $t) {
                $linkdate[$n] = $t->getDate_disabled();
            }
            array_multisort($linkdate, SORT_STRING, SORT_ASC, $linksResult);
            unset($linkdate, $n, $t);
        }

        // Supprime les liens marqués supprimés.
        if (sizeof($linksResult) != 0) {
            // Liste tous les liens.
            // Ils sont triés par date.
            foreach ($linksResult as $n1 => $t1) {
                if ($t1->getAction_disabled() != 'x') {
                    // Si ce n'est pas un lien x.
                    foreach ($linksResult as $t2) {
                        if ($t2->getAction_disabled() == 'x'
                            && $t1->getHashSource_disabled() == $t2->getHashSource_disabled()
                            && $t1->getHashTarget_disabled() == $t2->getHashTarget_disabled()
                            && $t1->getHashMeta_disabled() == $t2->getHashMeta_disabled()
                            && $this->_nebuleInstance->dateCompare($t1->getDate_disabled(), $t2->getDate_disabled()) <= 0
                        ) {
                            unset($linksResult[$n1]);
                        }
                    }
                }
            }
            unset($n1, $t1, $t2);
        }

        // Supprime les liens x.
        if (sizeof($linksResult) != 0) {
            // Liste tous les liens.
            foreach ($linksResult as $n => $t) {
                if ($t->getAction_disabled() == 'x') {
                    // Si lien x, le supprime.
                    unset($linksResult[$n]);
                }
            }
            unset($n, $t);
        }

        return $linksResult;
    }

    /**
     * Recherche l'identifiant d'un objet final définit comme mise à jour de l'objet courant.
     * Résoud le graphe des mises à jours d'un objet.
     * - $present permet de controler si l'on veut que l'objet final soit bien présent localement.
     * - $synchro permet ou non la synchronisation des liens et objets auprès d'entités tierces, en clair on télécharge ce qui manque au besoin lors du parcours du graphe.
     * Retourne l'ID de l'objet à jour ou l'ID de l'objet de départ si pas de mise à jour.
     * @param boolean $present
     * @param boolean $synchro
     * @todo
     *
     */
    public function findUpdate($present = true, $synchro = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifier si authorisé à rechercher les mises à jours.
        if (!$this->_nebuleInstance->getOption('permitFollowUpdates')) {
            return $this->_id;
        }

        // Si déjà recherché, donne le résultat en cache.
        if ($this->_cacheUpdate != ''
            && !$synchro
        ) {
            return $this->_cacheUpdate;
        }

        $l = array();        // Liste des branches de l'arborescence que l'on a pris.
        $i = 0;            // Indice de position dans l'arborescence.
        $j = 0;            // Indice de position sur les mises à jour un objet.
        $s = '0';            // L'ID de l'objet suivant.
        $co = array();    // Cache des objets de l'arborescence.
        $cl = array();    // Cache des dérivés des objets de l'arborescence.
        $ov = array();    // Table des objets vus.
        $oi = array();    // Table de l'indice de lien utilisé pour les objets vus.
        $ok = false;        // Résultat pour la boucle.
        $id = $this->_id;    // ID de l'objet courant.

        // Faire une boucle...

        // Vérifie si pas déjà traité, anti boucle infinie.
        $this->_usedUpdate[$this->_id] = true;

        // Vérifie si pas dépassé le nombre max à traiter, anti trou noir.
        if (sizeof($this->_usedUpdate) > $this->_nebuleInstance->getOption('maxFollowedUpdates')) {
            return '0';
        }

        // Recherche la mise à jour de l'objet.
        while (!$ok) {
            // Extrait l'objet du cache...
            if (isset($co[$id])) {
                // Extrait l'objet.
                $object = $co[$id];
                // Extrait les dérivés connus.
                $sub = $cl[$id];
            } // ... ou le génère si nouveau.
            else {
                // Génère l'objet.
                $object = $this->_nebuleInstance->newObject($id);
                $co[$id] = $object;
                // Génère la liste de ses dérivés connus.
                $sub = $object->findOneLevelUpdates($present, $synchro);
                $cl[$id] = $sub;
                // Marque l'objet comme vu pour qu'il ne soit pas réutilisé.
                $ov[$id] = true;
            }

            // Calcul le dérivé suivant dans la liste.
            // Prend le plus récent non déjà vu.
            // Si aucun trouvé, retourn l'ID 0.
            $s = '0';
            foreach ($sub as $sid) {
                if (!isset($ov[$sid])) {
                    $s = $sid;
                    break;
                }
            }

            // Si pas de dérivé connu...
            if ($s == '0') {
                // Si objet présent ...
                if ($this->_io->checkObjectPresent($object)) {
                    $ok = true; // On a trouvé l'ID de la dernière mise à jour de l'objet.
                } // ... sinon on remonte d'un niveau.
                else {
                    if ($i == 0) {
                        $ok = true; // OK et retourne implicitement l'ID de l'objet dont on recherchait une mise à jour.
                    } else {
                        $i--;
                        $id = $l[$i]; // Reprend l'ID de la branche du dessus.
                    }
                }
            } else // ... sinon, on continue la recherche sur l'ID dérivé.
            {
                $id = $s;
            }
        }

        // A faire...
        unset($l, $i, $j, $c, $s, $ov, $oi, $ok);
        return $id;
    }

    /**
     * Recherche les identifiants des objets définits comme mises à jour de l'objet courant.
     * Résoud une seule branche du graphe des mises à jours d'un objet.
     * - $present permet de controler si l'on veut que l'objet final soit bien présent localement.
     * - $synchro permet ou non la synchronisation des liens et objets auprès d'entités tierces, en clair on télécharge ce qui manque au besoin lors du parcours du graphe.
     * On extrait les liens u pré-filtrés x et triés pas date.
     * Retourne un tableau des ID des objets, vide si aucun trouvé.
     *
     * @param boolean $present
     * @param boolean $synchro
     * @return array:string
     */
    public function findOneLevelUpdates($present = true, $synchro = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $x = $this->_nebuleInstance->getOption('permitListInvalidLinks');
        $v = 'nebule/liens/version/' . $this->_nebuleInstance->getOption('defaultLinksVersion'); // Version de lien.
        $r = array(); // Tableau des liens de mise à jour.
        $o = array(); // Tableau des objets résultats.
        if (!$this->_io->checkLinkPresent($this->_id)) {
            return $o;
        }
        $i = 0; // Indice de position dans le tableau des liens.

        // Lit les liens.
        $links = $this->_io->linksRead($this->_id);
        $this->_metrology->addLog('Object links count read ' . $this->_id . ' ' . sizeof($links), Metrology::LOG_LEVEL_DEBUG); // Log

        // Analyse les liens, les filtre et les convertis en tableau d'objets de type lien.
        foreach ($links as $link) {
            // Ce traitement sur champs brutes est une optimisation du temps de traitement. Le gain est de 1 à 10.
            // Extrait les champs du lien.
            $j = 1;                        // Indice du champs lu, de 1 à 7.
            $c = array();                    // Table des champs lus.
            $e = strtok(trim($link), '_');    // Lecture du champs.
            while ($e !== false)            // Extrait le lien.
            {
                $c[$j] = trim($e);
                if ($j < 8) {
                    $e = strtok('_');
                } else {
                    $e = false;
                }
                $j++;
            }

            if (substr($link, 0, 21) == 'nebule/liens/version/') {
                $v = trim(substr($link, 0, 25)); // Mémorise la version mais ne valide pas la ligne comme lien.
            } elseif ($j == 8) {
                // Filtre les liens. Ne tient pas compte du champs meta.
                if (($c[4] == 'u'
                        || $c[4] == 'x'
                    )
                    && $c[5] == $this->_id
                    && $c[6] != '0'
                ) {
                    $l = $this->_nebuleInstance->newLink($link, $v);
                    if ($l->getValid() || $x) {
                        $r[$i] = $l;        // on l'écrit dans le tableau des résultats.
                        $i++;
                    }
                }
            }
        }
        unset($links, $link, $j, $c, $e);

        // Tri les liens par date.
        $this->_arrayDateSort($r);

        // Supprime les liens marqués supprimés.
        $s = sizeof($r); // Nombre de liens.
        $links = array(); // Tableau des liens non marqués supprimés.
        foreach ($r as $l) {
            if ($l->getAction_disabled() == 'x') {
                continue;
            }
            $ok = true;
            for ($j = 0; $j < $s; $j++) {
                // Teste si le lien en cours (i) est supprimé par un lien plus récent (j).
                if ($r[$j]->getAction_disabled() == 'x'
                    && $l->getHashSource_disabled() == $r[$j]->getHashSource_disabled()
                    && $l->getHashTarget_disabled() == $r[$j]->getHashTarget_disabled()
                    && $this->_nebuleInstance->dateCompare($l->getDate_disabled(), $r[$j]->getDate_disabled()) <= 0)
                    $ok = false;
            }
            if ($ok) {
                $links[$l->getHashTarget_disabled()] = $l;
                // Ecrase les liens même source même destination à une date antérieure.
            }
        }
        unset($i, $s, $r);

        // Extrait les objets cibles des liens si les objets sont présents.
        if (sizeof($links) == 0) {
            return $o;
        }
        $i = 0;
        if ($present) // Si besoin, teste la présence des objets avant de les ajouter.
        {
            foreach ($links as $l) {
                if ($this->_io->checkObjectPresent($l->getHashTarget_disabled())) {
                    $o[$i] = $l->getHashTarget_disabled();
                    $i++;
                } else {
                    // Tentative de synchronisation.
                    $t = $this->_nebuleInstance->newObject($id);
                    $t->syncLinks();
                    $t->syncObject();
                    if ($this->_io->checkObjectPresent($l->getHashTarget_disabled())) {
                        $o[$i] = $l->getHashTarget_disabled();
                        $i++;
                    }
                }
            }
        } else // Sinon ajoute tous les objets.
        {
            foreach ($links as $l) {
                $o[$i] = $l->getHashTarget_disabled();
                $i++;
            }
        }
        unset($i, $l, $links);

        return $o;
    }

    /**
     * Extrait l'identifiant de l'objet (un seul) définit comme mise à jour de l'objet courant.
     * Dérivé de la fonction précédente findOneLevelUpdates().
     *
     * @param boolean $present
     * @param boolean $synchro
     * @return string
     */
    public function findOneLevelUpdate($present = true, $synchro = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait les mises à jours.
        $objects = $this->findOneLevelUpdates($present, $synchro);

        // Vérifie si il y a des réponses.
        if (sizeof($objects) == 0) {
            return '0';
        }

        // Extrait le dernier objet.
        $object = end($objects);
        unset($objects);

        // Test la présence de l'objet.
        if ($this->_io->checkObjectPresent($object)) {
            return $object;
        }
        return '0';
    }


    /**
     * Liste les liens des objets par référence, référencés par l'objet instancié.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     *
     * @param string $reference
     * @return array:string
     */
    private function _getReferencedByLinks($reference = '')
    {
        // Si pas de référence, utilise la référence par défaut.
        if ($reference == '') {
            $reference = nebule::REFERENCE_NEBULE_REFERENCE;
        }

        // Converti au besoin en hash.
        if (!ctype_xdigit($reference)) {
            $reference = $this->_crypto->hash($reference);
        }

        // Liste les liens à la recherche de la propriété.
        $list = $this->readLinksFilterFull(
            '',
            '',
            'f',
            $this->_id,
            '',
            $reference
        );

        return $list;
    }

    /**
     * Liste les liens des objets par référence, les objets qui référencent l'objet instancié.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     *
     * @param string $reference
     * @return array:string
     */
    private function _getReferenceToLinks($reference = '')
    {
        // Si pas de référence, utilise la référence par défaut.
        if ($reference == '') {
            $reference = nebule::REFERENCE_NEBULE_REFERENCE;
        }

        // Converti au besoin en hash.
        if (!ctype_xdigit($reference)) {
            $reference = $this->_crypto->hash($reference);
        }

        // Liste les liens à la recherche de la propriété.
        $list = $this->readLinksFilterFull(
            '',
            '',
            'f',
            '',
            $this->_id,
            $reference
        );

        return $list;
    }

    /**
     * Cherche l'ID de l'objet par référence.
     * Si pas trouvé, retourne l'ID de l'objet sur lequel s'effectue la recherche.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     *
     * @param string $reference
     * @param string $socialClass
     * @return string
     */
    public function getReferencedObjectID($reference = '', $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste les liens à la recherche de la propriété.
        $links = $this->_getReferencedByLinks($reference);

        if (sizeof($links) == 0) {
            return $this->_id;
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Extrait le dernier de la liste.
        $link = end($links);
        unset($links);

        if (!is_a($link, 'link')) {
            return $this->_id;
        }

        return $link->getHashTarget();
    }

    /**
     * Cherche l'ID du signataire de l'objet par référence.
     * Si pas trouvé, retourne 0.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     *
     * @param string $reference
     * @param string $socialClass
     * @return string
     */
    public function getReferencedSignerID($reference = '', $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste les liens à la recherche de la propriété.
        $links = $this->_getReferencedByLinks($reference);

        if (sizeof($links) == 0) {
            return '0';
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        /**
         * Extrait le dernier de la liste.
         *
         * @var Link
         */
        $link = end($links);
        unset($links);

        if (!is_a($link, 'link')) {
            return '0';
        }

        return $link->getHashSigner();
    }

    /**
     * Cherche la liste des ID des signataires de l'objet par référence.
     * Si pas trouvé, retourne 0.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     *
     * @param string $reference
     * @param string $socialClass
     * @return array:string
     */
    public function getReferencedListSignersID($reference = '', $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $list = array();

        // Liste les liens à la recherche de la propriété.
        $links = $this->_getReferencedByLinks($reference);

        if (sizeof($links) == 0) {
            return $list;
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Extrait les signataires de la liste.
        $listOK = array();
        foreach ($links as $link) {
            if (!isset($listOK[$link->getHashSigner()])) {
                $list[] = $link->getHashSigner();
                $listOK[$link->getHashSigner()] = true;
            }
        }
        unset($links, $listOK);

        return $list;
    }

    /**
     * Cherche l'instance de l'objet par référence.
     * Si pas trouvé, retourne l'instance de l'objet sur lequel s'effectue la recherche.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     *
     * @param string $reference
     * @param string $socialClass
     * @return Node
     */
    public function getReferencedObjectInstance($reference, $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_nebuleInstance->convertIdToTypedObjectInstance($this->getReferencedObjectID($reference, $socialClass));
    }

    /**
     * Cherche si l'objet est une référence.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     * Les références sont converties en hash en hexadécimal.
     * Si la référence est un texte en hexadécimal, c'est à dire un ID d'objet, alors c'est utilisé directement.
     *
     * @param string $reference
     * @param string $socialClass
     * @return boolean
     */
    public function getIsReferencedBy($reference = '', $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste les liens à la recherche de la propriété.
        $links = $this->_getReferencedByLinks($reference);

        if (sizeof($links) == 0) {
            return false;
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        if (sizeof($links) == 0) {
            return false;
        }
        return true;
    }

    /**
     * Cherche si l'objet est référencé par une autre objet.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     * Les références sont converties en hash en hexadécimal.
     * Si la référence est un texte en hexadécimal, c'est à dire un ID d'objet, alors c'est utilisé directement.
     *
     * @param string $reference
     * @param string $socialClass
     * @return boolean
     */
    public function getIsReferenceTo($reference = '', $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste les liens à la recherche de la propriété.
        $links = $this->_getReferenceToLinks($reference);

        if (sizeof($links) == 0) {
            return false;
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        if (sizeof($links) == 0) {
            return false;
        }
        return true;
    }

    /**
     * Cherche l'ID de l'objet qui référence l'objet courant.
     * Si pas trouvé, retourne l'ID de l'objet sur lequel s'effectue la recherche.
     *
     * Si le type de référence $reference n'est pas précisée, utilise nebule::REFERENCE_NEBULE_REFERENCE.
     *
     * @param string $reference
     * @param string $socialClass
     * @return string
     */
    public function getReferenceToObjectID($reference = '', $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste les liens à la recherche de la propriété.
        $links = $this->_getReferenceToLinks($reference);

        if (sizeof($links) == 0) {
            return $this->_id;
        }

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Extrait le dernier de la liste.
        $link = end($links);
        unset($links);

        if (!is_a($link, 'link')) {
            return $this->_id;
        }

        return $link->getHashSource();
    }


    /**
     * Synchronisation de l'objet.
     * @param boolean $hardSync
     * @return boolean
     * @todo
     *
     */
    public function syncObject($hardSync = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($hardSync !== true) {
            $hardSync = false;
        }

        // Vérifie que l'objet ne soit pas déjà présent.
        if ($this->_io->checkObjectPresent($this->_id)) {
            return true;
        }

        // Vérifie si autorisé.
        if (!$this->_nebuleInstance->getOption('permitWriteObject')) {
            return false;
        }
        if (!$this->_nebuleInstance->getOption('permitSynchronizeObject')) {
            return false;
        }

        // Liste les liens à la recherche de la propriété de localisation.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            '',
            '',
            $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_ENTITE_LOCALISATION));

        // Fait une recherche sur d'autres types de hash si celui par défaut ne renvoie rien.
        if (sizeof($links) == 0
            && $this->_nebuleInstance->getOption('permitListOtherHash')
        ) {
            // A faire...
        }
        if (sizeof($links) == 0) {
            return false;
        }

        // Fait un tri par pertinance sociale.
        // A faire...

        // Extrait le contenu des objets de propriété.
        foreach ($links as $i => $l) {
            $localisations[$i] = $this->_readOneLineOtherObject($l->getHashTarget());
        }

        // Synchronisation
        foreach ($localisations as $localisation) {
            // Lecture de l'objet.
            $data = $this->_io->objectRead($this->_id, 0, $localisation);
            // Ecriture de l'objet.
            $this->_io->objectWrite($data);
        }

        unset($localisations, $localisation);
        return true;
    }

    /**
     * Synchronisation des liens de l'objet.
     * @param boolean $hardSync
     * @return boolean
     * @todo
     *
     */
    public function syncLinks($hardSync = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($hardSync !== true) {
            $hardSync = false;
        }

        // Vérifie si autorisé.
        if (!$this->_nebuleInstance->getOption('permitWriteLink')) {
            return false;
        }
        if (!$this->_nebuleInstance->getOption('permitSynchronizeLink')) {
            return false;
        }

        // Liste les liens à la recherche de la propriété de localisation.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            '',
            '',
            $this->_crypto->hash('nebule/objet/entite/localisation'));

        // Fait une recherche sur d'autres types de hash si celui par défaut ne renvoie rien.
        if (sizeof($links) == 0
            && $this->_nebuleInstance->getOption('permitListOtherHash')
        ) {
            // A faire...
        }
        if (sizeof($links) == 0) {
            return false;
        }

        // Fait un tri par pertinance sociale.
        // A faire...

        // Extrait le contenu des objets de propriété.
        foreach ($links as $i => $l) {
            $localisations[$i] = $this->_readOneLineOtherObject($l->getHashTarget());
        }

        // Synchronisation
        $link = null;
        $linkInstance = null;
        foreach ($localisations as $localisation) {
            $links = $this->_io->linksRead($this->_id, $localisation);
            $this->_metrology->addLog('Object links count read ' . $this->_id . ' ' . sizeof($links), Metrology::LOG_LEVEL_DEBUG); // Log

            foreach ($links as $link) {
                $linkInstance = $this->_nebuleInstance->newLink($link);
                $linkInstance->write();
            }
        }

        unset($localisations, $localisation, $links, $link, $linkInstance);
        return true;
    }

    /**
     * Supprime l'objet si plus aucune entité ne l'utilise.
     * Le lien de suppression est créé même si l'objet n'est pas supprimé.
     *
     * @return boolean
     */
    public function deleteObject()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $deleteObject = true;

        // Détecte si l'objet est protégé.
        $this->_getMarkProtected();
        $protected = ($this->_markProtectedChecked && $this->_cacheMarkProtected);
        if ($protected) {
            $id = $this->_idUnprotected;
        } else {
            $id = $this->_id;
        }

        // Création lien.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $source = $id;
        $link = '0_' . $signer . '_' . $date . '_d_' . $source . '_0_0';
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->signWrite();

        // Lit les liens.
        $links = $this->readLinksUnfiltred();
        $entity = $this->_nebuleInstance->getCurrentEntity();
        foreach ($links as $link) {
            // Vérifie si l'entité signataire du lien est l'entité courante.
            if ($link->getHashSigner() != $entity) {
                // Si ce n'est pas l'entité courante, quitte.
                $this->_metrology->addAction('delobj', $id, false);
                $deleteObject = false;
            }
        }

        if ($deleteObject) {
            // Supprime l'objet.
            $r1 = $this->_io->objectDelete($id);
            $r2 = true;

            // Métrologie.
            $this->_metrology->addAction('delobj', $id, $r);
        }

        // Si protégé.
        if ($protected) {
            $this->_metrology->addLog('Delete protected object ' . $this->_id, Metrology::LOG_LEVEL_NORMAL); // Log
            $id = $this->_idProtected;

            // Création lien.
            $signer = $this->_nebuleInstance->getCurrentEntity();
            $date = date(DATE_ATOM);
            $source = $id;
            $link = '0_' . $signer . '_' . $date . '_d_' . $source . '_0_0';
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->signWrite();

            // Lit les liens.
            $links = $this->readLinksUnfiltred();
            $entity = $this->_nebuleInstance->getCurrentEntity();
            foreach ($links as $link) {
                // Vérifie si l'entité signataire du lien est l'entité courante.
                if ($link->getHashSigner() != $entity) {
                    // Si ce n'est pas l'entité courante, quitte.
                    $this->_metrology->addAction('delobj', $id, false);
                    $deleteObject = false;
                }
            }

            if ($deleteObject) {
                // Supprime l'objet.
                $r2 = $this->_io->objectDelete($id);

                // Métrologie.
                $this->_metrology->addAction('delobj', $id, $r);
            }
        }
        unset($links, $entity, $link, $deleteObject);

        return ($r1 && $r2);
    }

    /**
     * Supprime un objet et ses liens.
     *
     * @return boolean
     * @todo faire une suppression de ses propres liens uniquement.
     *
     */
    public function deleteObjectLinks()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Création lien.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $source = $this->_id;
        $link = '0_' . $signer . '_' . $date . '_d_' . $source . '_0_0';
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->signWrite();

        // Lit les liens.
        $links = $this->readLinksUnfiltred();
        $entity = $this->_nebuleInstance->getCurrentEntity();
        foreach ($links as $link) {
            // Vérifie si l'entité signataire du lien est l'entité courante.
            if ($link->getHashSigner() != $entity) {
                // Si ce n'est pas l'entité courante, quitte.
                unset($links, $entity, $link);
                return false;
            }
        }

        unset($links, $entity, $link);

        // Supprime l'objet.
        $r = $this->_io->objectDelete($this->_id);

        // Métrologie.
        $this->_metrology->addAction('delobj', $this->_id, $r);

        // Supprime les liens de l'objet.
        $this->_io->linksDelect($this->_id);

        return $r;
    }

    /**
     * Supprime un objet.
     * Force l'opération si l'entité est autorisée à le faire.
     *
     * @return boolean
     */
    public function deleteForceObject()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Création lien.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $source = $this->_id;
        $link = '0_' . $signer . '_' . $date . '_d_' . $source . '_0_0';
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->signWrite();

        // Supprime l'objet.
        $r = $this->_io->objectDelete($this->_id);

        // Métrologie.
        $this->_metrology->addAction('delobj', $this->_id, $r);

        return $r;
    }

    /**
     * Supprime un objet et ses liens.
     * Force l'opération si l'entité est autorisée à le faire.
     */
    public function deleteForceObjectLinks()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Supprime l'objet.
        $this->_io->objectDelete($this->_id);

        // Supprime les liens de l'objet.
        $this->_io->linksDelete($this->_id);
    }

    /**
     * Trie un tableau de liens en fonction des dates des liens.
     *
     * @param array $list
     * @return boolean
     */
    protected function _arrayDateSort(&$list)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if (sizeof($list) == 0) {
            return false;
        }
        foreach ($list as $n => $t) {
            $linkdate[$n] = $t->getDate();
        }
        array_multisort($linkdate, SORT_STRING, SORT_DESC, $list);
        unset($n, $t, $linkdate);
        return true;
    }


    /**
     * Ecrit l'objet si non présent.
     *
     * @return boolean
     */
    public function write()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si protégé.
        if ($this->_cacheMarkProtected) {
            $this->_metrology->addAction('addobj', $this->_id, false);
            $this->_metrology->addLog('Write objet error, protected.', Metrology::LOG_LEVEL_ERROR);
            return false;
        }

        // Si pas de données.
        if (!$this->_haveData) {
            $this->_metrology->addAction('addobj', '0', false);
            $this->_metrology->addLog('Write objet error, no data.', Metrology::LOG_LEVEL_ERROR);
            return false;
        }

        if (!$this->_io->checkObjectPresent($this->_id)) {
            // Si autorisé à écrire un nouvel objet.
            if ($this->_nebuleInstance->getOption('permitWriteObject')
                && $this->_nebuleInstance->getOption('permitCreateObject')
            ) {
                $id = $this->_io->objectWrite($this->_data);
            } else {
                $id = false;
            }
        } else {
            $id = $this->_id;
        }

        // vide les données.
        $this->_data = '';
        $this->_haveData = false;

        // Métrologie.
        $v = true;
        if ($id === false
            || $id != $this->_id
        ) {
            $v = false;
            // Si l'écriture échoue, on crée l'objet d'ID '0'. @todo à revoir si vraiment utile... pareil pour entities->write().
            $this->_id = '0';
        }
        $this->_metrology->addAction('addobj', $this->_id, $v);
        $this->_metrology->addLog('OK write objet ' . $this->_id, Metrology::LOG_LEVEL_DEBUG);

        return $v;
    }


    /**
     * Affiche la partie menu de la documentation.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#o">O / Objet</a>
            <ul>
                <li><a href="#oo">OO / Objet</a>
                    <ul>
                        <li><a href="#oon">OON / Nommage</a></li>
                        <li><a href="#oop">OOP / Protection</a></li>
                        <li><a href="#ood">OOD / Dissimulation</a></li>
                        <li><a href="#ool">OOL / Liens</a></li>
                        <li><a href="#ooc">OOC / Création</a></li>
                        <li><a href="#oos">OOS / Stockage</a>
                            <ul>
                                <li><a href="#oosa">OOSA / Arborescence</a></li>
                            </ul>
                        </li>
                        <li><a href="#oot">OOT / Transfert</a></li>
                        <li><a href="#oor">OOR / Réservation</a></li>
                        <li><a href="#ooio">OOIO / Implémentation des Options</a></li>
                        <li><a href="#ooia">OOIA / Implémentation des Actions</a></li>
                        <li><a href="#oov">OOV / Vérification</a></li>
                        <li><a href="#ooo">OOO / Oubli</a></li>
                    </ul>
                </li>

                <?php Entity::echoDocumentationTitles(); ?>

                <li><a href="#or">OR / Référence</a>
                    <ul>
                        <li><a href="#orn">ORN / Nommage</a></li>
                        <li><a href="#orp">ORP / Protection</a></li>
                        <li><a href="#ord">ORD / Dissimulation</a></li>
                        <li><a href="#orl">ORL / Liens</a></li>
                        <li><a href="#orc">ORC / Création</a></li>
                        <li><a href="#ors">ORS / Stockage</a></li>
                        <li><a href="#ort">ORT / Transfert</a></li>
                        <li><a href="#orr">ORR / Réservation</a></li>
                        <li><a href="#orio">ORIO / Implémentation des Options</a></li>
                        <li><a href="#oria">ORIA / Implémentation des Actions</a></li>
                        <li><a href="#oro">ORO / Oubli</a></li>
                    </ul>
                </li>
                <?php Group::echoDocumentationTitles(); ?>

                <?php Conversation::echoDocumentationTitles(); ?>

                <?php Localisation::echoDocumentationTitles(); ?>

                <?php Applications::echoDocumentationTitles(); /* Inclu les modules. */ ?>

                <?php Currency::echoDocumentationTitles(); /* Inclu les sacs et jetons. */ ?>

            </ul>
        </li>
        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h1 id="o">O / Objet</h1>
        <p>L'objet est le contenant de toutes les informations.</p>

        <h2 id="oo">OO / Objet</h2>
        <p>L’objet est un agglomérat de données numériques.</p>
        <p>Un objet numérique est identifié par une empreinte ou condensat (hash) numérique de type cryptographique.
            Cette empreinte est à même d'empêcher la modification du contenu d'un objet, intentionnellement ou non (cf
            <a href="#co">CO</a>).</p>

        <h3 id="oon">OON / Nommage</h3>
        <p>Le nommage à l’affichage du nom des objets repose sur plusieurs propriétés :</p>
        <ol>
            <li>nom</li>
            <li>prénom</li>
            <li>surnom</li>
            <li>préfixe</li>
            <li>suffixe</li>
        </ol>
        <p>Ces propriétés sont matérialisées par des liens de type <code>l</code> avec comme objets méta, respectivement
            :</p>
        <ol>
            <li><code>nebule/objet/nom</code></li>
            <li><code>nebule/objet/prenom</code></li>
            <li><code>nebule/objet/surnom</code></li>
            <li><code>nebule/objet/prefix</code></li>
            <li><code>nebule/objet/suffix</code></li>
        </ol>
        <p>Par convention, voici le nommage des objets pour l’affichage :</p>
        <p class="pcenter"><code>prénom préfixe/nom.suffixe surnom</code></p>

        <h3 id="oop">OOP / Protection</h3>
        <p>La protection d'un objet va permettre de cacher le contenu de l'objet.</p>
        <p>A faire...</p>

        <h3 id="ood">OOD / Dissimulation</h3>
        <p>La dissimulation des liens d'un objet va permettre de cacher la présence ou l'usage d'un objet.</p>
        <p>A faire...</p>

        <h3 id="ool">OOL / Liens</h3>
        <p>A faire...</p>

        <h3 id="ooc">OOC / Création</h3>
        <p>L’objet est identifié par un ID égal à la valeur de son empreinte.</p>
        <p>L’indication de la fonction de prise d’empreinte (hashage) est impératif. Elle est défini par le lien :</p>
        <ul>
            <li>Signature du lien</li>
            <li>Identifiant du signataire</li>
            <li>Horodatage</li>
            <li>action : <code>l</code></li>
            <li>source : ID de l’objet</li>
            <li>cible : hash du nom de l’algorithme de prise d’empreinte</li>
            <li>méta : hash(‘nebule/objet/hash’)</li>
        </ul>
        <p>Le lien de définition du type est optionnel. Le type est généralement le type mime reconnu de l’objet.</p>
        <ul>
            <li>Signature du lien</li>
            <li>Identifiant du signataire</li>
            <li>Horodatage</li>
            <li>action : <code>l</code></li>
            <li>source : ID de l'objet</li>
            <li>cible : hash(type de l'objet)</li>
            <li>méta : hash(‘nebule/objet/type’)</li>
        </ul>
        <p>A faire...</p>

        <h3 id="oos">OOS / Stockage</h3>
        <p>Tous les contenus des objets sont stockés dans un même emplacement ou sont visible comme étant dans un même
            emplacement. Cet emplacement ne contient pas les liens (cf <a href="#ls">LS</a>).</p>
        <p>A faire...</p>

        <h3 id="oosa">OOSA / Arborescence</h3>
        <p>Sur un système de fichiers, tous les contenus des objets sont stockés dans des fichiers contenus dans le
            dossier <code>pub/o/</code> (<code>o</code> comme objet).</p>
        <p>A faire...</p>

        <h3 id="oot">OOT / Transfert</h3>
        <p>A faire...</p>

        <h3 id="oor">OOR / Réservation</h3>
        <p>Les différentes objets réservés pour les besoins de la bibliothèque nebule :</p>
        <ul>
            <?php
            $list = nebule::$RESERVED_OBJECTS_LIST;
            foreach ($list as $item) {
                echo "\t<li><code>$item</code></li>\n";
            }
            unset($list, $item);
            ?>
        </ul>

        <p>Les objets réservés périmés :</p>
        <ul>
            <li>nebule/objet/entite/web</li>
            <li>nebule/objet/entite/web/applications</li>
        </ul>

        <h4 id="ooio">OOIO / Implémentation des Options</h4>
        <p>A faire...</p>

        <h4 id="ooia">OOIA / Implémentation des Actions</h4>
        <p>A faire...</p>

        <h3 id="oov">OOV / Vérification</h3>
        <p>L’empreinte d’un objet doit être vérifiée lors de la fin de la réception de l’objet. L’empreinte d’un objet
            devrait être vérifiée avant chaque utilisation de cet objet. Un contenu d'objet avec une empreinte qui ne
            lui correspond pas doit être supprimé. Lors de la suppression d’un objet, les liens de cet objet ne sont pas
            supprimés. La vérification de la validité des liens est complètement indépendante de celle des objets, et
            inversement (cf <a href="#co">CO</a> et <a href="#lv">LV</a>).</p>

        <h3 id="ooo">OOO / Oubli</h3>
        <p>L'oubli vonlontaire de certains liens et objets n'est encore ni théorisé ni implémenté mais deviendra
            indispensable lorsque l'espace viendra à manquer (cf <a href="#cn">CN</a>).</p>

        <?php Entity::echoDocumentationCore(); ?>

        <h2 id="or">OR / Référence</h2>
        <p>A faire...</p>

        <h3 id="orn">ORN / Nommage</h3>
        <p>A faire...</p>

        <h3 id="orp">ORP / Protection</h3>
        <p>A faire...</p>

        <h3 id="ord">ORD / Dissimulation</h3>
        <p>A faire...</p>

        <h3 id="orl">ORL / Liens</h3>
        <p>A faire...</p>

        <h3 id="orc">ORC / Création</h3>
        <p>Liste des liens à générer lors de la création d'une entité.</p>
        <p>A faire...</p>

        <h3 id="ors">ORS / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="ort">ORT/ Transfert</h3>
        <p>A faire...</p>

        <h3 id="orr">ORR / Réservation</h3>
        <p>A faire...</p>

        <h4 id="orio">ORIO / Implémentation des Options</h4>
        <p>A faire...</p>

        <h4 id="oria">ORIA / Implémentation des Actions</h4>
        <p>A faire...</p>

        <h3 id="oro">ORO / Oubli</h3>
        <p>L'oubli vonlontaire de certains liens et objets n'est encore ni théorisé ni implémenté mais deviendra
            indispensable lorsque l'espace viendra à manquer (cf <a href="#cn">CN</a>).</p>

        <?php Group::echoDocumentationCore(); ?>

        <?php Conversation::echoDocumentationCore(); ?>

        <?php Localisation::echoDocumentationCore(); ?>

        <?php Applications::echoDocumentationCore(); /* Inclu les modules. */ ?>

        <?php Currency::echoDocumentationCore(); /* Inclu les sacs et jetons. */ ?>

        <?php
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Group.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID d'un groupe ou 'new' ;
 *
 * L'ID d'un groupe est forcément un texte en hexadécimal.
 *
 * Si une erreur survient lors de la lecture du groupe ou lors de la création, assigne l'ID 0.
 *
 * Tout objet peut devenir un groupe sans avoir été préalablement marqué comme groupe.
 * Le simple faire de faire un lien pour désigner un objet comme membre du groupe d'un autre objet
 *   suffit à créer le groupe.
 * ------------------------------------------------------------------------------------------
 */
class Group extends Node
{
    // Suffixe d'identifiant de nouveaux groupes.
    const DEFAULT_SUFFIX_NEW_GROUP = '006e6562756c652f6f626a65742f67726f757065';

    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_id',
        '_fullname',
        '_cacheProperty',
        '_cacheProperties',
        '_cacheMarkProtected',
        '_idProtected',
        '_idUnprotected',
        '_idProtectedKey',
        '_idUnprotectedKey',
        '_markProtectedChecked',
        '_cacheCurrentEntityUnlocked',
        '_usedUpdate',
        '_isGroup',
        '_isConversation',
        '_isMarkClosed',
        '_isMarkProtected',
        '_isMarkObfuscated',
        '_referenceObject',
        '_referenceObjectClosed',
        '_referenceObjectProtected',
        '_referenceObjectObfuscated',
    );

    /**
     * Constructeur.
     *
     * Toujours transmettre l'instance de la librairie nebule.
     * Si le groupe existe, juste préciser l'ID de celle-ci.
     * Si c'est un nouveau groupe à créer, mettre l'ID à 'new'.
     *
     * @param nebule $nebuleInstance
     * @param string $id
     * @param boolean $closed
     */
    public function __construct(nebule $nebuleInstance, $id, $closed = false, $obfuscated = false)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();

        $id = trim(strtolower($id));
        $this->_metrology->addLog('New instance group ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.

        if (is_string($id) && $id != '' && ctype_xdigit($id)) {
            // Si l'ID est cohérent et l'objet nebule présent, c'est bon.
            $this->_loadGroup($id);
        } elseif (is_string($id) && $id == 'new') {
            // Si c'est un nouveau groupe à créer, renvoie à la création.
            $this->_createNewGroup($closed, $obfuscated);
        } else {
            // Sinon, le groupe est invalide, retourne 0.
            $this->_id = '0';
        }

        // Pré-calcul les références.
        $this->getReferenceObject();
        $this->getReferenceObjectClosed();
        $this->getReferenceObjectProtected();
        $this->getReferenceObjectObfuscated();
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->_id;
    }

    /**
     * Retourne les variables à sauvegarder dans la session php lors d'une mise en sommeil de l'instance.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return self::SESSION_SAVED_VARS;
    }

    /**
     * Foncion de réveil de l'instance et de ré-initialisation de certaines variables non sauvegardées.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();
        $this->_cacheMarkDanger = false;
        $this->_cacheMarkWarning = false;
        $this->_cacheUpdate = '';
    }

    /**
     * Chargement d'un groupe existant.
     *
     * @param string $id
     */
    private function _loadGroup($id)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que c'est bien un objet.
        if (!is_string($id)) {
            $id = '0';
        } elseif ($id == '') {
            $id = '0';
        } elseif (!ctype_xdigit($id)) {
            $id = '0';
        } elseif (!$this->_io->checkLinkPresent($id)) {
            $id = '0';
        }

        $this->_id = $id;
        $this->_metrology->addLog('Load group ' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
        $this->getIsGroup();
    }

    /**
     * Création d'un nouveau groupe.
     *
     * @param boolean $closed
     */
    protected function _createNewGroup($closed, $obfuscated)
    {
        $this->_metrology->addLog(__METHOD__, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que l'on puisse créer un groupe et tous ses attributs.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitCreateObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCreateLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            // calcul l'ID.
            $this->_id = $this->_nebuleInstance->getCrypto()->hash($this->_nebuleInstance->getCrypto()->getPseudoRandom(128)) . self::DEFAULT_SUFFIX_NEW_GROUP;

            // Log
            $this->_metrology->addLog('Create group ' . $this->_id, Metrology::LOG_LEVEL_DEBUG);

            // Mémorise les données.
            $this->_data = null;
            $this->_haveData = false;

            $signer = $this->_nebuleInstance->getCurrentEntity();
            $date = date(DATE_ATOM);
            $hashGroup = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE);

            // Création lien de hash.
            $date2 = $date;
            if ($obfuscated) {
                $date2 = '0';
            }
            $action = 'l';
            $source = $this->_id;
            $target = $this->_crypto->hash($this->_crypto->hashAlgorithmName());
            $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_HASH);
            $link = '0_' . $signer . '_' . $date2 . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->signWrite();

            // Création lien de groupe.
            $action = 'l';
            $source = $this->_id;
            $target = $hashGroup;
            $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
            $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
            $newLink = new Link($this->_nebuleInstance, $link);
            $newLink->sign();
            if ($obfuscated) {
                $newLink->obfuscate();
            }
            $newLink->write();

            if ($closed) {
                // Création lien de groupe fermé.
                $action = 'l';
                $source = $this->_id;
                $target = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_FERME, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
                $meta = $hashGroup;
                $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $newLink = new Link($this->_nebuleInstance, $link);
                $newLink->sign();
                if ($obfuscated) {
                    $newLink->obfuscate();
                }
                $newLink->write();

                $this->_isMarkClosed = true;
            } else {
                $this->_isMarkClosed = false;
            }

            // Ecrit l'objet du groupe.
            $this->write();
            $this->_isGroup = true;
        } else {
            $this->_metrology->addLog('Create group error no autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_id = '0';
            return false;
        }
    }

    /**
     * Extrait l'ID de l'entité.
     * Filtre l'entité et s'assure que c'est une entité.
     *
     * @param string|Node|entity $entity
     * @return string
     */
    protected function _checkExtractEntityID($entity)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $entityInstance = null;
        if (is_string($entity)) {
            if ($entity == ''
                || $entity == '0'
                || !ctype_xdigit($entity)
                || !$this->_io->checkLinkPresent($entity)
            ) {
                $id = '';
            } else {
                $id = $entity;
                $entityInstance = $this->_nebuleInstance->newEntity($id);
            }
        } elseif (is_a($entity, 'Node')) {
            $id = $entity->getID();
            if ($id == '0') {
                $id = '';
            } else {
                $entityInstance = $entity;
            }
        } else {
            $id = '';
        }

        if ($id == '0') {
            $id = '';
        }

        if ($id != ''
            && !$entityInstance->getIsEntity('all')
        ) {
            $id = '';
        }
        unset($entityInstance);

        return $id;
    }

    /**
     * Filtre l'objet.
     *
     * @param string|Node $object
     * @return string
     */
    private function _checkExtractObjectID($object)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if (is_string($object)) {
            if ($object == ''
                || $object == '0'
                || !ctype_xdigit($object)
                || !$this->_io->checkLinkPresent($object)
            ) {
                $id = '';
            } else {
                $id = $object;
            }
        } elseif (is_a($object, 'Node')) {
            $id = $object->getID();
            if ($id == '0') {
                $id = '';
            }
        } else {
            $id = '';
        }

        if ($id == '0') {
            $id = '';
        }

        return $id;
    }



    // Désactivation des fonctions de protection et autres.

    /**
     * Vérifie la consistance de l'objet.
     *
     * Retourne toujours true pour une conversation.
     * Il n'y a pas de contenu à vérifier pour un objet de référence.
     *
     * @return boolean
     */
    public function checkConsistency()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return true;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function getReloadMarkProtected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return string
     */
    public function getProtectedID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return '0';
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return string
     */
    public function getUnprotectedID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_id;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function setProtected($obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function setUnprotected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function setProtectedTo($entity)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return array
     */
    public function getProtectedTo()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return array();
    }


    /**
     * Ecrit l'objet comme n'étant plus un groupe.
     * @todo détecter le lien dissimulé d'origine, et dissimuler en conséquence.
     *
     * @return boolean
     */
    public function unsetGroup()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si déjà marqué, donne le résultat tout de suite.
        if (!$this->_isGroup) {
            return true;
        }

        // Création lien de suppression de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'x';
        $source = $this->_id;
        $target = $this->getReferenceObject();
        $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE);
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->signWrite();

        $this->_isGroup = false;
        return true;
    }


    /**
     * Variable si l'objet est marqué comme un groupe fermé.
     * @var boolean
     */
    protected $_isMarkClosed = false;

    /**
     * Retourne si le groupe est marqué comme fermé.
     * En sélectionnant une entité, fait la recherche de marquage pour cette entité comme contributrice.
     *
     * @param string|Node|entity $entity
     * @return boolean
     */
    public function getMarkClosed($entity = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Liste tous mes liens de définition de groupe fermé.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->_id,
            $id,
            $this->getReferenceObjectClosed()
        );

        // Fait un tri par pertinance sociale. Forcé à myself.
        $this->_social->arraySocialFilter($links, 'myself');

        // Mémorise le r&sultat.
        if ($id == $this->_nebuleInstance->getCurrentEntity()) {
            if (sizeof($links) != 0) {
                $this->_isMarkClosed = true;
            } else {
                $this->_isMarkClosed = false;
            }
        }

        // Retourne le résultat.
        if (sizeof($links) != 0) {
            return true;
        }

        return false;
    }

    /**
     * Ecrit l'objet comme un groupe fermé.
     *
     * @param string|Node|entity $entity
     * @param boolean $obfuscated
     * @return boolean
     */
    public function setMarkClosed($entity = '', $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->getMarkClosed()) {
            return true;
        }

        // Création du lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $this->_id;
        $target = $id;
        $meta = $this->getReferenceObjectClosed();
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        if ($newLink->write()) {
            if ($id == $this->_nebuleInstance->getCurrentEntity()) {
                $this->_isMarkClosed = true;
            }
            return true;
        }
        return false;
    }

    /**
     * Ecrit l'objet comme n'étant pas un groupe fermé.
     * @todo détecter le lien dissimulé d'origine, et dissimuler en conséquence.
     *
     * @param string|Node|entity $entity
     * @return boolean
     */
    public function unsetMarkClosed($entity = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Si déjà marqué, donne le résultat tout de suite.
        if (!$this->getMarkClosed()) {
            return true;
        }

        // Création lien de suppression de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'x';
        $source = $this->_id;
        $target = $id;
        $meta = $this->getReferenceObjectClosed();
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);

        if ($newLink->signWrite()) {
            if ($id == $this->_nebuleInstance->getCurrentEntity()) {
                $this->_isMarkClosed = false;
            }
            return true;
        }
        return false;
    }


    /**
     * Variable si l'objet est marqué comme un groupe protégé.
     * @var boolean
     */
    protected $_isMarkProtected = false;

    /**
     * Retourne si le groupe est marqué comme protégé.
     * En sélectionnant une entité, fait la recherche de marquage pour cette entité comme contributrice.
     *
     * @param string|Node|entity $entity
     * @return boolean
     */
    public function getMarkProtected($entity = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Liste tous mes liens de définition de groupe protégé.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->_id,
            $id,
            $this->getReferenceObjectProtected()
        );

        // Fait un tri par pertinance sociale. Forcé à myself.
        $this->_social->arraySocialFilter($links, 'myself');

        // Mémorise le r&sultat.
        if ($id == $this->_nebuleInstance->getCurrentEntity()) {
            if (sizeof($links) != 0) {
                $this->_isMarkProtected = true;
            } else {
                $this->_isMarkProtected = false;
            }
        }

        // Retourne le résultat.
        if (sizeof($links) != 0) {
            return true;
        }

        return false;
    }

    /**
     * Ecrit l'objet comme un groupe protégé.
     *
     * @param string|Node|entity $entity
     * @param boolean $obfuscated
     * @return boolean
     */
    public function setMarkProtected($entity = '', $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->getMarkProtected()) {
            return true;
        }

        // Création du lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $this->_id;
        $target = $id;
        $meta = $this->getReferenceObjectProtected();
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        if ($newLink->write()) {
            if ($id == $this->_nebuleInstance->getCurrentEntity()) {
                $this->_isMarkProtected = true;
            }
            return true;
        }
        return false;
    }

    /**
     * Ecrit l'objet comme n'étant pas un groupe protégé.
     * @todo détecter le lien dissimulé d'origine, et dissimuler en conséquence.
     *
     * @param string|Node|entity $entity
     * @return boolean
     */
    public function unsetMarkProtected($entity = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Si déjà marqué, donne le résultat tout de suite.
        if (!$this->getMarkProtected()) {
            return true;
        }

        // Création lien de suppression de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'x';
        $source = $this->_id;
        $target = $id;
        $meta = $this->getReferenceObjectProtected();
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);

        if ($newLink->signWrite()) {
            if ($id == $this->_nebuleInstance->getCurrentEntity()) {
                $this->_isMarkProtected = false;
            }
            return true;
        }
        return false;
    }


    /**
     * Variable si l'objet est marqué comme un groupe dissimulé.
     * @var boolean
     */
    protected $_isMarkObfuscated = false;

    /**
     * Retourne si le groupe est marqué comme dissimulé.
     * En sélectionnant une entité, fait la recherche de marquage pour cette entité comme contributrice.
     *
     * @param string|Node|entity $entity
     * @return boolean
     */
    public function getMarkObfuscated($entity = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Désactivée si option à false.
        if (!$this->_nebuleInstance->getOption('permitObfuscatedLink')) {
            return false;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Liste tous mes liens de définition de groupe dissimulé.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->_id,
            $id,
            $this->getReferenceObjectObfuscated()
        );

        // Fait un tri par pertinance sociale. Forcé à myself.
        $this->_social->arraySocialFilter($links, 'myself');

        // Mémorise le r&sultat.
        if ($id == $this->_nebuleInstance->getCurrentEntity()) {
            if (sizeof($links) != 0) {
                $this->_isMarkObfuscated = true;
            } else {
                $this->_isMarkObfuscated = false;
            }
        }

        // Retourne le résultat.
        if (sizeof($links) != 0) {
            return true;
        }

        return false;
    }

    /**
     * Ecrit l'objet comme un groupe dissimulé.
     *
     * @param string|Node|entity $entity
     * @param boolean $obfuscated
     * @return boolean
     */
    public function setMarkObfuscated($entity = '', $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Désactivée si option à false.
        if (!$this->_nebuleInstance->getOption('permitObfuscatedLink')) {
            return false;
        }

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Si déjà marqué, donne le résultat tout de suite.
        if ($this->getMarkObfuscated()) {
            return true;
        }

        // Création du lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $this->_id;
        $target = $id;
        $meta = $this->getReferenceObjectObfuscated();
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        if ($newLink->write()) {
            if ($id == $this->_nebuleInstance->getCurrentEntity()) {
                $this->_isMarkObfuscated = true;
            }
            return true;
        }
        return false;
    }

    /**
     * Ecrit l'objet comme n'étant pas un groupe dissimulé.
     * @todo détecter le lien dissimulé d'origine, et dissimuler en conséquence.
     *
     * @param string|Node|entity $entity
     * @return boolean
     */
    public function unsetMarkObfuscated($entity = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Désactivée si option à false.
        if (!$this->_nebuleInstance->getOption('permitObfuscatedLink')) {
            return false;
        }

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        if ($id == '') {
            $id = $this->_nebuleInstance->getCurrentEntity();
        }

        // Si déjà marqué, donne le résultat tout de suite.
        if (!$this->getMarkObfuscated()) {
            return true;
        }

        // Création lien de suppression de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'x';
        $source = $this->_id;
        $target = $id;
        $meta = $this->getReferenceObjectObfuscated();
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);

        if ($newLink->signWrite()) {
            if ($id == $this->_nebuleInstance->getCurrentEntity()) {
                $this->_isMarkObfuscated = false;
            }
            return true;
        }
        return false;
    }


    /**
     * Retourne si l'objet est membre du groupe.
     *
     * @param string|Node $object
     * @param string $socialClass
     * @return boolean
     */
    public function getIsMember($object, $socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait l'ID de l'objet.
        $id = $this->_checkExtractObjectID($object);

        // Vérifie que c'est bien un objet.
        if ($id == '') {
            return false;
        }

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->_id,
            $id,
            $this->_id
        );

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        if (sizeof($links) != 0) {
            return true;
        }
        return false;
    }

    /**
     * Ajoute un objet comme membre dans le groupe.
     *
     * @param string|Node $object
     * @param boolean $obfuscated
     * @return boolean
     */
    public function setMember($object, $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'objet.
        $id = $this->_checkExtractObjectID($object);

        // Vérifie que c'est bien un objet.
        if ($id == '') {
            return false;
        }

        // Création lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $this->_id;
        $target = $id;
        $meta = $this->_id;
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        return $newLink->write();
    }

    /**
     * Retire un membre du groupe.
     * @todo détecter le lien dissimulé d'origine, et dissimuler en conséquence.
     *
     * @todo retirer la dissimulation déjà faite dans le code.
     *
     * @param string|Node $object
     * @param boolean $obfuscated
     * @return boolean
     */
    public function unsetMember($object = '', $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'objet.
        $id = $this->_checkExtractObjectID($object);

        // Vérifie que c'est bien un objet.
        if ($id == '') {
            return false;
        }

        // Création lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'x';
        $source = $this->_id;
        $target = $id;
        $meta = $this->_id;
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        return $newLink->write();
    }


    /**
     * Extrait la liste des liens définissant les objets du groupe.
     *
     * Le calcul sociale se fait par rapport à la classe sociale demandée,
     *   et donc utilise l'entité de _nebuleInstance ou de _applicationInstance en fonction.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:Link
     */
    public function getListMembersLinks($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste tous les liens des membres de la conversation.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->_id,
            '',
            $this->_id
        );

        // Fait un tri par pertinance sociale.
        $this->_social->setList($socialListID);
        $this->_social->arraySocialFilter($links, $socialClass);
        $this->_social->unsetList();

        return $links;
    }

    /**
     * Extrait la liste des ID des objets du groupe.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:string
     */
    public function getListMembersID($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait les liens des groupes.
        $links = $this->getListMembersLinks($socialClass, $socialListID);

        // Extraction des ID cibles.
        $list = array();
        foreach ($links as $link) {
            $list[$link->getHashTarget()] = $link->getHashTarget();
        }

        return $list;
    }

    /**
     * Retourne le nombre d'objets dans le groupe.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return float
     */
    public function getCountMembers($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return sizeof($this->getListMembersLinks($socialClass, $socialListID));
    }


    /**
     * Retourne si l'entité est à l'écoute du groupe.
     *
     * @param string|Node $entity
     * @param string $socialClass
     * @param array:string $socialListID
     * @return boolean
     */
    public function getIsFollower($entity, $socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        // Vérifie que c'est bien une entité.
        if ($id == '') {
            return false;
        }

        // Liste tous les liens de définition des entités à l'écoutes du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $id,
            $this->_id,
            $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI)
        );

        // Fait un tri par pertinance sociale.
        $this->_social->setList($socialListID);
        $this->_social->arraySocialFilter($links, $socialClass);
        $this->_social->unsetList();

        if (sizeof($links) != 0) {
            return true;
        }
        return false;
    }

    /**
     * Ajoute une entité comme à l'écoute du groupe.
     *
     * @param string|Node $entity
     * @param boolean $obfuscated
     * @return boolean
     */
    public function setFollower($entity, $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        // Vérifie que c'est bien une entité.
        if ($id == '') {
            return false;
        }

        // Création lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $id;
        $target = $this->_id;
        $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI);
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        return $newLink->write();
    }

    /**
     * Retire un entité à l'écoute du groupe.
     * @todo détecter le lien dissimulé d'origine, et dissimuler en conséquence.
     *
     * @todo retirer la dissimulation déjà faite dans le code.
     *
     * @param string|Node $entity
     * @param boolean $obfuscated
     * @return boolean
     */
    public function unsetFollower($entity = '', $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteGroup')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        // Vérifie que c'est bien une entité.
        if ($id == '') {
            return false;
        }

        // Création lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'x';
        $source = $id;
        $target = $this->_id;
        $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI);
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        return $newLink->write();
    }


    /**
     * Extrait la liste des liens définissant les entités à l'écoute du groupe.
     *
     * On ne peut pas voir un groupe comme fermé si on regarde pour une autre entité.
     * La pertinence sociale n'est pas utilisée pour un groupe fermé.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:Link
     */
    public function getListFollowersLinks($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_getListFollowersLinks($this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI), $socialClass, $socialListID);
    }

    /**
     * Extrait la liste des liens définissant les entités à l'écoute d'un objet et définit par une référence de suivi.
     * L'objet définit par une référence de suivi doit se comporter comme un groupe.
     *
     * @param string $reference
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:Link
     */
    protected function _getListFollowersLinks($reference, $socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie la référence.
        if (!is_string($reference)
            && !ctype_xdigit($reference)
        ) {
            $reference = $this->_crypto->hash($reference);
        }

        // Liste tous les liens des entités à l'écoutes du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            '',
            $this->_id,
            $reference
        );

        // Fait un tri par pertinance sociale.
        $this->_social->setList($socialListID);
        $this->_social->arraySocialFilter($links, $socialClass);
        $this->_social->unsetList();

        return $links;
    }

    /**
     * Extrait la liste des ID des entités à l'écoute du groupe.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:string
     */
    public function getListFollowersID($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait les liens des groupes.
        $links = $this->_getListFollowersLinks($this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI), $socialClass, $socialListID);

        // Extraction des ID cibles.
        $list = array();
        foreach ($links as $link) {
            $list[$link->getHashSource()] = $link->getHashSource();
        }

        return $list;
    }

    /**
     * Retourne le nombre d'entités à l'écoute du groupe.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return float
     */
    public function getCountFollowers($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return sizeof($this->_getListFollowersLinks($this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI), $socialClass, $socialListID));
    }

    /**
     * Retourne la liste des entités qui ont ajouté l'entité cité comme suiveuse du groupe.
     *
     * @param string $entity
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:string
     */
    public function getListFollowerAddedByID($entity, $socialClass = 'all', $socialListID = null)
    {
        // Extrait les liens des groupes.
        $links = $this->_getListFollowersLinks($this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI), $socialClass, $socialListID);

        // Extraction des ID cibles.
        $list = array();
        foreach ($links as $link) {
            if ($link->getHashSource() == $entity) {
                $list[$link->getHashSigner()] = $link->getHashSigner();
            }
        }

        return $list;
    }


    /**
     * ID de référence de l'objet.
     *
     * @var string
     */
    private $_referenceObject = '';

    /**
     * Calcule et retourne la référence de l'objet.
     *
     * @return string
     */
    public function getReferenceObject()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_referenceObject == '') {
            $this->_referenceObject = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }
        return $this->_referenceObject;
    }

    /**
     * ID de référence de l'objet de fermeture.
     *
     * @var string
     */
    private $_referenceObjectClosed = '';

    /**
     * Calcule et retourne la référence de l'objet de fermeture.
     *
     * @return string
     */
    public function getReferenceObjectClosed()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_referenceObjectClosed == '') {
            $this->_referenceObjectClosed = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_FERME, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }
        return $this->_referenceObjectClosed;
    }

    /**
     * ID de référence de l'objet de protection des membres.
     *
     * @var string
     */
    private $_referenceObjectProtected = '';

    /**
     * Calcule et retourne la référence de l'objet de protection des membres.
     *
     * @return string
     */
    public function getReferenceObjectProtected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_referenceObjectProtected == '') {
            $this->_referenceObjectProtected = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_PROTEGE, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }
        return $this->_referenceObjectProtected;
    }

    /**
     * ID de référence de l'objet de dissimulation des membres.
     *
     * @var string
     */
    private $_referenceObjectObfuscated = '';

    /**
     * Calcule et retourne la référence de l'objet de dissimulation des membres.
     *
     * @return string
     */
    public function getReferenceObjectObfuscated()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_referenceObjectObfuscated == '') {
            $this->_referenceObjectObfuscated = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_DISSIMULE, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }
        return $this->_referenceObjectObfuscated;
    }


    /**
     * Affiche la partie menu de la documentation.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#og">OG / Groupe</a>
            <ul>
                <li><a href="#ogo">OGO / Objet</a></li>
                <li><a href="#ogn">OGN / Nommage</a></li>
                <li><a href="#ogp">OGP / Protection</a></li>
                <li><a href="#ogd">OGD / Dissimulation</a></li>
                <li><a href="#ogf">OGF / Fermeture</a></li>
                <li><a href="#ogpm">OGPM / Protection des membres</a></li>
                <li><a href="#ogdm">OGDM / Dissimulation des membres</a></li>
                <li><a href="#ogl">OGL / Liens</a></li>
                <li><a href="#ogc">OGC / Création</a></li>
                <li><a href="#ogs">OGS / Stockage</a></li>
                <li><a href="#ogt">OGT / Transfert</a></li>
                <li><a href="#ogr">OGR / Réservation</a></li>
                <li><a href="#ogio">OGIO / Implémentation des Options</a></li>
                <li><a href="#ogia">OGIA / Implémentation des Actions</a></li>
            </ul>
        </li>

        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h2 id="og">OG / Groupe</h2>
        <p>Le groupe est un objet définit comme tel, c’est à dire qu’il doit avoir un type mime <code>nebule/objet/groupe</code>.
        </p>
        <p>Fondamentalement, le groupe est un ensemble de plusieurs objets. C’est à dire, c’est le regroupement d’au
            moins deux objets. Le lien peut donc à ce titre être vu comme la matérialisation d’un groupe. Mais la
            définition du groupe doit être plus restrictive afin que celui-ci soit utilisable. Pour cela, dans <em>nebule</em>,
            le groupe n’est reconnu comme tel uniquement si il est marqué de son type mime. Il est cependant possible
            d’instancier explicitement un objet comme groupe et de l’utiliser comme tel en cas de besoin.</p>
        <p>Le groupe va permettre de regrouper, et donc d’associer et de retrouver, des objets. L’objet du groupe va
            avoir des liens vers d’autres objets afin de les définir comme membres du groupe.</p>
        <p>Un groupe peut avoir des liens de membres vers des objets définis aussi comme groupes. Ces objets peuvent
            être vus comme des sous-groupes. La bibliothèque <em>nebule</em> ne prend en compte qu’un seul niveau de
            groupe, c’est à dire que les sous-groupes sont gérés simplement comme des objets.</p>

        <h3 id="ogo">OGO / Objet</h3>
        <p>L’objet du groupe peut être de deux natures.</p>
        <p>Soit c’est un objet existant qui est en plus définit comme un groupe. L’objet peut avoir un contenu et a
            sûrement d’autres types mime propres. Dans ce cas l’identifiant de groupe est l’identifiant de l’objet
            utilisé.</p>
        <p>Soit c’est un objet dit virtuel qui n’a pas et n’aura jamais de contenu. Cela n’empêche pas qu’il puisse
            avoir d’autres types mime. Dans ce cas l’identifiant de groupe a une forme commune aux objets virtuels.</p>
        <p>La création d’un objet virtuel comme groupe se fait en créant pour identifiant la concaténation d’un hash
            (<em>sha256</em>) d’une valeur aléatoire de 128bits et de la chaîne <code>006e6562756c652f6f626a65742f67726f757065</code>.
            Soit un identifiant complet de la taille de 104 caractères.</p>

        <h3 id="ogn">OGN / Nommage</h3>
        <p>Le nommage à l’affichage du nom des groupes repose sur une seule propriété :</p>
        <ol>
            <li>nom</li>
        </ol>
        <p>Cette propriété est matérialisée par un lien de type <code>l</code> avec comme objets méta :</p>
        <ol>
            <li><code>nebule/objet/nom</code></li>
        </ol>
        <p>Par convention, voici le nommage des groupes :</p>
        <ul>
            <li><code>nom</code></li>
        </ul>

        <h3 id="ogp">OGP / Protection</h3>
        <p>En tant que tel le groupe ne nécessite pas de protection puisque soit l’objet du groupe n’a pas de contenu
            soit on n’utilise pas son contenu directement.</p>
        <p>La gestion de la protection est désactivée dans une instance de groupe.</p>

        <h3 id="ogd">OGD / Dissimulation</h3>
        <p>Le groupe peut en tant que tel être dissimulé, c’est à dire que l’on dissimule l’existence du groupe, donc sa
            création.</p>
        <p>La dissimulation devrait se faire lors de la création du groupe.</p>
        <p>L’annulation de la dissimulation d’un groupe revient à révéler le lien de création du groupe.</p>
        <p>La dissimulation peut se (re)faire après la création du groupe mais son efficacité est incertaine si les
            liens de création ont déjà été diffusés. En cas de dissimulation à posteriori, il faut générer un lien de
            suppression du groupe puis générer un nouveau lien dissimulé de création du groupe à une date postérieure au
            lien de suppression.</p>

        <h3 id="ogf">OGF / Fermeture</h3>
        <p>Le groupe va contenir un certain nombre de membres ajouter par différentes entités. Il est possible de
            limiter le nombre des membres à utiliser dans un groupe en restreignant artificiellement les entités
            contributrices du groupe. Ainsi on marque le groupe comme fermé et on filtre sur les membres uniquement
            ajoutés par des entités définies.</p>
        <p>Dans nebule, l’objet réservé <code>nebule/objet/groupe/ferme</code> est dédié à la gestion des groupes
            fermés. Un groupe est considéré fermé quand on a l’objet réservé en champs méta, l’entité en cours en champs
            cible et l’ID du groupe en champs source. Si au lieu d’utiliser l’entité en cours pour le champs cible on
            utilise une autre entité, cela revient à prendre aussi en compte ses liens dans le groupe fermé. Dans ce cas
            c’est une entité contributrice.</p>
        <p>C’est uniquement un affichage du groupe que l’on a et non la suppression de membres du groupe.</p>
        <p>Lorsque l’on a marqué un groupe comme fermé, on doit explicitement ajouter des entités que l’on veut voir
            contribuer.</p>
        <p>Il est possible indéfiniment de fermer et ouvrir un groupe.</p>
        <p>Il est possible de fermer un groupe qui ne nous appartient pas afin par exemple de le rendre plus
            lisible.</p>
        <p>Lorsque l’on a marqué un groupe comme fermé, on peut voir la liste des entités explicitement que l’on veut
            voir contribuer. On peut aussi voir les entités que les autres entités veulent voir contribuer et décider ou
            non de les ajouter.</p>
        <p>Lorsqu’un groupe est marqué comme fermé, l’interface de visualisation du groupe peut permettre de le
            visualiser temporairement comme un groupe ouvert.</p>
        <p>Le traitement des liens de fermeture d’un groupe doit être fait exclusivement avec le traitement social <em>self</em>.
        </p>

        <h4 id="ogpm">OGPM / Protection des membres</h4>
        <p>Le groupe va contenir un certain nombre de membres ajouter par différentes entités. Il est possible de
            limiter la visibilité du contenu des membres utilisés dans un groupe en restreignant artificiellement les
            entités destinataires qui pourront les consulter.</p>
        <p>Dans nebule, l’objet réservé <code>nebule/objet/groupe/protege</code> est dédié à la gestion des groupes
            protégés. Un groupe est considéré protégé quand on a l’objet réservé en champs méta, l’entité en cours en
            champs cible et l’ID du groupe en champs source. Si au lieu d’utiliser l’entité en cours pour le champs
            cible on utilise une autre entité, cela revient à partager aussi les objets protégés créés pour ce groupe.
            Cela ne repartage pas la protection des objets déjà protégés.</p>
        <p>Dans un groupe marqué protégé, tous les nouveaux membres ajoutés au groupe ont leur contenu protégé. Ce n’est
            valable que pour l’entité en cours et éventuellement celles qui lui font confiance.</p>
        <p>Lorsque l’on a marqué un groupe comme protégé, on doit explicitement ajouter des entités avec qui on veut
            partager les contenus.</p>
        <p>Il est possible indéfiniment de protéger et déprotéger un groupe.</p>
        <p>Il est possible de protéger un groupe qui ne nous appartient afin de masquer le contenu des membres que l’on
            y ajoute.</p>
        <p>Lorsque l’on a marqué un groupe comme protégé, on peut voir la liste des entités explicitement a qui on veut
            partager les contenus. On peut aussi voir les entités a qui les autres entités veulent partager les contenus
            et décider ou non de les ajouter.</p>
        <p>Le traitement des liens de protection d’un groupe doit être fait exclusivement avec le traitement social <em>self</em>.
        </p>

        <h4 id="ogdm">OGDM / Dissimulation des membres</h4>
        <p>Le groupe va contenir un certain nombre de membres ajouter par différentes entités. Il est possible de
            limiter la visibilité de l’appartenance des membres utilisés dans un groupe en restreignant artificiellement
            les entités destinataires qui pourront les voir.</p>
        <p>Dans nebule, l’objet réservé <code>nebule/objet/groupe/dissimule</code> est dédié à la gestion des groupes
            dissimulés. Un groupe est considéré dissimulé quand on a l’objet réservé en champs méta, l’entité en cours
            en champs cible et l’ID du groupe en champs source. Si au lieu d’utiliser l’entité en cours pour le champs
            cible on utilise une autre entité, cela revient à partager aussi les objets dissimulés créés pour ce groupe.
            Cela ne repartage pas la dissimulation des objets déjà dissimulés.</p>
        <p>Dans un groupe marqué dissimulé, tous les nouveaux membres ajoutés au groupe sont dissimulés. Ce n’est
            valable que pour l’entité en cours et éventuellement celles qui lui font confiance.</p>
        <p>Lorsque l’on a marqué un groupe comme dissimulé, on doit explicitement ajouter des entités avec qui on veut
            partager les membres du groupe.</p>
        <p>Il est possible indéfiniment de dissimuler et dé-dissimuler un groupe.</p>
        <p>Il est possible de dissimuler un groupe qui ne nous appartient afin de masquer le contenu des membres que
            l’on y ajoute.</p>
        <p>Lorsque l’on a marqué un groupe comme dissimulé, on peut voir la liste des entités explicitement a qui on
            veut partager les contenus. On peut aussi voir les entités a qui les autres entités veulent partager les
            contenus et décider ou non de les ajouter.</p>
        <p>Le traitement des liens de dissimulation d’un groupe doit être fait exclusivement avec le traitement social
            <em>self</em>.</p>

        <h3 id="ogl">OGL / Liens</h3>
        <p>Une entité doit être déverrouillée pour la création de liens.</p>
        <ul>
            <li>Le lien de définition du groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : hash(‘nebule/objet/groupe’)</li>
                    <li>méta : hash(‘nebule/objet/type’)</li>
                </ul>
            </li>
            <li>Le lien de suppression d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : hash(‘nebule/objet/groupe’)</li>
                    <li>méta : hash(‘nebule/objet/type’)</li>
                </ul>
            </li>
            <li>Le lien de suivi du groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de l'entité, par défaut l’entité signataire</li>
                    <li>cible : ID du groupe</li>
                    <li>méta : hash(‘nebule/objet/groupe/suivi’)</li>
                </ul>
            </li>
            <li>Le lien de suppression de suivi du groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID de l'entité, par défaut l’entité signataire</li>
                    <li>cible : ID du groupe</li>
                    <li>méta : hash(‘nebule/objet/groupe/suivi’)</li>
                </ul>
            </li>
            <li>Le lien de dissimulation d’un groupe est le lien de définition caché dans une lien de type
                <code>c</code>.
            </li>
            <li>Le lien de rattachement d’un membre du groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’objet</li>
                    <li>méta : ID du groupe</li>
                </ul>
            </li>
            <li>Le lien de suppression de rattachement d’un membre du groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’objet</li>
                    <li>méta : ID du groupe</li>
                </ul>
            </li>
            <li>Le lien de fermeture d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/ferme’)</li>
                </ul>
            </li>
            <li>Le lien de suppression de fermeture d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/ferme’)</li>
                </ul>
            </li>
            <li>Le lien de protection des membres d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/protege’)</li>
                </ul>
            </li>
            <li>Le lien de suppression de protection des membres d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/protege’)</li>
                </ul>
            </li>
            <li>Le lien de dissimulation des membres d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/dissimule’)</li>
                </ul>
            </li>
            <li>Le lien de suppression de dissimulation des membres d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/dissimule’)</li>
                </ul>
            </li>
        </ul>

        <h3 id="ogc">OGC / Création</h3>
        <p>Liste des liens à générer lors de la création d'un groupe :</p>
        <ul>
            <li>Le lien de définition du groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : hash(‘nebule/objet/groupe’)</li>
                    <li>méta : hash(‘nebule/objet/type’)</li>
                </ul>
            </li>
            <li>Le lien de nommage du groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : hash(nom du groupe)</li>
                    <li>méta : hash(‘nebule/objet/nom’)</li>
                </ul>
            </li>
            <li>Le lien de suivi du groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de l'entité, par défaut l’entité signataire</li>
                    <li>cible : ID du groupe</li>
                    <li>méta : hash(‘nebule/objet/groupe/suivi’)</li>
                </ul>
            </li>
        </ul>
        <p>On peut aussi au besoin ajouter ces liens :</p>
        <ul>
            <li>Le lien de fermeture d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/ferme’)</li>
                </ul>
            </li>
            <li>Le lien de protection des membres d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/protege’)</li>
                </ul>
            </li>
            <li>Le lien de dissimulation des membres d’un groupe :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID du groupe</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/groupe/dissimule’)</li>
                </ul>
            </li>
        </ul>

        <h3 id="ogs">OGS / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="ogt">OGT / Transfert</h3>
        <p>A faire...</p>

        <h3 id="ogr">OGR / Réservation</h3>
        <p>Les objets réservés spécifiquement pour les groupes :</p>
        <ul>
            <li>nebule/objet/groupe</li>
            <li>nebule/objet/groupe/ferme</li>
            <li>nebule/objet/groupe/protege</li>
            <li>nebule/objet/groupe/dissimule</li>
        </ul>

        <h4 id="ogio">OGIO / Implémentation des Options</h4>
        <p>Les options spécifiques aux groupes :</p>
        <ul>
            <li><code>permitWriteGroup</code> : permet toute écriture de groupes.</li>
        </ul>
        <p>Les options qui ont une influence sur les groupes :</p>
        <ul>
            <li><code>permitWrite</code> : permet toute écriture d’objets et de liens ;</li>
            <li><code>permitWriteObject</code> : permet toute écriture d’objets ;</li>
            <li><code>permitCreateObject</code> : permet la création locale d’objets ;</li>
            <li><code>permitWriteLink</code> : permet toute écriture de liens ;</li>
            <li><code>permitCreateLink</code> : permet la création locale de liens.</li>
        </ul>
        <p>Il est nécessaire à la création d’un groupe de pouvoir écrire des objets comme le nom du groupe, même si
            l’objet du groupe ne sera pas créé.</p>

        <h4 id="ogia">OGIA / Implémentation des Actions</h4>
        <p>Dans les actions, on retrouve les chaînes :</p>
        <ul>
            <li><code>creagrp</code> : Crée un groupe.</li>
            <li><code>creagrpnam</code> : Nomme le groupe à créer.</li>
            <li><code>creagrpcld</code> : Marque fermé le groupe à créer.</li>
            <li><code>creagrpobf</code> : Dissimule les liens du groupe à créer.</li>
            <li><code>actdelgrp</code> : Supprime un groupe.</li>
            <li><code>actaddtogrp</code> : Ajoute l’objet courant membre à groupe.</li>
            <li><code>actremtogrp</code> : Retire l’objet courant membre d’un groupe.</li>
            <li><code>actadditogrp</code> : Ajoute un objet membre au groupe courant.</li>
            <li><code>actremitogrp</code> : Retire un objet membre du groupe courant.</li>
        </ul>

        <?php
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Entity.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID d'une entité ou 'new' ;
 *
 * L'ID d'une entité est forcément un texte en hexadécimal.
 *
 * Si une erreur survient lors de la lecture de l'entité ou lors de la création, assigne l'ID 0.
 * ------------------------------------------------------------------------------------------
 */
class Entity extends Node
{
    const ENTITY_MAX_SIZE = 16000;
    const ENTITY_PASSWORD_SALT_SIZE = 128;
    const ENTITY_TYPE = 'application/x-pem-file';
    const ENTITY_PUBLIC_HEADER = '-----BEGIN PUBLIC KEY-----';
    const ENTITY_PRIVATE_HEADER = '-----BEGIN ENCRYPTED PRIVATE KEY-----';

    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_id',
        '_fullname',
        '_cacheProperty',
        '_cacheProperties',
        '_cacheMarkProtected',
        '_idProtected',
        '_idUnprotected',
        '_idProtectedKey',
        '_idUnprotectedKey',
        '_markProtectedChecked',
        '_code',
        '_haveCode',
        '_usedUpdate',
        '_publicKey',
        '_privateKeyID',
        '_privateKey',
        '_newPrivateKey',
        '_privateKeyPassword',
        '_privateKeyPasswordSalt',
        '_issetPrivateKeyPassword',
        '_faceCache',
    );

    private $_publicKey = '',
        $_privateKeyID = '0', $_privateKey = '', $_newPrivateKey = false,
        $_privateKeyPassword = '', $_privateKeyPasswordSalt = '', $_issetPrivateKeyPassword = false,
        $_faceCache = array();

    /**
     * Constructeur.
     *
     * Toujours transmettre l'instance de la librairie nebule.
     * Si l'entité existe, juste préciser l'ID de celle-ci.
     * Si c'est une nouvelle entité à créer, mettre l'ID à 'new'.
     *
     * @param nebule $nebuleInstance
     * @param string $id
     */
    public function __construct(nebule $nebuleInstance, $id)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();

        $id = trim(strtolower($id));
        $this->_metrology->addLog('New instance entity ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.

        if (is_string($id)
            && $id != '' && ctype_xdigit($id)
        ) {
            $this->_loadEntity($id);        // Si l'ID est cohérent et l'objet nebule présent, c'est bon.
        } elseif (is_string($id) && $id == 'new') {
            $this->_createNewEntity();        // Si c'est une nouvelle entité à créer, renvoie à la création.
        } else {
            $this->_id = '0';                // Sinon, l'entité est invalide, retourne 0.
        }
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->_id;
    }

    /**
     * Retourne les variables à sauvegarder dans la session php lors d'une mise en sommeil de l'instance.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return self::SESSION_SAVED_VARS;
    }

    /**
     * Foncion de réveil de l'instance et de ré-initialisation de certaines variables non sauvegardées.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();
        $this->_cacheMarkDanger = false;
        $this->_cacheMarkWarning = false;
        $this->_cacheUpdate = '';
    }

    // Chargement d'une entité existante.
    private function _loadEntity($id)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que c'est bien un objet.
        if (!is_string($id)) {
            $id = '0';
        } elseif ($id == '') {
            $id = '0';
        } elseif (!ctype_xdigit($id)) {
            $id = '0';
        } elseif (!$this->_io->checkObjectPresent($id)) {
            $id = '0';
        } elseif (!$this->_io->checkLinkPresent($id)) {
            $id = '0';
        }
        $this->_id = $id;
        $this->_metrology->addLog('Load entity ' . $id, Metrology::LOG_LEVEL_NORMAL); // Log
        if ($id == '0') {
            return false;
        }
        // Trouve la clé publique.
        $this->_findPublicKey();
    }

    /**
     * Création d'une nouvelle entité.
     * La création est légèrement différente de la création d'un objet parce que les liens de l'entité ne peuvent pas encore être vérifiés.
     * Une entité par nature ne peut pas être dissimulée.
     *
     * @return boolean
     */
    private function _createNewEntity()
    {
        $this->_metrology->addLog(__METHOD__, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que l'on puisse créer une entité.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteEntity')
            && ($this->_nebuleInstance->getCurrentEntityUnlocked()
                || $this->_nebuleInstance->getOption('permitPublicCreateEntity')
            )
        ) {
            $this->_metrology->addLog('Create entity ' . $this->_crypto->asymetricAlgorithmName(), Metrology::LOG_LEVEL_NORMAL); // Log

            // Génère un bi-clé cryptographique.
            $newPkey = $this->_crypto->newPkey();
            if ($newPkey !== false) {
                // Extraction des infos.
                $this->_publicKey = $this->_crypto->getPkeyPublic($newPkey);
                $this->_id = $this->_crypto->hash($this->_publicKey);
                $this->_metrology->addLog('Generated entity ' . $this->_id, Metrology::LOG_LEVEL_NORMAL); // Log
                $this->_privateKeyPassword = $this->_crypto->getStrongRandom(32);
                $this->_privateKeyPasswordSalt = '';
                $this->_privateKey = $this->_crypto->getPkeyPrivate($newPkey, $this->_privateKeyPassword);
                $this->_privateKeyID = $this->_crypto->hash($this->_privateKey);
                $this->_issetPrivateKeyPassword = true;
                $this->_newPrivateKey = true;

                // Ecriture de la clé publique.
                $this->write();
                // La clé privée n'est pas écrite. Son mot de passe doit être changé avant son écriture.

                // Définition de la date.
                $date = date(DATE_ATOM);

                // Création lien 1.
                $action = 'l';
                $source = $this->_id;
                $target = $this->_crypto->hash($this->_crypto->hashAlgorithmName());
                $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_HASH);
                $link = '_' . $this->_id . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $this->_createNewEntityWriteLink($link, $source, $target, $meta);

                // Création lien 2.
                $action = 'l';
                $source = $this->_id;
                $target = $this->_crypto->hash(self::ENTITY_TYPE);
                $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE);
                $link = '_' . $this->_id . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $this->_createNewEntityWriteLink($link, $source, $target, $meta);

                unset($date, $action, $source, $target, $meta, $link);

                // A faire : effacement sécurisé...
                unset($newPkey);
            } else {
                $this->_metrology->addLog('Create entity error on generation', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_id = '0';
                return false;
            }
        } else {
            $this->_metrology->addLog('Create entity error no autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_id = '0';
            return false;
        }
    }

    // Ecrit le lien pour les objets concernés.
    // Utilisé pour la création d'une nouvelle entité, càd dont la clé publique n'est pas encore reconnue.
    private function _createNewEntityWriteLink($link, $source, $target, $meta)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Signe le lien.
        $signe = $this->signLink($link);
        if ($signe === false) {
            return false;
        }
        $signedLink = $signe . '.' . $this->_crypto->hashAlgorithmName() . $link;

        // Ecrit le lien pour l'objet de l'entité signataire.
        if ($this->_nebuleInstance->getOption('NEBULE_DEFAULT_PERMIT_ADD_LINK_TO_SIGNER')) {
            $this->_io->linkWrite($this->_id, $signedLink);
        }

        // Ecrit le lien pour l'objet source.
        $this->_io->linkWrite($source, $signedLink);

        // Ecrit le lien pour l'objet cible.
        $this->_io->linkWrite($target, $signedLink);

        // Ecrit le lien pour l'objet méta.
        $this->_io->linkWrite($meta, $signedLink);

        unset($signe, $signedLink);
        return true;
    }


    /**
     * Vérifier que c'est en hexa, et que c'est une entité.
     * @return boolean
     */
    private function _verifyEntity()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $t = false;
        // Extrait le contenu de l'objet source.
        $objHead = $this->readOneLineAsText(Entity::ENTITY_MAX_SIZE);
        // Vérifie si le contenu contient un entête de clé privée
        if ((strstr($objHead, self::ENTITY_PRIVATE_HEADER)) !== false) {
            $t = true;
        }
        // Vérifie si le contenu contient un entête de clé publique
        if ((strstr($objHead, self::ENTITY_PUBLIC_HEADER)) !== false) {
            $t = true;
        }
        unset($objHead);

        // Faire une vérif plus complète...

        $this->_typeVerified = $t;
        return $t;
    }

    private $_typeVerified = false;

    public function getKeyType()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return '';
        }
        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_ENTITE_TYPE, 'all');
    }

    public function getTypeVerify()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $this->_verifyEntity();
        return $this->_typeVerified;
    }

    public function getIsPublicKey()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $t = false;
        // Extrait le contenu de l'objet source.
        $objHead = $this->readOneLineAsText(Entity::ENTITY_MAX_SIZE);
        // Vérifie si le contenu contient un entête de clé public
        if ((strstr($objHead, self::ENTITY_PUBLIC_HEADER)) !== false) {
            $t = true;
        }
        unset($objHead);
        return $t;
    }

    public function getIsPrivateKey()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $t = false;
        // Extrait le contenu de l'objet source.
        $objHead = $this->readOneLineAsText(Entity::ENTITY_MAX_SIZE);
        // Vérifie si le contenu contient un entête de clé public
        if ((strstr($objHead, self::ENTITY_PRIVATE_HEADER)) !== false) {
            $t = true;
        }
        unset($objHead);
        return $t;
    }


    // Retrouve et retourne la clé publique.
    public function getPublicKeyID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_id;
    }

    public function getPublicKey()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return '';
        }
        if ($this->_publicKey != '') {
            return $this->_publicKey;
        }
        return '';
    }

    // Retrouve la clé publique.
    private function _findPublicKey()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

//		$key = '';
        if ($this->_io->checkObjectPresent($this->_id)
            && $this->_io->checkLinkPresent($this->_id)
        ) {
//			$key = $this->_io->objectRead($this->_id, self::ENTITY_MAX_SIZE);
        } else {
            return;
        }
//		$hashKey = '';
//		$hashAlgo = $this->getHashAlgo();
//		$hashKey = hash($hashAlgo, $key);
        $this->_publicKey = $this->_io->objectRead($this->_id, self::ENTITY_MAX_SIZE);
    }


    // Retourne l'identifiant de la clé privée.
    public function getPrivateKeyID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie la présence d'un ID de clé privée. La recherche au besoin.
        if (!isset($this->_privateKeyID)
            || !$this->_privateKeyID != '0'
        ) {
            $this->_findPrivateKeyID();
        }
        // Retourne l'ID.
        return $this->_privateKeyID;
    }

    // Retrouve l'identifiant de la clé privée.
    private function _findPrivateKeyID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie la présence d'un ID de clé privée.
        if (isset($this->_privateKeyID)
            && $this->_privateKeyID != '0'
        ) {
            return true;
        }
        // Extrait les liens f vers la clé publique.
        $list = $this->readLinksFilterFull($this->_id, '', 'f', '', $this->_id, '0');
        if (sizeof($list) == 0) {
            return true;
        }
        // Boucle de recherche d'une clé privée.
        foreach ($list as $link) {
            $hashSource = $link->getHashSource();
            // Vérifie le lien et la présence de l'objet source.
            if ($link->getHashSigner() == $this->_id
                && $link->getAction() == 'f'
                && $link->getHashTarget() == $this->_id
                && $link->getHashMeta() == '0'
                && $this->_io->checkObjectPresent($hashSource)
            ) {
                // Extrait le contenu de l'objet source. @todo remplacer par Object::getContent ...
                $line = $this->_io->objectRead($hashSource, self::ENTITY_MAX_SIZE);
                // Vérifie si le contenu contient un entête de clé privée
                if (strstr($line, self::ENTITY_PRIVATE_HEADER) !== false) {
                    // Mémorise l'ID de la clé privée.
                    $this->_privateKeyID = $hashSource;
                }
            }
        }
        // Vérifie qu'une clé privée a été trouvée.
        if (isset($this->_privateKeyID)
            && $this->_privateKeyID != '0'
        ) {
            return true;
        }
        return false;
    }

    // Retrouve la clé privée.
    private function _findPrivateKey()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie la présence d'une clé privée.
        if (isset($this->_privateKey)
            && $this->_privateKey != ''
        ) {
            return true;
        }
        // Vérifie la présence d'un ID de clé privée. La recherche au besoin.
        if (!isset($this->_privateKeyID)
            || !$this->_privateKeyID != '0'
        ) {
            $this->_findPrivateKeyID();
        }
        // Extrait le contenu de l'objet.
        $this->_privateKey = $this->_io->objectRead($this->_privateKeyID, self::ENTITY_MAX_SIZE);
        return true;
        // A faire... vérifier que c'est bien une clé privée _pour_ cette clé publique.
    }

    // Définit le mot de passe de la clé privée.
    public function setPrivateKeyPassword($passwd)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $this->_findPrivateKey();
        // Vérifie le mot de passe sur la clé privée.
        $check = $this->_crypto->getPrivateKey($this->_privateKey, $passwd);
        if ($check === false) {
            return false;
        }
        $this->_privateKeyPasswordSalt = $this->_crypto->getStrongRandom(self::ENTITY_PASSWORD_SALT_SIZE);
        // A faire... le chiffrement du mot de passe avec le sel et l'ID de session php...
        $this->_privateKeyPassword = $passwd;
        $this->_issetPrivateKeyPassword = true;
        $this->_nebuleInstance->addListEntitiesUnlocked($this->_id);
        return true;
    }

    /**
     * Supprime le mot de passe de l'entité.
     * Cela verrouille l'entité.
     *
     * @return boolean
     */
    public function unsetPrivateKeyPassword()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return false;
        }
        $this->_privateKeyPassword = $this->_privateKeyPasswordSalt;
        $this->_privateKeyPassword = '';
        $this->_privateKeyPasswordSalt = '';
        $this->_issetPrivateKeyPassword = false;
        $this->_nebuleInstance->removeListEntitiesUnlocked($this->_id);
        return true;
    }

    public function checkPrivateKeyPassword()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_issetPrivateKeyPassword;
    }

    public function changePrivateKeyPassword($newPasswd)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return false;
        }
        // Vérifie que le mot de passe actuel est présent.
        if (!$this->_issetPrivateKeyPassword) {
            return false;
        }

        $this->_metrology->addLog('Change entity password - old ' . $this->_privateKeyID, Metrology::LOG_LEVEL_NORMAL); // Log
        $oldPrivateKeyID = $this->_privateKeyID;

        $privateKey = $this->_crypto->getPrivateKey($this->_privateKey, $this->_privateKeyPassword);
        if ($privateKey === false) {
            return false;
        }

        $newKey = $this->_crypto->getPkeyPrivate($privateKey, $newPasswd);
        if ($newKey === false) {
            return false;
        }

        $this->_privateKeyPasswordSalt = $this->_crypto->getStrongRandom(self::ENTITY_PASSWORD_SALT_SIZE);
        // A faire... le chiffrement du mot de passe avec le sel et l'ID de session php...
        $this->_privateKeyPassword = $newPasswd;
        $this->_privateKey = $newKey;
        $this->_privateKeyID = $this->_crypto->hash($this->_privateKey);
        $this->_issetPrivateKeyPassword = true;
        $this->_metrology->addLog('Change entity password - new ' . $this->_privateKeyID, Metrology::LOG_LEVEL_NORMAL); // Log

        unset($newKey, $privateKey);

        // Ecrit l'objet de la nouvelle clé privée.
        $this->_io->objectWrite($this->_privateKey);

        // Définition de la date.
        $date = date(DATE_ATOM);

        // Si ce n'est pas une création d'entité, fait les liens de mises à jours de clés privées.
        if (!$this->_newPrivateKey) {
            // Création lien 1.
            $source = $oldPrivateKeyID;
            $target = $this->_id;
            $meta = '0';
            $link = '_' . $this->_id . '_' . $date . '_x_' . $source . '_' . $target . '_' . $meta;
            $this->_createNewEntityWriteLink($link, $source, $target, $meta);

            // Création lien 2.
            $source = $oldPrivateKeyID;
            $target = $this->_privateKeyID;
            $meta = '0';
            $link = '_' . $this->_id . '_' . $date . '_u_' . $source . '_' . $target . '_' . $meta;
            $this->_createNewEntityWriteLink($link, $source, $target, $meta);
        }

        // Création lien 3.
        $source = $this->_privateKeyID;
        $target = $this->_crypto->hash($this->_crypto->hashAlgorithmName());
        $meta = $this->_crypto->hash('nebule/objet/hash');
        $link = '_' . $this->_id . '_' . $date . '_l_' . $source . '_' . $target . '_' . $meta;
        $this->_createNewEntityWriteLink($link, $source, $target, $meta);

        // Création lien 4.
        $source = $this->_privateKeyID;
        $target = $this->_crypto->hash(self::ENTITY_TYPE);
        $meta = $this->_crypto->hash('nebule/objet/type');
        $link = '_' . $this->_id . '_' . $date . '_l_' . $source . '_' . $target . '_' . $meta;
        $this->_createNewEntityWriteLink($link, $source, $target, $meta);

        // Création lien 5.
        $source = $this->_privateKeyID;
        $target = $this->_id;
        $meta = '0';
        $link = '_' . $this->_id . '_' . $date . '_f_' . $source . '_' . $target . '_' . $meta;
        $this->_createNewEntityWriteLink($link, $source, $target, $meta);

        unset($date, $source, $target, $meta, $link);

        $this->_newPrivateKey = false;
        return true;
    }


    /**
     * Signature de liens.
     *
     * @param string $link
     * @param string $algo
     * @return string
     */
    public function signLink($link, $algo = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_privateKey == '') {
            $this->_metrology->addLog('ERROR entity no private key', Metrology::LOG_LEVEL_NORMAL); // Log
            return false;
        }
        if ($this->_privateKeyPassword == '') {
            $this->_metrology->addLog('ERROR entity no password for private key', Metrology::LOG_LEVEL_NORMAL); // Log
            return false;
        }
        if ($algo == '') {
            $algo = $this->_crypto->hashAlgorithmName();
        }

        $hash = $this->_crypto->hash($link, $algo);
        return $this->_crypto->sign($hash, $this->_privateKey, $this->_privateKeyPassword);
    }

    /**
     * Signature et écriture de liens.
     *
     * @param string $link
     * @return string
     */
    public function signWriteLink($link)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $signe = $this->signLink($link);
        if ($signe === false) {
            return false;
        }
        $signedLink = $signe . $link;
        // A faire...
    }

    /**
     * Déchiffrement de données pour l'entité.
     * Déchiffrement asymétrique uniquement, càd avec la clé privée.
     *
     * @param string $data
     * @return string
     */
    public function decrypt($code)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_crypto->decryptTo($code, $this->_privateKey, $this->_privateKeyPassword);
    }


    /**
     * Lecture du nom complet.
     * La construction du nom complet d'une entité est légèrement différente d'un objet.
     *
     * @param string $socialClass
     * @return string
     */
    public function getFullName($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return '';
        }
        if (isset($this->_fullname)
            && trim($this->_fullname) != ''
        ) {
            return $this->_fullname;
        }

        // Recherche des éléments. Pas de suffix pris en compte.
        $name = $this->getName($socialClass);
        $prefix = $this->getPrefixName($socialClass);
        $suffix = $this->getSuffixName($socialClass);
        $firstname = $this->getFirstname($socialClass);
        $surname = $this->getSurname($socialClass);

        // Reconstitution du nom complet : préfixe prénom "surnom" nom suffixe
        $fullname = $name;
        if ($surname != '') {
            $fullname = '&ldquo;' . $surname . '&rdquo; ' . $fullname;
        }
        if ($firstname != '') {
            $fullname = $firstname . ' ' . $fullname;
        }
        if ($prefix != '') {
            $fullname = $prefix . ' ' . $fullname;
        }
        if ($suffix != '') {
            $fullname = $fullname . ' ' . $suffix;
        }
        $this->_fullname = $fullname;

        // Resultat.
        return $fullname;
    }

    // Retourne les localisations de l'entité.
    public function getLocalisations($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return '';
        }
        return $this->getProperties(nebule::REFERENCE_NEBULE_OBJET_ENTITE_LOCALISATION, $socialClass);
    }

    public function getLocalisationsID($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return '';
        }
        return $this->getPropertiesID(nebule::REFERENCE_NEBULE_OBJET_ENTITE_LOCALISATION, $socialClass);
    }

    public function getLocalisation($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return '';
        }
        return $this->getProperty(nebule::REFERENCE_NEBULE_OBJET_ENTITE_LOCALISATION, $socialClass);
    }

    public function getLocalisationID($socialClass = '')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return '';
        }
        return $this->getPropertyID(nebule::REFERENCE_NEBULE_OBJET_ENTITE_LOCALISATION, $socialClass);
    }

    /**
     * Recherche la miniature d'un image la plus proche possible de la dimension demandée. Recherche faite sur un seul niveau d'arborescence.
     *
     * @param number $size
     * @return string
     */
    public function getFaceID($size = 400)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_id == '0') {
            return '';
        }
        if ($size == '0') {
            return '';
        }

        $ximg = (int)($this->getProperty('EXIF/ImageWidth', 'all'));
        if ($ximg == 0) {
            $ximg = (int)($this->getProperty('COMPUTED.Width', 'all'));
        }

        $yimg = (int)($this->getProperty('EXIF/ImageHeight', 'all'));
        if ($yimg == 0) {
            $yimg = (int)($this->getProperty('COMPUTED.Height', 'all'));
        }

        if ($ximg == 0 || $yimg == 0) // Si pas de dimensions trouvées, continue avec des valeurs par défaut.
        {
            $ximg = 10000;
            $yimg = 10000;
        }

        // Si l'objet est plus petit que la 'miniature' demandée, retourne 0.
        $xyimg = sqrt($ximg * $yimg);
        if ($size >= $xyimg) {
            return '0';
        }

        $list = array();
        $links = array();
        //_l_fnd($this->_id, $links, 'f', $this->_id, '', '0');				// @todo Vérifier le bon fonctionnement.
        $links = $this->readLinksFilterFull('', '', 'f', $this->_id, '', '0');
        foreach ($links as $link) {
            $instance6 = $this->_nebuleInstance->newObject($link->getHashTarget());
            $type = $instance6->getType('all');
            if (($type == 'image/png'
                    || $type == 'image/jpeg')
                && $instance6->checkPresent()
            ) {
                $xsize = (int)($instance6->getProperty('EXIF/ImageWidth', 'all'));
                if ($xsize == 0) {
                    $xsize = (int)($instance6->getProperty('COMPUTED.Width', 'all'));
                }
                $ysize = (int)($instance6->getProperty('EXIF/ImageHeight', 'all'));
                if ($ysize == 0) {
                    $ysize = (int)($instance6->getProperty('COMPUTED.Width', 'all'));
                }
                if ($xsize != ''
                    && $ysize != ''
                    && $xsize != '0'
                    && $ysize != '0'
                ) {
                    $list[$instance6->getID()][0] = $instance6->getID();
                    $list[$instance6->getID()][1] = sqrt((int)$xsize * (int)$ysize);
                }
            }
        }

        // Recherche la résolution la plus proche.
        $best = $xyimg;
        $bestimg = '0';
        if (sizeof($list) != 0) {
            foreach ($list as $img) {
                if (abs($size - $img[1]) < $best) {
                    $bestimg = $img[0];
                    $best = abs($size - $img[1]);
                }
            }
        }
        if ($bestimg != $this->_id && $xyimg < $best) {
            return '0';
        }
        if ($bestimg != $this->_id) {
            return $bestimg;
        } else // Si pas trouvé d'objet aux dimmensions intéressantes, recherche si ça ne marche pas mieux avec l'objet parent.
        {
            $uplinks = array();
            //_l_fnd($this->_id, $uplinks, 'f', '', $this->_id, '0');							// @todo Vérifier le bon fonctionnement.
            $uplinks = $this->readLinksFilterFull('', '', 'f', '', $this->_id, '0');
            foreach ($uplinks as $uplink) {
                $instance5 = $this->_nebuleInstance->newObject($uplink->getHashSource());
                $type = $instance5->getType('all');
                if (($type == 'image/png' || $type == 'image/jpeg') && $instance5->checkPresent()) {
                    $list = array();
                    $links = array();
                    //_l_fnd($instance5->getID(), $links, 'f', $instance5->getID(), '', '0');          // @todo Vérifier le bon fonctionnement.
                    $links = $instance5->readLinksFilterFull('', '', 'f', $instance5->getID(), '', '0');
                    foreach ($links as $link) {
                        $instance6 = $this->_nebuleInstance->newObject($link->getHashTarget());
                        $type = $instance6->getType('all');
                        if ($type == 'image/png'
                            || $type == 'image/jpeg'
                        ) {
                            $xsize = (int)($instance6->getProperty('EXIF/ImageWidth', 'all'));
                            if ($xsize == 0) {
                                $xsize = (int)($instance6->getProperty('COMPUTED.Width', 'all'));
                            }
                            $ysize = (int)($instance6->getProperty('EXIF/ImageHeight', 'all'));
                            if ($ysize == 0) {
                                $ysize = (int)($instance6->getProperty('COMPUTED.Width', 'all'));
                            }
                            if ($xsize != ''
                                && $ysize != ''
                                && $xsize != '0'
                                && $ysize != '0'
                            ) {
                                $list[$instance6->getID()][0] = $instance6->getID();
                                $list[$instance6->getID()][1] = sqrt((int)$xsize * (int)$ysize);
                            }
                        }
                    }
                }
            }
        }
        if (sizeof($list) != 0) {
            foreach ($list as $img) {
                if (abs($size - $img[1]) < $best) {
                    $bestimg = $img[0];
                    $best = abs($size - $img[1]);
                }
            }
        }
        if ($xyimg < $best) {
            return '0';
        }
        return $bestimg;
    }


    // Ecrit l'objet si non présent.
    public function write()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if (!$this->_io->checkObjectPresent($this->_id)) {
            $id = $this->_io->objectWrite($this->_publicKey);
        } else {
            $id = $this->_id;
        }

        // Métrologie.
        $v = true;
        if ($id === false) {
            $v = false;
            // Si l'écriture échoue, on crée l'objet d'ID '0'. @todo à revoir si vraiment utile... pareil pour objects->write().
            $id = '0';
        }
        $this->_metrology->addAction('addent', $id, $v);

        return $v;
    }



    // Désactivation des fonctions de protection.

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function getMarkProtected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function getReloadMarkProtected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return string
     */
    public function getProtectedID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return '0';
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return string
     */
    public function getUnprotectedID()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_id;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function setProtected($obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function setUnprotected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return boolean
     */
    public function setProtectedTo($entity)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les groupes.
     *
     * @return array
     */
    public function getProtectedTo()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return array();
    }


    /**
     * Retourne si l'entité est une autorité locale.
     * Fait appel à la fonction dédiée de la classe nebule.
     *
     * @return boolean
     */
    public function getIsLocalAuthority()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_nebuleInstance->getIsLocalAuthority($this->_id);
    }


    /**
     * Retourne la liste des liens vers les groupes dont l'entité est à l'écoute.
     *
     * @param string $socialClass
     * @return array:Link
     */
    public function getListIsFollowerOfGroupLinks($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->id,
            '',
            $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI)
        );

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Tri les objets de type groupe.
        foreach ($links as $i => $link) {
            $instance = $this->_nebuleInstance->newGroup($link->getHashTarget());
            if (!$instance->getIsGroup('all')) {
                unset($links[$i]);
            }
        }

        return $links;
    }

    /**
     * Retourne la liste des ID vers les groupes dont l'entité est à l'écoute.
     *
     * @param string $socialClass
     * @return array:string
     */
    public function getListIsFollowerOnGroupID($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $list = array();

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->id,
            '',
            $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_GROUPE_SUIVI)
        );

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Tri les objets de type groupe.
        foreach ($links as $i => $link) {
            $instance = $this->_nebuleInstance->newGroup($link->getHashTarget());
            if ($instance->getIsGroup('all')) {
                $list[$link->getHashTarget()] = $link->getHashTarget();
            }
        }

        return $list;
    }

    /**
     * Retourne la liste des liens vers les conversations dont l'entité est à l'écoute.
     * S'appuie sur la fonction dédiée aux groupes.
     *
     * @param string $socialClass
     * @return array:Link
     */
    public function getListIsFollowerOfConversationLinks($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $this->id,
            '',
            $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE)
        );

        // Fait un tri par pertinance sociale.
        $this->_social->arraySocialFilter($links, $socialClass);

        // Tri les objets de type groupe.
        foreach ($links as $i => $link) {
            $instance = $this->_nebuleInstance->newConversation($link->getHashTarget());
            if (!$instance->getIsConversation('all')) {
                unset($links[$i]);
            }
        }

        return $links;
    }

    /**
     * Retourne la liste des ID vers les conversations dont l'entité est à l'écoute.
     * S'appuie sur la fonction dédiée aux groupes.
     *
     * @param string $socialClass
     * @return array:string
     */
    public function getListIsFollowerOnConversationID($socialClass = 'myself')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $list = array();

        // Liste tous les liens de définition des membres du groupe.
        $links = $this->getListIsFollowerOfConversationLinks($socialClass);

        // Tri les objets de type groupe.
        foreach ($links as $i => $link) {
            $instance = $this->_nebuleInstance->newConversation($link->getHashTarget());
            if ($instance->getIsConversation('all')) {
                $list[$link->getHashTarget()] = $link->getHashTarget();
            }
        }

        return $list;
    }


    /**
     * Affiche la partie menu de la documentation.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#oe">OE / Entité</a>
            <ul>
                <li><a href="#oen">OEM / Entités Maîtresses</a></li>
                <li><a href="#oen">OEN / Nommage</a></li>
                <li><a href="#oep">OEP / Protection</a></li>
                <li><a href="#oed">OED / Dissimulation</a></li>
                <li><a href="#oel">OEL / Liens</a></li>
                <li><a href="#oec">OEC / Création</a></li>
                <li><a href="#oes">OES / Stockage</a></li>
                <li><a href="#oet">OET / Transfert</a></li>
                <li><a href="#oer">OER / Réservation</a></li>
                <li><a href="#oeio">OEIO / Implémentation des Options</a></li>
                <li><a href="#oeia">OEIA / Implémentation des Actions</a></li>
                <li><a href="#oeo">OEO / Oubli</a></li>
            </ul>
        </li>

        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h2 id="oe">OE / Entité</h2>
        <p>A faire...</p>
        <p>L’entité est un objet caractéristique. Elle dispose d’une clé publique, par laquelle elle est identifiée, et
            d’une clé privée.</p>
        <p>L’indication de la fonction de prise d’empreinte (hashage) ainsi que le type de bi-clé sont impératifs. Le
            lien est identique à celui défini pour un objet.</p>
        <p>Le type mime <code>mime-type:application/x-pem-file</code> est suffisant pour indiquer que cet objet est une
            entité. <i>Des valeurs équivalentes pourront être définies ultérieurement</i>.</p>
        <p>Toutes les autres indications sont optionnelles.</p>

        <h3 id="oem">OEM / Entités Maîtresses</h3>
        <p>La bibliothèque utilise actuellement plusieurs entités spéciales, dites autorités maîtresses, avec des rôles
            prédéfinis.</p>
        <ol>
            <li>Maître du tout. L'instance actuelle s'appelle <a href="http://puppetmaster.nebule.org">puppetmaster</a>.
                Voir <a href="#cam">CAM</a>.
            </li>
            <li>Maître de la sécurité. L'instance actuelle s'appelle <a href="http://cerberus.nebule.org">cerberus</a>.
                Voir <a href="#cams">CAMS</a>.
            </li>
            <li>Maître du code. L'instance actuelle s'appelle <a href="http://bachue.nebule.org">bachue</a>. Voir <a
                        href="#camc">CAMC</a>.
            </li>
            <li>Maître de l'annuaire. L'instance actuelle s'appelle <a href="http://asabiyya.nebule.org">assabyia</a>.
                Voir <a href="#cama">CAMA</a>.
            </li>
            <li>Maître du temps. L'instance actuelle s'appelle <a href="http://kronos.nebule.org">kronos</a>. Voir <a
                        href="#camt">CAMT</a>.
            </li>
        </ol>

        <h3 id="oen">OEN / Nommage</h3>
        <p>Le nommage à l’affichage du nom des entités repose sur plusieurs propriétés :</p>
        <ol>
            <li>nom</li>
            <li>prénom</li>
            <li>surnom</li>
            <li>préfixe</li>
            <li>suffixe</li>
        </ol>
        <p>Ces propriétés sont matérialisées par des liens de type <code>l</code> avec comme objets méta, respectivement
            :</p>
        <ol>
            <li><code>nebule/objet/nom</code></li>
            <li><code>nebule/objet/prenom</code></li>
            <li><code>nebule/objet/surnom</code></li>
            <li><code>nebule/objet/prefix</code></li>
            <li><code>nebule/objet/suffix</code></li>
        </ol>
        <p>Par convention, voici le nommage des entités :</p>
        <p><code>préfixe prénom "surnom" nom suffixe</code></p>

        <h3 id="oep">OEP / Protection</h3>
        <p>A faire...</p>

        <h3 id="oed">OED / Dissimulation</h3>
        <p>A faire...</p>

        <h3 id="oel">OEL / Liens</h3>
        <p>A faire...</p>

        <h3 id="oec">OEC / Création</h3>
        <p>La première étape consiste en la génération d’un bi-clé (public/privé) cryptographique. Ce bi-clé peut être
            de type RSA ou équivalent. Aujourd’hui, seul RSA est reconnu.</p>
        <p>On extrait la clé publique du bi-clé. Le calcul de l’empreinte cryptographique de la clé publique donne
            l’identifiant de l’entité. On écrit dans les objets (o/*) l’objet avec comme contenu la clé publique et
            comme id son empreinte cryptographique.</p>
        <p>On extrait la clé privée du bi-clé. Il est fortement conseillé lors de l’extraction de protéger tout de suite
            la clé privée avec un mot de passe. On écrit dans les objets (o/*) l’objet avec comme contenu la clé privée
            et comme id son empreinte cryptographique (différente de celle de la clé publique).</p>
        <p>A partir de maintenant, le bi-clé n’est plus nécessaire. Il faut le supprimer avec un effacement
            sécurisé.</p>
        <p>Pour que l’objet soit reconnu comme entité il faut créer les liens correspondants.</p>
        <ul>
            <li>Lien 1 :
                <ul>
                    <li>Signature du lien par la clé privée de la nouvelle entité</li>
                    <li>Identifiant de la clé publique</li>
                    <li>Horodatage</li>
                    <li>Lien de type <code>l</code></li>
                    <li>Identifiant de la clé <span style="font-weight:bold;">publique</span></li>
                    <li>Empreinte de l’algorithme de hash utilisé pour le calcul des empreintes</li>
                    <li>Empreinte de ‘nebule/objet/hash’</li>
                </ul>
            </li>
            <li>Lien 2 :
                <ul>
                    <li>Signature du lien par la clé privée de la nouvelle entité</li>
                    <li>Identifiant de la clé publique</li>
                    <li>Horodatage</li>
                    <li>Lien de type <code>l</code></li>
                    <li>Identifiant de la clé <span style="font-weight:bold;">privée</span></li>
                    <li>Empreinte de l’algorithme de hash utilisé pour le calcul des empreintes</li>
                    <li>Empreinte de ‘nebule/objet/hash’</li>
                </ul>
            </li>
            <li>Lien 3 :
                <ul>
                    <li>Signature du lien par la clé privée de la nouvelle entité</li>
                    <li>Identifiant de la clé publique</li>
                    <li>Horodatage</li>
                    <li>Lien de type <code>l</code></li>
                    <li>Identifiant de la clé <span style="font-weight:bold;">publique</span></li>
                    <li>Empreinte de ‘application/x-pem-file’</li>
                    <li>Empreinte de ‘nebule/objet/type’</li>
                </ul>
            </li>
            <li>Lien 4 :
                <ul>
                    <li>Signature du lien par la clé privée de la nouvelle entité</li>
                    <li>Identifiant de la clé publique</li>
                    <li>Horodatage</li>
                    <li>Lien de type <code>l</code></li>
                    <li>Identifiant de la clé <span style="font-weight:bold;">privée</span></li>
                    <li>Empreinte de ‘application/x-pem-file’</li>
                    <li>Empreinte de ‘nebule/objet/type’</li>
                </ul>
            </li>
            <li>Lien 5 :
                <ul>
                    <li>Signature du lien par la clé privée de la nouvelle entité</li>
                    <li>Identifiant de la clé publique</li>
                    <li>Horodatage</li>
                    <li>Lien de type <code>f</code> ;</li>
                    <li>Identifiant de la clé <span style="font-weight:bold;">privée</span></li>
                    <li>Identifiant de la clé <span style="font-weight:bold;">publique</span></li>
                    <li>0.</li>
                </ul>
            </li>
        </ul>
        <p>C’est le minimum vital pour une entité. Ensuite, d’autres propriétés peuvent être ajoutées à l’entité (id clé
            publique) comme sont nom, son type, etc…</p>
        <p>Si le mot de passe de la clé privée est définit par l’utilisateur demandeur de la nouvelle entité, il faut
            supprimer ce mot de passe avec un effacement sécurisé.</p>
        <p>Si le mot de passe de la clé privée a été généré, donc que la nouvelle entité est esclave d’une entité
            maître, le mot de passe doit être stocké dans un objet chiffré pour l’entité maître. Et il faut générer un
            lien reliant l’objet de mot de passe à la clé privée de la nouvelle entité.</p>

        <h3 id="oes">OES / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="oet">OET / Transfert</h3>
        <p>A faire...</p>

        <h3 id="oer">OER / Réservation</h3>
        <p>A faire...</p>

        <h4 id="oeio">OEIO / Implémentation des Options</h4>
        <p>A faire...</p>

        <h4 id="oeia">OEIA / Implémentation des Actions</h4>
        <p>A faire...</p>

        <h3 id="oeo">OEO / Oubli</h3>
        <p>L'oubli vonlontaire de certains liens et objets n'est encore ni théorisé ni implémenté mais deviendra
            indispensable lorsque l'espace viendra à manquer (cf <a href="#cn">CN</a>).</p>

        <?php
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Localisation.
 * @todo à revoir complètement !
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID de la localisation ou la localisation.
 *
 * La localisation est forcément un texte et est passée automatiquement en minuscule.
 * ------------------------------------------------------------------------------------------
 */
class Localisation extends Node
{
    private $_localisation = '', $_protocol = '', $_communication, $_ioDefaultPrefix = '';

    public function __construct(nebule $nebuleInstance, $id, $localisation = '')
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();
        $this->_ioDefaultPrefix = $this->_io->getDefaultLocalisation();
        $id = trim(strtolower($id));
        $this->_metrology->addLog('New instance localisation ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.

        // Vérifie sommairement la localisation.
        if (is_string($id) && $id != '0' && $id != '' && ctype_xdigit($id)) {
            $this->_id = $id;
            // Extrait la localisation et la convertit en minuscule.
            $this->_localisation = trim(strtolower($this->_io->objectRead($id)));
        } elseif (is_string($id) && $id == '0') {
            // Crée le nouvel objet.
            $this->_createNewObject($localisation);
            // Définit la licalisation, en minuscule.
            $this->_localisation = trim(strtolower($localisation));
        } else {
            // La localisation n'est pas valide.
            $this->_id = '0';
            $this->_localisation = '';
        }

        // Extrait le type de protocole.
        // Si invalide ou non reconnu, la variable du protocole est vide.
        if (substr($this->_localisation, 0, 7) == 'http://' || substr($this->_localisation, 0, 8) == 'https://') {
            // @todo Test la validité de l'adresse.
            $this->_protocol = 'HTTP';
        } elseif (substr($this->_localisation, 0, 5) == 'mail:') {
            // @todo Test la validité de l'adresse.
            $this->_protocol = 'SMTP';
        } elseif (substr($this->_localisation, 0, 5) == 'xmpp:') {
            // @todo Test la validité de l'adresse.
            $this->_protocol = 'XMPP';
        } else {
            $this->_protocol = '';
        }
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->_localisation;
    }

    // Synchronise l'objet avec l'ID donné si non présent localement.
    public function syncObjectID($id)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // @todo
    }

    // Synchronise les liens.
    public function syncLinksID($id)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // @todo
    }

    // Synchronise à la fois les liens et l'objet avec l'ID donné.
    public function syncID($id)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        $this->syncLinksID($id);
        $this->syncObjectID($id);
    }


    private function _addPonderate($time)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_nebuleInstance->getOption('permitLocalisationStats')) {
            return false;
        }

        // @todo
    }


    /**
     * Affiche la partie menu de la documentation.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#ol">OL / Localisation</a>
            <ul>
                <li><a href="#oln">OLN / Nommage</a></li>
                <li><a href="#olp">OLP / Protection</a></li>
                <li><a href="#old">OLD / Dissimulation</a></li>
                <li><a href="#oll">OLL / Liens</a></li>
                <li><a href="#olc">OLC / Création</a></li>
                <li><a href="#ols">OLS / Stockage</a></li>
                <li><a href="#olt">OLT / Transfert</a></li>
                <li><a href="#olr">OLR / Réservation</a></li>
                <li><a href="#olio">OLIO / Implémentation des Options</a></li>
                <li><a href="#olia">OLIA / Implémentation des Actions</a></li>
            </ul>
        </li>

        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h2 id="ol">OL / Localisation</h2>
        <p>A faire...</p>
        <p>Une localisation permet de trouver l’emplacement des objets et liens générés par une entité.</p>
        <p>Un emplacement n’a de sens que pour une entité.</p>
        <p>Une entité peut disposer de plusieurs localisations. Il faut considérer que toute entité qui héberge l’objet
            d’une autre entité devient de fait une localisation valide même si cela n’est pas explicitement définit.</p>

        <h3 id="oln">OLN / Nommage</h3>
        <p>A faire...</p>

        <h3 id="olp">OLP / Protection</h3>
        <p>A faire...</p>

        <h3 id="old">OLD / Dissimulation</h3>
        <p>A faire...</p>

        <h3 id="oll">OLL / Liens</h3>
        <p>A faire...</p>

        <h3 id="olc">OLC / Création</h3>
        <p>Liste des liens à générer lors de la création d'une localisation.</p>
        <p>A faire...</p>

        <h3 id="ols">OLS / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="olt">OLT / Transfert</h3>
        <p>A faire...</p>

        <h3 id="olr">OLR / Réservation</h3>
        <p>A faire...</p>

        <h4 id="olio">OLIO / Implémentation des Options</h4>
        <p>A faire...</p>

        <h4 id="olia">OLIA / Implémentation des Actions</h4>
        <p>A faire...</p>

        <?php
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Conversation.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID d'une conversation ou 'new' ;
 *
 * L'ID d'une conversation est forcément un texte en hexadécimal.
 *
 * Si une erreur survient lors de la lecture de la conversation ou lors de la création, assigne l'ID 0.
 *
 * Tout objet peut devenir une conversation sans avoir été préalablement marqué comme conversation.
 * Le simple faire de faire un lien pour désigner un objet comme membre de la conversation d'un autre objet
 *   suffit à créer la conversation.
 * ------------------------------------------------------------------------------------------
 */
class Conversation extends Group
{
    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_id',
        '_fullname',
        '_cacheProperty',
        '_cacheProperties',
        '_cacheMarkProtected',
        '_idProtected',
        '_idUnprotected',
        '_idProtectedKey',
        '_idUnprotectedKey',
        '_markProtectedChecked',
        '_cacheCurrentEntityUnlocked',
        '_usedUpdate',
        '_isGroup',
        '_isConversation',
        '_isMarkClosed',
        '_isMarkProtected',
        '_isMarkObfuscated',
        '_referenceObject',
        '_referenceObjectClosed',
        '_referenceObjectProtected',
        '_referenceObjectObfuscated',
    );

    /**
     * Constructeur.
     *
     * Toujours transmettre l'instance de la librairie nebule.
     * Si la conversation existe, juste préciser l'ID de celle-ci.
     * Si c'est une nouvelle conversation à créer, mettre l'ID à 'new'.
     *
     * @param nebule $nebuleInstance
     * @param string $id
     * @param boolean $closed si $id == 'new'
     * @param boolean $protected si $id == 'new'
     * @param boolean $obfuscated si $id == 'new'
     */
    public function __construct(nebule $nebuleInstance, $id, $closed = false, $protected = false, $obfuscated = false)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();

        $id = trim(strtolower($id));
        $this->_metrology->addLog('New instance conversation ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.

        if (is_string($id)
            && $id != ''
            && ctype_xdigit($id)
        ) {
            // Si l'ID est cohérent et l'objet nebule présent, c'est bon.
            $this->_loadConversation($id);
        } elseif (is_string($id)
            && $id == 'new'
        ) {
            // Si c'est une nouvelle conversation à créer, renvoie à la création.
            $this->_createNewConversation($closed, $protected, $obfuscated);
        } else {
            // Sinon, la conversation est invalide, retourne 0.
            $this->_id = '0';
        }

        // Pré-calcul les références.
        $this->getReferenceObject();
        $this->getReferenceObjectClosed();
        $this->getReferenceObjectProtected();
        $this->getReferenceObjectObfuscated();
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->_id;
    }

    /**
     * Retourne les variables à sauvegarder dans la session php lors d'une mise en sommeil de l'instance.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return self::SESSION_SAVED_VARS;
    }

    /**
     * Foncion de réveil de l'instance et de ré-initialisation de certaines variables non sauvegardées.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();
        $this->_cacheMarkDanger = false;
        $this->_cacheMarkWarning = false;
        $this->_cacheUpdate = '';
    }

    /**
     *  Chargement d'une conversation existant.
     *
     * @param string $id
     */
    private function _loadConversation($id)
    {
        // Vérifie que c'est bien un objet.
        if (!is_string($id)
            || $id == ''
            || !ctype_xdigit($id)
            || !$this->_io->checkLinkPresent($id)
        ) {
            $id = '0';
        }

        $this->_id = $id;
        $this->_metrology->addLog('Load conversation ' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
        $this->getIsConversation();
    }

    /**
     * Création d'une nouvelle conversation.
     *
     * @param boolean $closed
     * @param boolean $protected
     * @param boolean $obfuscated
     * @return boolean
     */
    protected function _createNewConversation($closed, $protected, $obfuscated)
    {
        $this->_metrology->addLog('Ask create conversation', Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie que l'on puisse créer une conversation.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            // Génère un contenu aléatoire.
            $data = $this->_crypto->getPseudoRandom(32);

            // Si le contenu est valide.
            if ($data != ''
                && $data !== false
            ) {
                // Calcul l'ID référence de la conversation.
                $this->_id = substr($this->_crypto->hash($data), 0, 32)
                    . '0000656e7562656c6f2f6a627465632f6e6f6576737274616f690a6e';
                $this->_metrology->addLog('Create conversation ' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log

                // Mémorise les données.
                $this->_data = $data;
                $this->_haveData = true;
                $data = null;

                $signer = $this->_nebuleInstance->getCurrentEntity();
                $date = date(DATE_ATOM);
                $hashconversation = $this->getReferenceObject();

                // Création lien de hash.
                $date2 = $date;
                if ($obfuscated) {
                    $date2 = '0';
                }
                $action = 'l';
                $source = $this->_id;
                $target = $this->_crypto->hash($this->_crypto->hashAlgorithmName());
                $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_HASH);
                $link = '0_' . $signer . '_' . $date2 . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $newLink = $this->_nebuleInstance->newLink($link);
                $newLink->signWrite();

                // Création lien de conversation.
                $action = 'l';
                $source = $this->_id;
                $target = $hashconversation;
                $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE);
                $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $newLink = $this->_nebuleInstance->newLink($link);
                $newLink->sign();
                if ($obfuscated) {
                    $newLink->obfuscate();
                }
                $newLink->write();

                // Si besoin, marque la conversation comme fermée.
                if ($closed) {
                    $this->_metrology->addLog('Create closed conversation', Metrology::LOG_LEVEL_DEBUG); // Log
                    $action = 'l';
                    $source = $this->_id;
                    $target = $signer;
                    $meta = $this->getReferenceObjectClosed();
                    $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                    $newLink = $this->_nebuleInstance->newLink($link);
                    $newLink->sign();
                    if ($obfuscated) {
                        $newLink->obfuscate();
                    }
                    $newLink->write();
                }

                // Si besoin, marque la conversation comme protégée.
                if ($protected) {
                    $this->_metrology->addLog('Create protected conversation', Metrology::LOG_LEVEL_DEBUG); // Log
                    $action = 'l';
                    $source = $this->_id;
                    $target = $signer;
                    $meta = $this->getReferenceObjectProtected();
                    $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                    $newLink = $this->_nebuleInstance->newLink($link);
                    $newLink->sign();
                    if ($obfuscated) {
                        $newLink->obfuscate();
                    }
                    $newLink->write();
                }

                // Si besoin, marque la conversation comme dissimulée.
                if ($obfuscated) {
                    $this->_metrology->addLog('Create obfuscated conversation', Metrology::LOG_LEVEL_DEBUG); // Log
                    $action = 'l';
                    $source = $this->_id;
                    $target = $signer;
                    $meta = $this->getReferenceObjectObfuscated();
                    $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                    $newLink = $this->_nebuleInstance->newLink($link);
                    $newLink->sign();
                    $newLink->obfuscate();
                    $newLink->write();
                }

                // Création du lien de l'entité originaire de la conversation.
                $action = 'l';
                $source = $signer;
                $target = $this->_id;
                $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE);
                $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
                $newLink = $this->_nebuleInstance->newLink($link);
                $newLink->sign();
                if ($obfuscated) {
                    $newLink->obfuscate();
                }
                $newLink->write();

                $this->_isConversation = true;
            } else {
                $this->_metrology->addLog('Create conversation error on generation', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_id = '0';
                return false;
            }
        } else {
            $this->_metrology->addLog('Create conversation error not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_id = '0';
            return false;
        }
    }



    // Désactivation des fonctions de protection et autres.

    /**
     * Vérifie la consistance de l'objet.
     *
     * Retourne toujours true pour une conversation.
     * Il n'y a pas de contenu à vérifier pour un objet de référence.
     *
     * @return boolean
     */
    public function checkConsistency()
    {
        return true;
    }

    /**
     * Fonction pour les objets, désactivée pour les conversations.
     *
     * @return boolean
     */
    public function getReloadMarkProtected()
    {
        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les conversations.
     *
     * @return string
     */
    public function getProtectedID()
    {
        return '0';
    }

    /**
     * Fonction pour les objets, désactivée pour les conversations.
     *
     * @return string
     */
    public function getUnprotectedID()
    {
        return $this->_id;
    }

    /**
     * Fonction pour les objets, désactivée pour les conversations.
     *
     * @return boolean
     */
    public function setProtected($obfuscated = false)
    {
        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les conversations.
     *
     * @return boolean
     */
    public function setUnprotected()
    {
        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les conversations.
     *
     * @param string|Entity $entity
     * @return boolean
     */
    public function setProtectedTo($entity)
    {
        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les conversations.
     *
     * @return array
     */
    public function getProtectedTo()
    {
        return array();
    }


    /**
     * Retourne si l'entité est à l'écoute du groupe.
     *
     * @param string|Node|Entity $entity
     * @param string $socialClass
     * @param array:string $socialListID
     * @return boolean
     */
    public function getIsFollower($entity, $socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que c'est bien une entité.
        if ($entity == '') {
            return false;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        // Vérifie que c'est bien une entité.
        if ($id == '') {
            return false;
        }

        // Liste tous les liens de définition des entités à l'écoutes du groupe.
        $links = $this->readLinksFilterFull(
            '',
            '',
            'l',
            $id,
            $this->_id,
            $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE)
        );

        // Fait un tri par pertinance sociale.
        $this->_social->setList($socialListID);
        $this->_social->arraySocialFilter($links, $socialClass);
        $this->_social->unsetList();

        if (sizeof($links) != 0) {
            return true;
        }
        return false;
    }

    /**
     * Ajoute une entité comme à l'écoute du groupe.
     *
     * @param string|Node $entity
     * @param boolean $obfuscated
     * @return boolean
     */
    public function setFollower($entity, $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteConversation')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        // Vérifie que c'est bien une entité.
        if ($id == '') {
            return false;
        }

        // Création lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'l';
        $source = $id;
        $target = $this->_id;
        $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE);
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        return $newLink->write();
    }

    /**
     * Retire un entité à l'écoute du groupe.
     * @todo détecter le lien dissimulé d'origine, et dissimuler en conséquence.
     *
     * @todo retirer la dissimulation déjà faite dans le code.
     *
     * @param string|Node $entity
     * @param boolean $obfuscated
     * @return boolean
     */
    public function unsetFollower($entity = '', $obfuscated = false)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que la création de liens est possible.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || !$this->_nebuleInstance->getOption('permitCreateLink')
            || !$this->_nebuleInstance->getOption('permitWriteConversation')
            || !$this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            return false;
        }

        // Si la dissimulation est activée, la force.
        if ($this->getMarkObfuscated('')) {
            $obfuscated = true;
        }

        // Extrait l'ID de l'entité.
        $id = $this->_checkExtractEntityID($entity);

        // Vérifie que c'est bien une entité.
        if ($id == '') {
            return false;
        }

        // Création lien de groupe.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $action = 'x';
        $source = $id;
        $target = $this->_id;
        $meta = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE);
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);
        $newLink->sign();

        // Si besoin, obfuscation du lien.
        if ($obfuscated) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        return $newLink->write();
    }


    /**
     * Extrait la liste des liens définissant les entités à l'écoute de la conversation.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:Link
     */
    public function getListFollowersLinks($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_getListFollowersLinks($this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE), $socialClass, $socialListID);
    }

    /**
     * Extrait la liste des ID des entités à l'écoute du groupe.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:string
     */
    public function getListFollowersID($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        // Extrait les liens des groupes.
        $links = $this->_getListFollowersLinks($this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE), $socialClass, $socialListID);

        // Extraction des ID cibles.
        $list = array();
        foreach ($links as $link) {
            $list[$link->getHashSource()] = $link->getHashSource();
        }

        return $list;
    }

    /**
     * Retourne le nombre d'entités à l'écoute du groupe.
     *
     * @param string $socialClass
     * @param array:string $socialListID
     * @return float
     */
    public function getCountFollowers($socialClass = '', $socialListID = null)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        return sizeof($this->_getListFollowersLinks($this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE), $socialClass, $socialListID));
    }

    /**
     * Retourne la liste des entités qui ont ajouté l'entité cité comme suiveuse de la conversation.
     *
     * @param string $entity
     * @param string $socialClass
     * @param array:string $socialListID
     * @return array:string
     */
    public function getListFollowerAddedByID($entity, $socialClass = 'all', $socialListID = null)
    {
        // Extrait les liens des groupes.
        $links = $this->_getListFollowersLinks($this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_SUIVIE), $socialClass, $socialListID);

        // Extraction des ID cibles.
        $list = array();
        foreach ($links as $link) {
            if ($link->getHashSource() == $entity) {
                $list[$link->getHashSigner()] = $link->getHashSigner();
            }
        }

        return $list;
    }


    /**
     * ID de référence de l'objet.
     *
     * @var string
     */
    private $_referenceObject = '';

    /**
     * Calcule et retourne la référence de l'objet.
     *
     * @return string
     */
    public function getReferenceObject()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_referenceObject == '') {
            $this->_referenceObject = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }
        return $this->_referenceObject;
    }

    /**
     * ID de référence de l'objet de fermeture.
     *
     * @var string
     */
    private $_referenceObjectClosed = '';

    /**
     * Calcule et retourne la référence de l'objet de fermeture.
     *
     * @return string
     */
    public function getReferenceObjectClosed()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_referenceObjectClosed == '') {
            $this->_referenceObjectClosed = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_FERMEE, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }
        return $this->_referenceObjectClosed;
    }

    /**
     * ID de référence de l'objet de protection des membres.
     *
     * @var string
     */
    private $_referenceObjectProtected = '';

    /**
     * Calcule et retourne la référence de l'objet de protection des membres.
     *
     * @return string
     */
    public function getReferenceObjectProtected()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_referenceObjectProtected == '') {
            $this->_referenceObjectProtected = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_PROTEGEE, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }
        return $this->_referenceObjectProtected;
    }

    /**
     * ID de référence de l'objet de dissimulation des membres.
     *
     * @var string
     */
    private $_referenceObjectObfuscated = '';

    /**
     * Calcule et retourne la référence de l'objet de dissimulation des membres.
     *
     * @return string
     */
    public function getReferenceObjectObfuscated()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . $this->_id, Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_referenceObjectObfuscated == '') {
            $this->_referenceObjectObfuscated = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_CONVERSATION_DISSIMULEE, nebule::REFERENCE_CRYPTO_HASH_ALGORITHM);
        }
        return $this->_referenceObjectObfuscated;
    }


    /**
     * Affiche la partie menu de la documentation.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#oc">OC / Conversation</a>
            <ul>
                <li><a href="#oco">OCO / Objet</a></li>
                <li><a href="#ocn">OCN / Nommage</a></li>
                <li><a href="#ocp">OCP / Protection</a></li>
                <li><a href="#ocd">OCD / Dissimulation</a></li>
                <li><a href="#ocf">OCF / Fermeture</a></li>
                <li><a href="#ocpm">OCPM / Protection des membres</a></li>
                <li><a href="#ocdm">OCDM / Dissimulation des membres</a></li>
                <li><a href="#ocl">OCL / Liens</a></li>
                <li><a href="#occ">OCC / Création</a></li>
                <li><a href="#ocs">OCS / Stockage</a></li>
                <li><a href="#oct">OCT / Transfert</a></li>
                <li><a href="#ocr">OCR / Réservation</a></li>
                <li><a href="#ocio">OCIO / Implémentation des Options</a></li>
                <li><a href="#ocia">OCIA / Implémentation des Actions</a></li>
            </ul>
        </li>

        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h2 id="oc">OC / Conversation</h2>
        <p>La conversation est un objet définit comme tel, c’est à dire qu’il doit avoir un type mime <code>nebule/objet/conversation</code>.
        </p>
        <p>Fondamentalement, la conversation est un groupe de plusieurs objets et est donc géré de la même façon qu'un
            groupe. Ainsi, un membre de la conversation n'est pas une entité mais un message, une entité est dite entité
            contributrice. Certains liens générés sont communs avec ceux des groupes et si un objet est marqué comme
            groupe et conversation, ses membres seront les mêmes.</p>
        <p>La conversation va permettre de regrouper, et donc d’associer et de retrouver, des message. L’objet de la
            conversation va avoir des liens vers d’autres objets afin de les définir comme messages (membres) de la
            conversation.</p>
        <p>Une conversation peut avoir des liens de membres vers des objets définis aussi comme conversations. Ces
            objets peuvent être vus comme des sous-conversations. La bibliothèque <em>nebule</em> ne prend en compte
            qu’un seul niveau de conversation, c’est à dire que les sous-conversations sont gérés simplement comme des
            objets.</p>

        <h3 id="oco">OCO / Objet</h3>
        <p>L’objet de la conversation peut être de deux natures.</p>
        <p>Soit c’est un objet existant qui est en plus définit comme une conversation. L’objet peut avoir un contenu et
            a sûrement d’autres types mime propres. Dans ce cas l’identifiant de conversation est l’identifiant de
            l’objet utilisé.</p>
        <p>Soit c’est un objet dit virtuel qui n’a pas et n’aura jamais de contenu. Cela n’empêche pas qu’il puisse
            avoir d’autres types mime. Dans ce cas l’identifiant de conversation a une forme commune aux objets
            virtuels.</p>
        <p>La création d’un objet virtuel comme conversation se fait en créant pour identifiant la concaténation d’un
            hash (<em>sha256</em>) d’une valeur aléatoire de 128bits et de la chaîne <code>006e6562756c652f6f626a65742f636f6e766572736174696f6e</code>.
            Soit un identifiant complet de la taille de 116 caractères.</p>

        <h3 id="ocn">OCN / Nommage</h3>
        <p>Le nommage à l’affichage du nom des conversations repose sur une seule propriété :</p>
        <ol>
            <li>nom</li>
        </ol>
        <p>Cette propriété est matérialisée par un lien de type <code>l</code> avec comme objets méta :</p>
        <ol>
            <li><code>nebule/objet/nom</code></li>
        </ol>
        <p>Par convention, voici le nommage des conversations :</p>
        <ul>
            <li><code>nom</code></li>
        </ul>

        <h3 id="ocp">OCP / Protection</h3>
        <p>En tant que tel la conversation ne nécessite pas de protection puisque soit l’objet de la conversation n’a
            pas de contenu soit on n’utilise pas son contenu directement.</p>
        <p>La gestion de la protection est désactivée dans une instance de conversation.</p>

        <h3 id="ocd">OCD / Dissimulation</h3>
        <p>La conversation peut en tant que tel être dissimulée, c’est à dire que l’on dissimule l’existence de la
            conversation, donc sa création.</p>
        <p>La dissimulation devrait se faire lors de la création de la conversation.</p>
        <p>L’annulation de la dissimulation d’une conversation revient à révéler le lien de création de la
            conversation.</p>
        <p>La dissimulation peut se (re)faire après la création de la conversation mais son efficacité est incertaine si
            les liens de création ont déjà été diffusés. En cas de dissimulation à posteriori, il faut générer un lien
            de suppression de la conversation puis générer un nouveau lien dissimulée de création de la conversation à
            une date postérieure au lien de suppression.</p>

        <h3 id="ocf">OCF / Fermeture</h3>
        <p>La conversation va contenir un certain nombre de membres (messages) ajouter par différentes entités. Il est
            possible de limiter le nombre des membres à utiliser dans une conversation en restreignant artificiellement
            les entités contributrices de la conversation. Ainsi on marque la conversation comme fermée et on filtre sur
            les membres uniquement ajoutés par des entités définies.</p>
        <p>Dans nebule, l’objet réservé <code>nebule/objet/conversation/fermee</code> est dédié à la gestion des
            conversations fermées. Une conversation est considéré fermée quand on a l’objet réservé en champs méta,
            l’entité en cours en champs cible et l’ID de la conversation en champs source. Si au lieu d’utiliser
            l’entité en cours pour le champs cible on utilise une autre entité, cela revient à prendre aussi en compte
            ses liens dans la conversation fermée. Dans ce cas c’est une entité contributrice.</p>
        <p>C’est uniquement un affichage de la conversation que l’on a et non la suppression de membres de la
            conversation.</p>
        <p>Lorsque l’on a marqué une conversation comme fermée, on doit explicitement ajouter des entités que l’on veut
            voir contribuer.</p>
        <p>Il est possible indéfiniment de fermer et ouvrir une conversation.</p>
        <p>Il est possible de fermer une conversation qui ne nous appartient afin par exemple de la rendre plus
            lisible.</p>
        <p>Lorsque l’on a marqué une conversation comme fermée, on peut voir la liste des entités explicitement que l’on
            veut voir contribuer. On peut aussi voir les entités que les autres entités veulent voir contribuer et
            décider ou non de les ajouter.</p>
        <p>Lorsqu’une conversation est marqué comme fermée, l’interface de visualisation de la conversation peut
            permettre de la visualiser temporairement comme une conversation ouvert.</p>
        <p>Le traitement des liens de fermeture d’une conversation doit être fait exclusivement avec le traitement
            social <em>self</em>.</p>

        <h4 id="ocpm">OCPM / Protection des membres</h4>
        <p>La conversation va contenir un certain nombre de membres (messages) ajouter par différentes entités. Il est
            possible de limiter la visibilité du contenu des membres utilisés dans une conversation en restreignant
            artificiellement les entités destinataires qui pourront les consulter.</p>
        <p>Dans nebule, l’objet réservé <code>nebule/objet/conversation/protegee</code> est dédié à la gestion des
            conversations protégées. Une conversation est considéré protégée quand on a l’objet réservé en champs méta,
            l’entité en cours en champs cible et l’ID de la conversation en champs source. Si au lieu d’utiliser
            l’entité en cours pour le champs cible on utilise une autre entité, cela revient à partager aussi les objets
            protégées créés pour cette conversation. Cela ne repartage pas la protection des objets déjà protégés.</p>
        <p>Dans une conversation marqué protégée, tous les nouveaux membres ajoutés à la conversation ont leur contenu
            protégé. Ce n’est valable que pour l’entité en cours et éventuellement celles qui lui font confiance.</p>
        <p>Lorsque l’on a marqué une conversation comme protégée, on doit explicitement ajouter des entités avec qui on
            veut partager les contenus.</p>
        <p>Il est possible indéfiniment de protéger et déprotéger une conversation.</p>
        <p>Il est possible de protéger une conversation qui ne nous appartient afin de masquer le contenu des membres
            que l’on y ajoute.</p>
        <p>Lorsque l’on a marqué une conversation comme protégée, on peut voir la liste des entités explicitement a qui
            on veut partager les contenus. On peut aussi voir les entités a qui les autres entités veulent partager les
            contenus et décider ou non de les ajouter.</p>
        <p>Le traitement des liens de protection d’une conversation doit être fait exclusivement avec le traitement
            social <em>self</em>.</p>

        <h4 id="ocdm">OCDM / Dissimulation des membres</h4>
        <p>La conversation va contenir un certain nombre de membres (messages) ajouter par différentes entités. Il est
            possible de limiter la visibilité de l’appartenance des membres utilisés dans une conversation en
            restreignant artificiellement les entités destinataires qui pourront les voir.</p>
        <p>Dans nebule, l’objet réservé <code>nebule/objet/conversation/dissimulee</code> est dédié à la gestion des
            conversations dissimulées. Une conversation est considéré dissimulée quand on a l’objet réservé en champs
            méta, l’entité en cours en champs cible et l’ID de la conversation en champs source. Si au lieu d’utiliser
            l’entité en cours pour le champs cible on utilise une autre entité, cela revient à partager aussi les objets
            dissimulées créés pour cette conversation. Cela ne repartage pas la dissimulation des objets déjà
            dissimulés.</p>
        <p>Dans une conversation marqué dissimulée, tous les nouveaux membres ajoutés à la conversation sont dissimulés.
            Ce n’est valable que pour l’entité en cours et éventuellement celles qui lui font confiance.</p>
        <p>Lorsque l’on a marqué une conversation comme dissimulée, on doit explicitement ajouter des entités avec qui
            on veut partager les membres de la conversation.</p>
        <p>Il est possible indéfiniment de dissimuler et dé-dissimuler une conversation.</p>
        <p>Il est possible de dissimuler une conversation qui ne nous appartient afin de masquer le contenu des membres
            que l’on y ajoute.</p>
        <p>Lorsque l’on a marqué une conversation comme dissimulée, on peut voir la liste des entités explicitement a
            qui on veut partager les contenus. On peut aussi voir les entités a qui les autres entités veulent partager
            les contenus et décider ou non de les ajouter.</p>
        <p>Le traitement des liens de dissimulation d’une conversation doit être fait exclusivement avec le traitement
            social <em>self</em>.</p>

        <h3 id="ocl">OCL / Liens</h3>
        <p>Une entité doit être déverrouillée pour la création de liens.</p>
        <ul>
            <li>Le lien de définition de la conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : hash(‘nebule/objet/conversation’)</li>
                    <li>méta : hash(‘nebule/objet/type’)</li>
                </ul>
            </li>
            <li>Le lien de suppression d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : hash(‘nebule/objet/conversation’)</li>
                    <li>méta : hash(‘nebule/objet/type’)</li>
                </ul>
            </li>
            <li>Le lien de suivi de la conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de l'entité, par défaut l’entité signataire</li>
                    <li>cible : ID de la conversation</li>
                    <li>méta : hash(‘nebule/objet/conversation/suivie’)</li>
                </ul>
            </li>
            <li>Le lien de suppression de suivi de la conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID de l'entité, par défaut l’entité signataire</li>
                    <li>cible : ID de la conversation</li>
                    <li>méta : hash(‘nebule/objet/conversation/suivie’)</li>
                </ul>
            </li>
            <li>Le lien de dissimulation d’une conversation est le lien de définition caché dans une lien de type <code>c</code>.
            </li>
            <li>Le lien de rattachement d’un membre (message) de la conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’objet</li>
                    <li>méta : ID de la conversation</li>
                </ul>
            </li>
            <li>Le lien de suppression de rattachement d’un membre (message) de la conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’objet</li>
                    <li>méta : ID de la conversation</li>
                </ul>
            </li>
            <li>Le lien de fermeture d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire.</li>
                    <li>méta : hash(‘nebule/objet/conversation/fermee’)</li>
                </ul>
            </li>
            <li>Le lien de suppression de fermeture d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire.</li>
                    <li>méta : hash(‘nebule/objet/conversation/fermee’)</li>
                </ul>
            </li>
            <li>Le lien de protection des membres d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire.</li>
                    <li>méta : hash(‘nebule/objet/conversation/protegee’)</li>
                </ul>
            </li>
            <li>Le lien de suppression de protection des membres d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire.</li>
                    <li>méta : hash(‘nebule/objet/conversation/protegee’)</li>
                </ul>
            </li>
            <li>Le lien de dissimulation des membres d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire.</li>
                    <li>méta : hash(‘nebule/objet/conversation/dissimulee’)</li>
                </ul>
            </li>
            <li>Le lien de suppression de dissimulation des membres d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>x</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire.</li>
                    <li>méta : hash(‘nebule/objet/conversation/dissimulee’)</li>
                </ul>
            </li>
        </ul>

        <h3 id="occ">OCC / Création</h3>
        <p>Liste des liens à générer lors de la création d'une conversation :</p>
        <ul>
            <li>Le lien de définition de la conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : hash(‘nebule/objet/conversation’)</li>
                    <li>méta : hash(‘nebule/objet/type’)</li>
                </ul>
            </li>
            <li>Le lien de nommage de la conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : hash(nom de la conversation)</li>
                    <li>méta : hash(‘nebule/objet/nom’)</li>
                </ul>
            </li>
            <li>Le lien de suivi de la conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de l'entité, par défaut l’entité signataire</li>
                    <li>cible : ID de la conversation</li>
                    <li>méta : hash(‘nebule/objet/conversation/suivie’)</li>
                </ul>
            </li>
        </ul>
        <p>On peut aussi au besoin ajouter ces liens :</p>
        <ul>
            <li>Le lien de fermeture d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/conversation/ferme’)</li>
                </ul>
            </li>
            <li>Le lien de protection des membres d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/conversation/protege’)</li>
                </ul>
            </li>
            <li>Le lien de dissimulation des membres d’une conversation :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de la conversation</li>
                    <li>cible : ID de l’entité, par défaut l’entité signataire</li>
                    <li>méta : hash(‘nebule/objet/conversation/dissimule’)</li>
                </ul>
            </li>
        </ul>

        <h3 id="ocs">OCS / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="oct">OCT / Transfert</h3>
        <p>A faire...</p>

        <h3 id="ocr">OCR / Réservation</h3>
        <p>Les objets réservés spécifiquement pour les conversations :</p>
        <ul>
            <li>nebule/objet/conversation</li>
            <li>nebule/objet/conversation/fermee</li>
            <li>nebule/objet/conversation/protegee</li>
            <li>nebule/objet/conversation/dissimulee</li>
        </ul>

        <h4 id="ocio">OCIO / Implémentation des Options</h4>
        <p>Les options spécifiques aux conversations :</p>
        <ul>
            <li><code>permitWriteConversation</code> : permet toute écriture de conversations.</li>
        </ul>
        <p>Les options qui ont une influence sur les conversations :</p>
        <ul>
            <li><code>permitWrite</code> : permet toute écriture d’objets et de liens ;</li>
            <li><code>permitWriteObject</code> : permet toute écriture d’objets ;</li>
            <li><code>permitCreateObject</code> : permet la création locale d’objets ;</li>
            <li><code>permitWriteLink</code> : permet toute écriture de liens ;</li>
            <li><code>permitCreateLink</code> : permet la création locale de liens.</li>
        </ul>
        <p>Il est nécessaire à la création d’une conversation de pouvoir écrire des objets comme le nom de la
            conversation, même si l’objet de la conversation ne sera pas créé.</p>

        <h4 id="ocia">OCIA / Implémentation des Actions</h4>
        <p>Dans les actions, on retrouve les chaînes :</p>
        <ul>
            <li><code>creagrp</code> : Crée une conversation.</li>
            <li><code>creagrpnam</code> : Nomme la conversation à créer.</li>
            <li><code>creagrpcld</code> : Marque fermée la conversation à créer.</li>
            <li><code>creagrpobf</code> : Dissimule les liens de la conversation à créer.</li>
            <li><code>actdelgrp</code> : Supprime une conversation.</li>
            <li><code>actaddtogrp</code> : Ajoute l’objet courant membre à conversation.</li>
            <li><code>actremtogrp</code> : Retire l’objet courant membre d’une conversation.</li>
            <li><code>actadditogrp</code> : Ajoute un objet membre à la conversation courant.</li>
            <li><code>actremitogrp</code> : Retire un objet membre de la conversation courant.</li>
        </ul>

        <?php
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Currency.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID d'une monnaie ou 'new' ;
 * - un tableau des paramètres de la nouvelle monnaie.
 *
 * L'ID d'une monnaie est forcément un texte en hexadécimal.
 *
 * Si une erreur survient lors de la lecture de la monnaie ou lors de la création, assigne l'ID 0.
 * ------------------------------------------------------------------------------------------
 */
class Currency extends Node
{
    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_id',
        '_fullname',
        '_cachePropertyLink',
        '_cachePropertiesLinks',
        '_cachePropertyID',
        '_cachePropertiesID',
        '_cacheProperty',
        '_cacheProperties',
        '_cacheMarkDanger',
        '_cacheMarkWarning',
        '_cacheMarkProtected',
        '_idProtected',
        '_idUnprotected',
        '_idProtectedKey',
        '_idUnprotectedKey',
        '_markProtectedChecked',
        '_cacheCurrentEntityUnlocked',
        '_usedUpdate',
        '_isEntity',
        '_isGroup',
        '_isConversation',
        '_isCurrency',
        '_isTokenPool',
        '_isToken',
        '_isWallet',
        '_isTransaction',
        '_properties',
        '_propertiesInherited',
        '_propertiesForced',
        '_seed',
        '_inheritedCID',
        '_inheritedPID',
    );

    /**
     * Tableau des propriétés de la monnaie.
     * @var array
     */
    protected $_properties = array();

    /**
     * Tableau des propriétés héritées.
     * @var array
     */
    protected $_propertiesInherited = array();

    /**
     * Tableau des propriétés forcées.
     * @var array
     */
    protected $_propertiesForced = array();

    /**
     * Tableau des noms des propriétés disponibles.
     *
     * Le premier niveau définit les différentes catégories d'objets.
     *
     * Le second niveau nomme la propriété en interne et dispose de sous-propriétés :
     * - key : le nom publique de la clé pour l'objet.
     * - shortname : le nom de la clé pour les échangent en HTML, sans ambiguité par rapport au type d'objet.
     * - type : typage de la valeur attendu.
     * - info : le code de renvoi dans la page de documentation.
     * - force : valeur forcée dans le code, donc non modifiable lors de la création de l'objet.
     * - forceable : la clé:valeur peut être forcée dans l'objet généré. Sinon la valeur peut être surchargée par un lien.
     * - inherite : la valeur est hérité et n'est pas écrite.
     * - calculate : valeur calculée à postériori. Si présent, est équivalent à true.
     * - multivalue : clé à valeurs multiples séparées par des espaces. Si présent, est équivalent à true.
     * - limit : limit de la valeur attendu. Utilisé par les filtres de netoyage des valeurs.
     * - meta : l'objet à utiliser en temps que meta pour les liens.
     * - display : la taille du champs à utiliser pour la saisie de la valeur, non limitatif sur la taille de la valeur saisie.
     * - select : réduit le nombre de réponses possibles via un menu déroulant de taille fixe. Une seule réponse peut être sélectionnée.
     * - checkbox : permet une sélection multiple sur une liste. La valeur manipulée est une chaîne séparée par des espaces.
     *
     * @var array
     */
    protected $_propertiesList = array(
        'currency' => array(
            'CurrencyHaveContent' => array('key' => 'HCT', 'shortname' => 'chct', 'type' => 'boolean', 'info' => 'omcphct', 'force' => 'true',),
            'CurrencyType' => array('key' => 'TYP', 'shortname' => 'ctyp', 'type' => 'string', 'info' => 'omcptyp', 'limit' => '32', 'display' => '16', 'force' => 'cryptocurrency',),
            'CurrencySerialID' => array('key' => 'SID', 'shortname' => 'csid', 'type' => 'hexadecimal', 'info' => 'omcpsid', 'limit' => '1024', 'display' => '64',),
            'CurrencyCapacities' => array('key' => 'CAP', 'shortname' => 'ccap', 'type' => 'string', 'info' => 'omcpcap', 'limit' => '1024', 'display' => '128', 'force' => 'TYP MOD SID CAP AID MID NAM UNI DTA DTC DTD COM CPR IDM IDR IDP VMD VID TRS CID PID FID BID VAL CLB CLD SVC TID', 'multivalue' => true,),
            'CurrencyExploitationMode' => array('key' => 'MOD', 'shortname' => 'cmod', 'type' => 'string', 'info' => 'omcpmod', 'limit' => '3', 'display' => '10', 'force' => 'CTL',),
            'CurrencyAutorityID' => array('key' => 'AID', 'shortname' => 'caid', 'type' => 'hexadecimal', 'info' => 'omcpaid', 'limit' => '1024', 'display' => '64', 'force' => '',),
            'CurrencyCurrencyName' => array('key' => 'NAM', 'shortname' => 'cnam', 'type' => 'string', 'info' => 'omcpnam', 'limit' => '256', 'display' => '32', 'forceable' => true,),
            'CurrencyCurrencyUnit' => array('key' => 'UNI', 'shortname' => 'cuni', 'type' => 'string', 'info' => 'omcpuni', 'limit' => '3', 'display' => '6', 'forceable' => true,),
            'CurrencyDateAuthorityID' => array('key' => 'DTA', 'shortname' => 'cdta', 'type' => 'hexadecimal', 'info' => 'omcpdta', 'limit' => '1024', 'display' => '64', 'forceable' => true,),
            'CurrencyDateCreate' => array('key' => 'DTC', 'shortname' => 'cdtc', 'type' => 'date', 'info' => 'omcpdtc', 'display' => '32', 'forceable' => true,),
            'CurrencyDateDelete' => array('key' => 'DTD', 'shortname' => 'cdtd', 'type' => 'date', 'info' => 'omcpdtd', 'display' => '32', 'forceable' => true,),
            'CurrencyComment' => array('key' => 'COM', 'shortname' => 'ccom', 'type' => 'string', 'info' => 'omcpcom', 'limit' => '4096', 'display' => '128', 'forceable' => true,),
            'CurrencyCopyright' => array('key' => 'CPR', 'shortname' => 'ccpr', 'type' => 'string', 'info' => 'omcpcpr', 'limit' => '1024', 'display' => '128', 'forceable' => true,),
            'CurrencyInflateMode' => array('key' => 'IDM', 'shortname' => 'cidm', 'type' => 'string', 'info' => 'omcpidm', 'limit' => '10', 'display' => '12', 'forceable' => true, 'select' => array('disabled', 'creation', 'transaction'),),
            'CurrencyInflateRate' => array('key' => 'IDR', 'shortname' => 'cidr', 'type' => 'number', 'info' => 'omcpidr', 'limit' => '2', 'display' => '10', 'forceable' => true,),
            'CurrencyInflatePeriod' => array('key' => 'IDP', 'shortname' => 'cidp', 'type' => 'number', 'info' => 'omcpidp', 'limit' => '1048576', 'display' => '10', 'forceable' => true,),
            'CurrencyValidationMode' => array('key' => 'VMD', 'shortname' => 'cvmd', 'type' => 'string', 'info' => 'omcpvmd', 'limit' => '10', 'display' => '12', 'forceable' => true, 'select' => array('central'),),
            'CurrencyValidationID' => array('key' => 'VID', 'shortname' => 'cvid', 'type' => 'hexadecimal', 'info' => 'omcpvid', 'limit' => '1024', 'display' => '64', 'forceable' => true, 'multivalue' => true,),
            'CurrencyManageID' => array('key' => 'MID', 'shortname' => 'cmid', 'type' => 'hexadecimal', 'info' => 'omcpmid', 'limit' => '1024', 'display' => '64', 'forceable' => true, 'checkbox' => '', 'multivalue' => true,),
            'CurrencyTransacMethods' => array('key' => 'TRS', 'shortname' => 'ctrs', 'type' => 'string', 'info' => 'omcptrs', 'limit' => '1024', 'display' => '128', 'force' => 'LNS', 'multivalue' => true,),
            'CurrencyID' => array('key' => 'CID', 'shortname' => 'ccid', 'type' => 'hexadecimal', 'info' => 'omcpcid', 'limit' => '1024', 'display' => '64', 'calculate' => true,),
        ),
        'tokenpool' => array(
            'PoolHaveContent' => array('key' => 'HCT', 'shortname' => 'phct', 'type' => 'boolean', 'info' => 'omgcphct', 'force' => 'true',),
            'PoolType' => array('key' => 'TYP', 'shortname' => 'ptyp', 'type' => 'string', 'info' => 'omgcptyp', 'limit' => '32', 'display' => '16', 'force' => 'tokenpool',),
            'PoolSerialID' => array('key' => 'SID', 'shortname' => 'psid', 'type' => 'hexadecimal', 'info' => 'omgcpsid', 'limit' => '1024', 'display' => '64',),
            'PoolCapacities' => array('key' => 'CAP', 'shortname' => 'pcap', 'type' => 'string', 'info' => 'omgcpcap', 'display' => '128', 'inherite' => 'currency', 'multivalue' => true,),
            'PoolCurrencyID' => array('key' => 'CID', 'shortname' => 'pcid', 'type' => 'hexadecimal', 'info' => 'omgcpcid', 'limit' => '1024', 'display' => '64', 'force' => '',),
            'PoolForgeID' => array('key' => 'FID', 'shortname' => 'pfid', 'type' => 'hexadecimal', 'info' => 'omgcpfid', 'limit' => '1024', 'display' => '64', 'force' => '',),
            'PoolDateAuthorityID' => array('key' => 'DTA', 'shortname' => 'pdta', 'type' => 'hexadecimal', 'info' => 'omgcpdta', 'display' => '64', 'inherite' => 'currency',),
            'PoolDateCreate' => array('key' => 'DTC', 'shortname' => 'pdtc', 'type' => 'date', 'info' => 'omgcpdtc', 'display' => '32', 'forceable' => true,),
            'PoolDateDelete' => array('key' => 'DTD', 'shortname' => 'pdtd', 'type' => 'date', 'info' => 'omgcpdtd', 'display' => '32', 'forceable' => true,),
            'PoolComment' => array('key' => 'COM', 'shortname' => 'pcom', 'type' => 'string', 'info' => 'omgcpcom', 'limit' => '4096', 'display' => '128', 'forceable' => true,),
            'PoolCopyright' => array('key' => 'CPR', 'shortname' => 'pcpr', 'type' => 'string', 'info' => 'omgcpcpr', 'limit' => '1024', 'display' => '128', 'forceable' => true,),
            'PoolManageID' => array('key' => 'MID', 'shortname' => 'pmid', 'type' => 'hexadecimal', 'info' => 'omgcpmid', 'limit' => '1024', 'display' => '64', 'forceable' => true, 'checkbox' => '', 'multivalue' => true,),
            'PoolID' => array('key' => 'PID', 'shortname' => 'ppid', 'type' => 'hexadecimal', 'info' => 'omgcppid', 'limit' => '1024', 'display' => '64', 'calculate' => true,),
        ),
        'token' => array(
            'TokenHaveContent' => array('key' => 'HCT', 'shortname' => 'thct', 'type' => 'boolean', 'info' => 'omjcphct', 'force' => 'true',),
            'TokenType' => array('key' => 'TYP', 'shortname' => 'ttyp', 'type' => 'string', 'info' => 'omjcptyp', 'limit' => '32', 'display' => '16', 'force' => 'cryptoken',),
            'TokenSerialID' => array('key' => 'SID', 'shortname' => 'tsid', 'type' => 'hexadecimal', 'info' => 'omjcpsid', 'limit' => '1024', 'display' => '64',),
            'TokenCapacities' => array('key' => 'CAP', 'shortname' => 'tcap', 'type' => 'string', 'info' => 'omjcpcap', 'display' => '128', 'inherite' => 'currency', 'multivalue' => true,),
            'TokenCurrencyID' => array('key' => 'CID', 'shortname' => 'tcid', 'type' => 'hexadecimal', 'info' => 'omjcpcid', 'limit' => '1024', 'display' => '64', 'force' => '',),
            'TokenForgeID' => array('key' => 'FID', 'shortname' => 'tfid', 'type' => 'hexadecimal', 'info' => 'omjcpfid', 'limit' => '1024', 'display' => '64', 'force' => '',),
            'TokenPoolID' => array('key' => 'PID', 'shortname' => 'tpid', 'type' => 'hexadecimal', 'info' => 'omjcppid', 'limit' => '1024', 'display' => '64', 'inherite' => 'pool',),
            'TokenBlockID' => array('key' => 'BID', 'shortname' => 'tbid', 'type' => 'hexadecimal', 'info' => 'omjcpbid', 'limit' => '1024', 'display' => '64', 'forceable' => true,),
            'TokenCurrencyName' => array('key' => 'NAM', 'shortname' => 'tnam', 'type' => 'string', 'info' => 'omjcpnam', 'display' => '32', 'inherite' => 'currency',),
            'TokenCurrencyUnit' => array('key' => 'UNI', 'shortname' => 'tuni', 'type' => 'string', 'info' => 'omjcpuni', 'display' => '6', 'inherite' => 'currency',),
            'TokenValue' => array('key' => 'VAL', 'shortname' => 'tval', 'type' => 'number', 'info' => 'omjcpval', 'limit' => '1048576', 'display' => '10', 'forceable' => true,),
            'TokenService' => array('key' => 'SVC', 'shortname' => 'tsvc', 'type' => 'string', 'info' => 'omjcpsvc', 'limit' => '1024', 'display' => '128', 'forceable' => true,),
            'TokenDateAuthorityID' => array('key' => 'DTA', 'shortname' => 'tdta', 'type' => 'hexadecimal', 'info' => 'omjcpdta', 'display' => '64', 'inherite' => 'currency',),
            'TokenDateCreate' => array('key' => 'DTC', 'shortname' => 'tdtc', 'type' => 'date', 'info' => 'omjcpdtc', 'display' => '32', 'forceable' => true,),
            'TokenDateDelete' => array('key' => 'DTD', 'shortname' => 'tdtd', 'type' => 'date', 'info' => 'omjcpdtd', 'display' => '32', 'forceable' => true,),
            'TokenComment' => array('key' => 'COM', 'shortname' => 'tcom', 'type' => 'string', 'info' => 'omjcpcom', 'limit' => '4096', 'display' => '128', 'forceable' => true,),
            'TokenCopyright' => array('key' => 'CPR', 'shortname' => 'tcpr', 'type' => 'string', 'info' => 'omjcpcpr', 'limit' => '1024', 'display' => '128', 'forceable' => true,),
            'TokenInflateMode' => array('key' => 'IDM', 'shortname' => 'tidm', 'type' => 'string', 'info' => 'omjcpidm', 'display' => '12', 'inherite' => 'currency',),
            'TokenInflateRate' => array('key' => 'IDR', 'shortname' => 'tidr', 'type' => 'number', 'info' => 'omjcpidr', 'display' => '10', 'inherite' => 'currency',),
            'TokenInflatePeriod' => array('key' => 'IDP', 'shortname' => 'tidp', 'type' => 'number', 'info' => 'omjcpidp', 'display' => '10', 'inherite' => 'currency',),
            'TokenCancelable' => array('key' => 'CLB', 'shortname' => 'tclb', 'type' => 'boolean', 'info' => 'omjcpclb', 'forceable' => true,),
            'TokenCanceled' => array('key' => 'CLD', 'shortname' => 'tcld', 'type' => 'boolean', 'info' => 'omjcpcld', 'force' => 'false',),
            'TokenTransacMethods' => array('key' => 'TRS', 'shortname' => 'ttrs', 'type' => 'string', 'info' => 'omjcptrs', 'display' => '128', 'inherite' => 'currency', 'multivalue' => true,),
            'TokenID' => array('key' => 'TID', 'shortname' => 'ttid', 'type' => 'hexadecimal', 'info' => 'omjcptid', 'limit' => '1024', 'display' => '64', 'calculate' => true,),
        ),
    );

    /**
     * Compteur interne de génération de l'aléa.
     *
     * @var string
     */
    protected $_seed = '';

    /**
     * Instance de la monnaie dont dépend l'instance.
     * N'est pas utilisé pour une monnaie.
     *
     * @var Currency
     */
    protected $_inheritedCID = null;

    /**
     * Instance de la monnaie dont dépend l'instance.
     * N'est pas utilisé pour une monnaie.
     *
     * @var TokenPool
     */
    protected $_inheritedPID = null;

    /**
     * Tableau des capacités reconnues de la monnaie.
     *
     * @var array:string
     */
    protected $_CAParray = array();

    /**
     * Constructeur.
     *
     * Toujours transmettre l'instance de la librairie nebule.
     * Si la monnaie existe, juste préciser l'ID de celle-ci.
     * Si c'est une nouvelle monnaie à créer, mettre l'ID à 'new'.
     *
     * @param nebule $nebuleInstance
     * @param string $id
     * @param array $param si $id == 'new'
     * @param boolean $protected si $id == 'new'
     * @param boolean $obfuscated si $id == 'new'
     */
    public function __construct(nebule $nebuleInstance, $id, $param = array(), $protected = false, $obfuscated = false)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();

        $id = trim(strtolower($id));
        $this->_metrology->addLog('New instance currency ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.

        if (is_string($id)
            && $id != ''
            && ctype_xdigit($id)
        ) {
            // Si l'ID est cohérent et l'objet nebule présent, c'est bon.
            $this->_loadCurrency($id);
        } elseif (is_string($id)
            && $id == 'new'
        ) {
            // Si c'est une nouvelle monnaie à créer, renvoie à la création.
            $this->_createNewCurrency($param, $protected, $obfuscated);
        } else {
            // Sinon, la monnaie est invalide, retourne 0.
            $this->_id = '0';
        }
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->_id;
    }

    /**
     * Retourne les variables à sauvegarder dans la session php lors d'une mise en sommeil de l'instance.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return self::SESSION_SAVED_VARS;
    }

    /**
     * Foncion de réveil de l'instance et de ré-initialisation de certaines variables non sauvegardées.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();
        $this->_cacheMarkDanger = false;
        $this->_cacheMarkWarning = false;
        $this->_cacheUpdate = '';

        // Complément des paramètres.
//		$this->_propertiesList['currency']['CurrencyAutorityID']['force'] = $this->_nebuleInstance->getCurrentEntity();
    }

    /**
     *  Chargement d'une monnaie existant.
     *
     * @param string $id
     */
    private function _loadCurrency($id)
    {
        // Vérifie que c'est bien un objet.
        if (!is_string($id)
            || $id == ''
            || !ctype_xdigit($id)
            || !$this->_io->checkLinkPresent($id)
            || !$this->_nebuleInstance->getOption('permitCurrency')
        ) {
            $id = '0';
        }

        $this->_id = $id;
        $this->_metrology->addLog('Load currency ' . $id, Metrology::LOG_LEVEL_DEBUG); // Log

        // On ne recherche pas les paramètres si ce n'est pas une monnaie.
        if ($this->getIsCurrency('myself')) {
            $this->setAID();
            $this->setFID('0');
        }

        // Vérifie la monnaie.
        $TYP = $this->_getParamFromObject('TYP', (int)$this->_propertiesList['currency']['CurrencyType']['limit']);
        $SID = $this->_getParamFromObject('SID', (int)$this->_propertiesList['currency']['CurrencySerialID']['limit']);
        $CAP = $this->_getParamFromObject('CAP', (int)$this->_propertiesList['currency']['CurrencyCapacities']['limit']);
        $MOD = $this->_getParamFromObject('MOD', (int)$this->_propertiesList['currency']['CurrencyExploitationMode']['limit']);
        $AID = $this->_getParamFromObject('AID', (int)$this->_propertiesList['currency']['CurrencyAutorityID']['limit']);
        if ($TYP == ''
            || $SID == ''
            || $CAP == ''
            || $MOD == ''
            || $AID == ''
        ) {
            $this->_id = '0';
        } else {
            $this->_propertiesList['currency']['CurrencyID']['force'] = $id;
            $this->_properties['CID'] = $id;
        }
        $this->_propertiesForced['TYP'] = true;
        $this->_propertiesForced['SID'] = true;
        $this->_propertiesForced['CAP'] = true;
        $this->_propertiesForced['MOD'] = true;
        $this->_propertiesForced['AID'] = true;
        $this->_propertiesForced['CID'] = true;
    }

    /**
     * Création d'une nouvelle monnaie.
     *
     * @param array $param
     * @return boolean
     */
    private function _createNewCurrency($param, $protected = false, $obfuscated = false)
    {
        $this->_metrology->addLog('Ask create currency', Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie que l'on puisse créer une monnaie.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCurrency')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            // Génère la nouvelle monnaie.
            $this->_id = $this->_createCurrency($param, $protected, $obfuscated);

            // Si la génération s'est mal passée.
            if ($this->_id == '0') {
                $this->_metrology->addLog('Create currency error on generation', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_id = '0';
                return false;
            }
        } else {
            $this->_metrology->addLog('Create currency error not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_id = '0';
            return false;
        }
    }



    // Désactivation des fonctions de protection et autres.

    /**
     * Fonction pour les objets, désactivée pour les monnaies.
     *
     * @return boolean
     */
    public function getReloadMarkProtected()
    {
        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les monnaies.
     *
     * @return string
     */
    public function getProtectedID()
    {
        return '0';
    }

    /**
     * Fonction pour les objets, désactivée pour les monnaies.
     *
     * @return string
     */
    public function getUnprotectedID()
    {
        return $this->_id;
    }

    /**
     * Fonction pour les objets, désactivée pour les monnaies.
     *
     * @return boolean
     */
    public function setProtected($obfuscated = false)
    {
        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les monnaies.
     *
     * @return boolean
     */
    public function setUnprotected()
    {
        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les monnaies.
     *
     * @param string|Entity $entity
     * @return boolean
     */
    public function setProtectedTo($entity)
    {
        return false;
    }

    /**
     * Fonction pour les objets, désactivée pour les monnaies.
     *
     * @return array
     */
    public function getProtectedTo()
    {
        return array();
    }


    /**
     * Nettoye la table des paramètres en entrée avant exploitation.
     *
     * @param array $param
     * @return void
     * @todo faire le forcage de valeurs.
     *
     * array( 'currency' => array(
     * ...,
     * 'CurrencyType' => array(
     * 'key' => 'TYP',
     * 'shortname' => 'ctyp',
     * 'type' => 'string',
     * 'info' => 'omcptyp',
     * 'limit' => '32',
     * 'force' => 'cryptocurrency', ),
     * 'display' => '64',
     * 'forceable' => true,
     * ...,
     * ),
     * ...,
     * )
     *
     */
    protected function _normalizeInputParam(&$param)
    {
        foreach ($param as $key => $value) {
            foreach ($this->_propertiesList as $type => $nameArray) {
                // Si ce n'est pas le type d'objet en cours de création, continue.
                if (strtolower(get_class($this)) != $type) {
                    continue;
                }

                foreach ($nameArray as $name => $propArray) {
                    if ($key == $name) {
                        $param[$key] = null;

                        if (isset($propArray['force'])) {
                            // Détecte une tentative de modifier une valeur forçée.
                            if ($value != $propArray['force']
                                && $value != ''
                                && $value != null
                            ) {
                                $this->_metrology->addLog(get_class($this) . ' - Try to overwrite forced value ' . $propArray['key'] . ':' . $value, Metrology::LOG_LEVEL_ERROR); // Log
                            }

                            $this->_metrology->addLog(get_class($this) . ' - Normalize force ' . $propArray['key'] . ':' . $propArray['force'], Metrology::LOG_LEVEL_DEBUG); // Log
                            if ($propArray['type'] == 'boolean') {
                                if ($propArray['force'] == 'true') {
                                    $param[$key] = true;
                                } else {
                                    $param[$key] = false;
                                }
                            } elseif ($propArray['type'] == 'number') {
                                $param[$key] = (int)$propArray['force'];
                            } else {
                                $param[$key] = $propArray['force'];
                            }
                        } else {
                            if ($propArray['type'] == 'boolean'
                                && is_string($value)
                            ) {
                                $this->_metrology->addLog(get_class($this) . ' - Normalize bool ' . $key . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                                if ($value == 'true') {
                                    $param[$key] = true;
                                }
                                if ($value == 'false') {
                                    $param[$key] = false;
                                }
                                break 2;
                            }

                            if ($propArray['type'] == 'string') {
                                $this->_metrology->addLog(get_class($this) . ' - Normalize string ' . $key . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                                if (isset($propArray['limit'])
                                    && strlen($value) > (int)$propArray['limit']
                                ) {
                                    $param[$key] = substr($value, 0, (int)$propArray['limit']);
                                } else {
                                    $param[$key] = $value;
                                }
                                break 2;
                                // @todo faire validation des selects.
                            }

                            if ($propArray['type'] == 'hexadecimal') {
                                if (isset($propArray['checkbox'])) {
                                    $this->_metrology->addLog(get_class($this) . ' - Normalize multi hex ' . $key . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                                    $valueArray = explode(' ', $value);
                                    $value = '';
                                    foreach ($valueArray as $item) {
                                        if (ctype_xdigit($item)) {
                                            $value .= ' ' . $item;
                                        }
                                    }
                                    unset($valueArray);

                                    if (isset($propArray['limit'])
                                        && strlen(trim($value)) > (int)$propArray['limit']
                                    ) {
                                        $param[$key] = substr(trim($value), 0, (int)$propArray['limit']);
                                    } else {
                                        $param[$key] = trim($value);
                                    }
                                } else {
                                    $this->_metrology->addLog(get_class($this) . ' - Normalize hex ' . $key . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                                    if (!ctype_xdigit($value)) {
                                        // Si pas un hexa, supprime la valeur.
                                        $param[$name] = null;
                                    }
                                    if (isset($propArray['limit'])
                                        && strlen($value) > (int)$propArray['limit']
                                    ) {
                                        $param[$key] = substr($value, 0, (int)$propArray['limit']);
                                    } else {
                                        $param[$key] = $value;
                                    }
                                }
                                break 2;
                            }

                            if ($propArray['type'] == 'date') {
                                $this->_metrology->addLog(get_class($this) . ' - Normalize date ' . $key . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                                if (isset($propArray['limit'])
                                    && strlen($value) > (int)$propArray['limit']
                                ) {
                                    $param[$key] = substr($value, 0, (int)$propArray['limit']);
                                } else {
                                    $param[$key] = $value;
                                }
                                // @todo faire la vérification que c'est une date !
                                break 2;
                            }

                            if ($propArray['type'] == 'number'
                                && is_string($value)
                            ) {
                                $this->_metrology->addLog(get_class($this) . ' - Normalize number ' . $key . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                                $param[$key] = (double)$value;
                                if (isset($propArray['limit'])
                                    && $value > (double)$propArray['limit']
                                ) {
                                    $param[$key] = (double)$propArray['limit'];
                                } else {
                                    $param[$key] = $value;
                                }
                                break 2;
                            }
                        }
                    }
                    if ($key == 'Force' . $name
                        && isset($propArray['forceable'])
                        && $propArray['forceable']
                    ) {
                        $param[$key] = false;
                        $this->_metrology->addLog(get_class($this) . ' - Normalize force ' . $key . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                        if ($value === true) {
                            $param[$key] = true;
                        }
                        break 2;
                    }
                }
            }
        }

        // Rempli les paramètres non renseignés.
        foreach ($this->_propertiesList as $nameArray) {
            foreach ($nameArray as $name => $propArray) {
                if (isset($param[$name])) {
                    continue;
                }

                if ($propArray['type'] == 'boolean') {
                    $param[$name] = false;
                    $this->_metrology->addLog(get_class($this) . ' - Normalize add ' . $propArray['key'] . ':false', Metrology::LOG_LEVEL_DEBUG); // Log
                } else {
                    $param[$name] = null;
                    $this->_metrology->addLog(get_class($this) . ' - Normalize add ' . $propArray['key'] . ':null', Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }
        }
    }

    /**
     * Crée une monnaie.
     *
     * Les paramètres force* ne sont utilisés que si currencyHaveContent est à true.
     * Pour l'instant le code commence à prendre en compte currencyHaveContent à false mais le paramètre est forçé à true tant que le code n'est pas prêt.
     *
     * Les options pour la génération d'une monnaie :
     * currencyHaveContent
     * currencySerialID
     * currencyAutorityID
     *
     * forceCurrencyAutorityID
     *
     * Retourne la chaine avec 0 si erreur.
     *
     * array( 'currency' => array(
     * ...,
     * 'CurrencyType' => array(
     * 'key' => 'TYP',
     * 'shortname' => 'ctyp',
     * 'type' => 'string',
     * 'info' => 'omcptyp',
     * 'limit' => '32',
     * 'force' => 'cryptocurrency', ),
     * 'display' => '64',
     * 'forceable' => true,
     * ...,
     * ),
     * ...,
     * )
     *
     * @param array $param
     * @param boolean $protected
     * @param boolean $obfuscated
     * @return string
     */
    private function _createCurrency($param, $protected = false, $obfuscated = false)
    {
        // Identifiant final de la monnaie.
        $this->_id = '0';

        // Normalise les paramètres.
        $this->_normalizeInputParam($param);

        // Force l'écriture de l'objet de la monnaie.
        $param['CurrencyHaveContent'] = true;

        // Force l'écriture du serial.
        $param['ForceCurrencySerialID'] = true;

        // Force le paramètre AID avec l'entité en cours.
        $param['CurrencyAutorityID'] = $this->_nebuleInstance->getCurrentEntity();
        $param['ForceCurrencyAutorityID'] = true;
        $this->_properties['AID'] = $param['CurrencyAutorityID'];

        // Force les capacités.
        $param['ForceCurrencyCapacities'] = true;

        // Détermine si la monnaie a un numéro de série fourni.
        $sid = '';
        if (isset($param['CurrencySerialID'])
            && is_string($param['CurrencySerialID'])
            && $param['CurrencySerialID'] != ''
            && ctype_xdigit($param['CurrencySerialID'])
        ) {
            $sid = $this->_stringFilter($param['CurrencySerialID']);
            $this->_metrology->addLog('Generate currency asked SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        } else {
            // Génération d'un numéro de série de monnaie unique aléatoire.
            $sid = $this->_getPseudoRandom();
            $param['CurrencySerialID'] = $sid;
            $this->_metrology->addLog('Generate currency rand SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        }


        // Détermine si la monnaie doit avoir un contenu.
        if (isset($param['CurrencyHaveContent'])
            && $param['CurrencyHaveContent'] === true
        ) {
            $this->_metrology->addLog('Generate currency SID:' . $sid . ' HCT:true', Metrology::LOG_LEVEL_DEBUG); // Log

            // Le contenu final commence par l'identifiant interne de la monnaie.
            $content = 'TYP:' . $this->_propertiesList['currency']['CurrencyType']['force'] . "\n"; // @todo peut être intégré au reste.
            $this->_metrology->addLog('Generate currency SID:' . $sid . ' TYP:' . $this->_propertiesList['currency']['CurrencyType']['force'], Metrology::LOG_LEVEL_DEBUG); // Log
            $content .= 'SID:' . $sid . "\n";
            $content .= 'CAP:' . $this->_propertiesList['currency']['CurrencyCapacities']['force'] . "\n";
            $this->_metrology->addLog('Generate currency SID:' . $sid . ' CAP:' . $this->_propertiesList['currency']['CurrencyCapacities']['force'], Metrology::LOG_LEVEL_DEBUG); // Log
            $content .= 'MOD:' . $this->_propertiesList['currency']['CurrencyExploitationMode']['force'] . "\n";
            $this->_metrology->addLog('Generate currency SID:' . $sid . ' MOD:' . $this->_propertiesList['currency']['CurrencyExploitationMode']['force'], Metrology::LOG_LEVEL_DEBUG); // Log
            $content .= 'AID:' . $this->_nebuleInstance->getCurrentEntity() . "\n";
            $this->_metrology->addLog('Generate currency SID:' . $sid . ' AID:' . $this->_nebuleInstance->getCurrentEntity(), Metrology::LOG_LEVEL_DEBUG); // Log

            // Pour chaque propriété, si présente et forcée, l'écrit dans l'objet.
            foreach ($this->_propertiesList['currency'] as $name => $property) {
                if ($property['key'] != 'HCT'
                    && $property['key'] != 'TYP'
                    && $property['key'] != 'SID'
                    && $property['key'] != 'CAP'
                    && $property['key'] != 'MOD'
                    && $property['key'] != 'AID'
                    //&& $property['key'] != 'PCN'
                    //&& $property['key'] != 'TCN'
                    && isset($property['forceable'])
                    && $property['forceable'] === true
                    && isset($param['Force' . $name])
                    && $param['Force' . $name] === true
                    && isset($param[$name])
                    && $param[$name] != ''
                    && $param[$name] != null
                ) {
                    $value = null;
                    if ($property['type'] == 'boolean') {
                        if ($param[$name] === true) {
                            $value = true;
                        } else {
                            $value = false;
                        }
                    } elseif ($property['type'] == 'number') {
                        $value = (string)$param[$name];
                    } else {
                        $value = $param[$name];
                    }

                    // Ajoute la ligne.
                    $content .= $property['key'] . ':' . $value . "\n";
                    $this->_metrology->addLog('Generate currency SID:' . $sid . ' force ' . $property['key'] . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }

            // Crée l'objet avec le contenu et l'écrit.
            $this->_data = $content;
            $this->_haveData = true;
            unset($content);

            // calcul l'ID.
            $this->_id = $this->_crypto->hash($this->_data);

            // Si l'objet doit être protégé.
            if ($protected) {
                $this->setProtected($obfuscated);
            } else {
                // Sinon écrit l'objet directement.
                $this->write();
            }
        } else {
            $this->_id = $sid;
            $this->_metrology->addLog('Generate currency SID:' . $sid . ' HCT:false', Metrology::LOG_LEVEL_DEBUG); // Log
        }

        // La monnaie a maintenant un CID.
        $param['CurrencyID'] = $this->_id;
        $this->_metrology->addLog('Generate currency SID:' . $sid . ' CID:' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log


        // Prépare la génération des liens.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $source = $this->_id;
        $argObf = $obfuscated;

        // Le lien de type.
        $action = 'l';
        $target = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_MONNAIE);
        $meta = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE);
        $this->_createLink($signer, $date, $action, $source, $target, $meta, false);

        // Le lien de nommage si le nom est présent.
        if (isset($param['NAM'])
            && $param['NAM'] != null
            && $param['NAM'] != ''
        ) {
            $this->setName($param['NAM']);
        }

        // Crée les liens associés à la monnaie.
        //$action	= 'l';

        // Pour chaque propriété, si présente et a un méta, écrit le lien.
        foreach ($this->_propertiesList['currency'] as $name => $property) {
            if (isset($param[$name])
                && $param[$name] != null
            ) {
                $value = null;
                if ($property['type'] == 'boolean') {
                    if ($param[$name] === true) {
                        $value = 'true';
                    } else {
                        $value = 'false';
                    }
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                } elseif ($property['type'] == 'number') {
                    $value = (string)$param[$name];
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                } elseif ($property['type'] == 'hexadecimal') {
                    $value = $param[$name];
                    $target = $value;
                } else {
                    $value = $param[$name];
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                }

                if ($value != null) {
                    $this->_metrology->addLog('Generate currency SID:' . $sid . ' add ' . $property['key'] . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                    $meta = $this->_nebuleInstance->getCrypto()->hash($property['key']);
                    $this->_createLink($signer, $date, $action, $source, $target, $meta, $argObf);
                    $this->_metrology->addLog('Generate currency SID:' . $sid . ' link=' . $target . '_' . $meta, Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }
        }


        // Retourne l'identifiant de la monnaie.
        $this->_metrology->addLog('Generate currency end SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        return $this->_id;
    }


    /**
     * Filtrage d'un texte sur les caractères chiffres et lettres uniquement, et sur une seule ligne.
     *
     * @param string $value
     * @return string
     */
    protected function _stringFilter($value, $limit = 1024)
    {
        if ($value == '') {
            return '';
        }

        // Contenu retourné.
        $result = mb_convert_encoding(trim(strtok(filter_var(trim($value), FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW | FILTER_FLAG_NO_ENCODE_QUOTES), "\n")), 'UTF-8'); // @todo faire la restriction de caractères plus fine...

        if ($result === false) {
            $result = '';
        }

        if (strlen($result) > $limit) {
            $result = substr($result, 0, $limit);
        }

        return $result;
    }

    /**
     * Retourne la liste des sacs de jetons de la monnaie.
     *
     * @return array:string
     */
    public function getPoolList()
    {
        return $this->_getItemList('CID');
    }

    /**
     * Retourne le nombre de sacs de jetons de la monnaie.
     *
     * @return integer
     */
    public function getPoolCount()
    {
        return sizeof($this->_getItemList('CID'));
    }

    protected function _getItemList($type)
    {
        $links1 = array();
        $links2 = array();
        $links3 = array();
        $list = array();

        // Prépare la recherche des monnaies.
        $referenceType = $this->_nebuleInstance->getCrypto()->hash($type);
        $meta = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE);
        if ($type == 'CID') {
            $target = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_MONNAIE_SAC);
        } elseif ($type == 'PID') {
            $target = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_MONNAIE_JETON);
        } else {
            return $list;
        }

        // Recherche les monnaies pour l'entité en cours.
        $links1 = $this->readLinksFilterFull(
            '',
            '',
            'l',
            '',
            $this->_id,
            $referenceType
        );

        // Filtrage type recherché. @todo faire filtrage sur MID.
        foreach ($links1 as $i => $link) {
            $instance = $this->_nebuleInstance->newObject($link->getHashSource());
            $links2 = $instance->readLinksFilterFull(
                $link->getHashSigner(),
                '',
                'l',
                $link->getHashSource(),
                $target,
                $meta
            );

            if (sizeof($links2) != 0) {
                $list[$link->getHashSource()] = $link->getHashSource();
            }
        }

        return $list;
    }

    /**
     * Lit une clé et retourne un texte avec la valeur.
     *
     * Cette fonction est héritée par les sacs de jetons et les jetons et doit fonctionner dans les différentes classes.
     *
     * @param string $key
     * @param integer $maxsize
     * @return string|null
     */
    protected function _getParam($key, $maxsize)
    {
        $this->_metrology->addLog(get_class($this) . ' get param start for ' . $this->_id . ' - ' . $key, Metrology::LOG_LEVEL_DEBUG); // Log

        // La réponse.
        $result = null;

        if (!is_a($this, 'Currency')) {
            return $result;
        }

        // Lit le cache.
        if (isset($this->_properties[$key])) {
            $result = $this->_properties[$key];
        }

        // Traite les paramètres de présence de données forçées à part.
        if ($key == 'HCT'
            && $this->checkPresent()
        ) {
            $this->_propertiesForced['HCT'] = true;
            $result = true;
        }

        // Traite les paramètres de nombre de sacs ou jetons à part.
        /*		if ( $key == 'PCN' )
		{
			$result = sizeof($this->_getItemList('PID'));
		}
		if ( $key == 'TCN' )
		{
			$result = sizeof($this->_getItemList('TID'));
		}*/

        // Cherche l'option dans la monnaie définie (pas pour les monnaies).
        if ($result === null
            && $key != 'HCT'
            && $key != 'TYP'
            && $key != 'SID'
            && $key != 'FID'
            && $key != 'BID'
            && $key != 'COM'
            && $key != 'CPR'
        ) {
            $result = $this->_getParamFromCurrency($key, $maxsize);
        }

        // Cherche l'option dans le sac de jetons (pour les jetons).
        if ($result === null
            && $key != 'HCT'
            && $key != 'TYP'
            && $key != 'SID'
            && $key != 'FID'
            && $key != 'BID'
            && $key != 'COM'
            && $key != 'CPR'
        ) {
            $result = $this->_getParamFromPool($key, $maxsize);
        }

        // Cherche l'option dans l'environnement.
        if ($result === null) {
            $result = $this->_getParamFromObject($key, $maxsize);
        }

        // Si non trouvé, cherche l'option dans les liens.
        if ($result === null) {
            $result = $this->_getParamFromLinks($key, $maxsize);
        }

        $this->_metrology->addLog(get_class($this) . ' return param final ' . $this->_id . ' - ' . $key . ' = ' . (string)$result, Metrology::LOG_LEVEL_DEBUG); // Log

        // Ecrit le cache.
        $this->_properties[$key] = $result;

        return $result;
    }

    /**
     * Lit une clé dans la monnaie définie retourne un texte avec la valeur.
     *
     * @param string $key
     * @param integer $maxsize
     * @return string|null
     */
    protected function _getParamFromCurrency($key, $maxsize)
    {
        $return = null;

        // N'est pas utilisable pour une monnaie.
        if ($this->_inheritedCID === null
            || get_class($this) == 'Currency'
        ) {
            return null;
        }

        $this->_metrology->addLog(get_class($this) . ' get param on currency ' . $this->_id . ' - ' . $key, Metrology::LOG_LEVEL_DEBUG); // Log

        $return = $this->_inheritedCID->getParam($key);

        $this->_propertiesForced[$key] = $this->_inheritedCID->getParamForced($key);

        if ($return == ''
            && !$this->_propertiesForced[$key]
        ) {
            $return = null;
        }

        if ($return === null) {
            $this->_propertiesInherited[$key] = false;
        } else {
            $this->_propertiesInherited[$key] = true;
            $this->_metrology->addLog(get_class($this) . ' return param inherited on currency ' . $this->_id . ' - ' . $key, Metrology::LOG_LEVEL_DEBUG); // Log
        }

        $this->_metrology->addLog(get_class($this) . ' return param on currency ' . $this->_id . ' - ' . $key . ':' . (string)$return, Metrology::LOG_LEVEL_DEBUG); // Log
        return $return;
    }

    /**
     * Lit une clé dans le sac de jetons défini et retourne un texte avec la valeur.
     *
     * @param string $key
     * @param integer $maxsize
     * @return string|null
     */
    protected function _getParamFromPool($key, $maxsize)
    {
        $return = null;

        // N'est pas utilisable pour une monnaie ou un sac de jetons.
        if ($this->_inheritedPID === null
            || get_class($this) == 'Currency'
            || get_class($this) == 'TokenPool'
        ) {
            return null;
        }

        $this->_metrology->addLog(get_class($this) . ' get param on pool ' . $this->_id . ' - ' . $key, Metrology::LOG_LEVEL_DEBUG); // Log

        $return = $this->_inheritedPID->getParam($key);

        $this->_propertiesForced[$key] = $this->_inheritedPID->getParamForced($key);

        if ($return == ''
            && !$this->_propertiesForced[$key]
        ) {
            $return = null;
        }

        if ($return === null) {
            $this->_propertiesInherited[$key] = false;
        } else {
            $this->_propertiesInherited[$key] = true;
            $this->_metrology->addLog(get_class($this) . ' return param inherited on pool ' . $this->_id . ' - ' . $key, Metrology::LOG_LEVEL_DEBUG); // Log
        }

        $this->_metrology->addLog(get_class($this) . ' return param on pool ' . $this->_id . ' - ' . $key . ':' . (string)$return, Metrology::LOG_LEVEL_DEBUG); // Log
        return $return;
    }

    /**
     * Lit une clé dans le contenu de l'objet et retourne un texte avec la valeur.
     *
     * @param string $key
     * @param integer $maxsize
     * @return string|null
     */
    protected function _getParamFromObject($key, $maxsize)
    {
        $this->_metrology->addLog(get_class($this) . ' get param on object ' . $this->_id . ' - ' . $key, Metrology::LOG_LEVEL_DEBUG); // Log

        $result = null;

        // Lit le contenu de l'objet.
        $maxLimit = $this->_nebuleInstance->getOption('ioReadMaxData');
        $content = $this->getContent($maxLimit);

        // Si l'objet monnaie a du contenu.
        if ($content != null) {
            // Extrait un tableau avec une ligne par élément.
            $contentArray = explode("\n", $content);
            unset($content);

            foreach ($contentArray as $i => $line) {
                $l = trim($line);

                // Si commentaire, passe à la ligne suivante.
                if (substr($l, 0, 1) == "#"
                    || ($key == 'TYP' && $i != 0)
                    || ($key == 'SID' && $i != 1)
                    || (get_class($this) == 'Currency' && $key == 'CAP' && $i != 2)
                    || (get_class($this) == 'Currency' && $key == 'MOD' && $i != 3)
                    || (get_class($this) == 'Currency' && $key == 'AID' && $i != 4)
                    || (get_class($this) == 'TokenPool' && $key == 'CID' && $i != 2)
                    || (get_class($this) == 'Token' && $key == 'CID' && $i != 2)
                    || (get_class($this) == 'Token' && $key == 'PID' && $i != 3)
                ) {
                    continue;
                }

                // Recherche l'option demandée.
                if (filter_var(trim(strtok($l, ':')), FILTER_SANITIZE_STRING) == $key) {
                    $result = trim(filter_var(trim(substr($l, strpos($l, ':') + 1)), FILTER_SANITIZE_STRING));
                    break;
                }
            }
            unset($contentArray, $line, $l);
        }

        // Ecrit l'état de forçage de la valeur pour la clé.
        if ($result === null) {
            $this->_propertiesForced[$key] = false;
        } else {
            $this->_propertiesForced[$key] = true;
            $this->_metrology->addLog(get_class($this) . ' return param forced on object ' . $this->_id . ' - ' . $key, Metrology::LOG_LEVEL_DEBUG); // Log
        }

        $this->_metrology->addLog(get_class($this) . ' return param on object ' . $this->_id . ' - ' . $key . ':' . (string)$result, Metrology::LOG_LEVEL_DEBUG); // Log
        return $result;
    }

    /**
     * Lit une clé dans les liens de l'objet et retourne un texte avec la valeur.
     *
     * @param string $key
     * @param integer $maxsize
     * @return string
     */
    protected function _getParamFromLinks($key, $maxsize)
    {
        $this->_metrology->addLog(get_class($this) . ' get param on links ' . $this->_id . ' - ' . $key, Metrology::LOG_LEVEL_DEBUG); // Log

        $result = '';

        $id = '';
        $instance = null;

        $autorityList = array();

        // Vérifie que l'AID et/ou l'FID sont connus pour vérifier les liens.
        if (isset($this->_properties['AID'])) {
            $autorityList[] = $this->_properties['AID'];
        }
        if (isset($this->_properties['FID'])) {
            $autorityList[] = $this->_properties['FID']; // @todo à vérifier mais ce ne devrait pas être présent ici !?
        }

        $meta = '';
        foreach ($this->_propertiesList as $nameArray) {
            foreach ($nameArray as $name => $propArray) {
                if ($propArray['key'] == $key) {
                    $meta = $propArray['key'];
                    break 2;
                }
            }
        }

        $this->_metrology->addLog(get_class($this) . ' get param on links ' . $this->_id . ' - metatype:' . $meta, Metrology::LOG_LEVEL_DEBUG); // Log

        if ($meta != '') {
            $this->_social->setList($autorityList, 'onlist');
            $id = $this->getPropertyID($meta, 'onlist');
            //$id = $this->getPropertyID($meta, 'all');
            $this->_social->unsetList();
        }

        $this->_metrology->addLog(get_class($this) . ' get param on links ' . $this->_id . ' - meta:' . $id, Metrology::LOG_LEVEL_DEBUG); // Log

        if ($id != '') {
            $instance = $this->_nebuleInstance->newObject($id);
        }

        if (is_a($instance, 'Node')
            && $instance->getID() != '0'
        ) {
            // Extrait la valeur en fonction du type.
            foreach ($this->_propertiesList as $type => $nameArray) {
                // Si ce n'est pas le type d'objet attendu, continue.
                if (strtolower(get_class($this)) != $type) {
                    continue;
                }

                foreach ($nameArray as $name => $propArray) {
                    if ($key == $propArray['key']) {
                        if ($propArray['type'] == 'hexadecimal') {
                            $result = $instance->getID();
                        } else {
                            $result = $instance->getContent($maxsize);
                        }
                    }
                }
            }
        }

        unset($meta, $id, $instance);

        $this->_metrology->addLog(get_class($this) . ' return param on links ' . $this->_id . ' - ' . $key . ':' . (string)$result, Metrology::LOG_LEVEL_DEBUG); // Log
        if ($result == '') {
            return null;
        }
        return $result;
    }

    /**
     * Ecrit un paramètre en lien avec une monnaie ou dérivé.
     * Vérifie que le paramètre n'est pas en lecture seule, càd dans l'objet.
     * Le paramètre est enregistré sous forme d'un lien.
     *
     * @param unknown $key
     * @param unknown $value
     * @return boolean
     */
    protected function _setParam($key, $value)
    {
        // @todo

        return false;
    }

    /**
     * Lit une clé et retourne un texte avec la valeur.
     * La taille maximum dépend de la clé.
     *
     * @param string $key
     * @return string|null
     */
    public function getParam($key)
    {
        // @todo faire les vérifications des variables.

        // Détermine la taille maximum à lire.
        $maxsize = 0;
        foreach ($this->_propertiesList as $nameArray) {
            foreach ($nameArray as $name => $propArray) {
                if ($propArray['key'] == $key) {
                    if ($propArray['type'] == 'boolean') {
                        $maxsize = 5;
                        break 2;
                    } elseif ($propArray['type'] == 'number') {
                        $maxsize = 15;
                        break 2;
                    } elseif (isset($propArray['limit'])) {
                        $maxsize = (float)$propArray['limit'];
                        break 2;
                    }
                }
            }
        }

        if ($maxsize == 0) {
            return null;
        }

        return $this->_getParam($key, $maxsize);
    }

    /**
     * Lit si la valeur d'une clé est forçée par héritage.
     *
     * Pas d'héritage pour une monnaie mais c'est géré lors de la recherche de la clé.
     *
     * @param string $key
     * @return boolean
     */
    public function getParamInherited($key)
    {
        if (get_class($this) == 'Currency') {
            return false;
        }

        // Initalise les caches.
        if (!isset($this->_propertiesInherited[$key])) {
            $this->getParam($key);
        }

        // Retourne l'état d'héritage.
        if (isset($this->_propertiesInherited[$key])) {
            if ($this->_propertiesInherited[$key]) {
                $this->_metrology->addLog(get_class($this) . ' get param inherited ' . $this->_id . ' - ' . $key . ':true', Metrology::LOG_LEVEL_DEBUG); // Log
            } else {
                $this->_metrology->addLog(get_class($this) . ' get param inherited ' . $this->_id . ' - ' . $key . ':false', Metrology::LOG_LEVEL_DEBUG); // Log
            }
            return $this->_propertiesInherited[$key];
        } else {
            $this->_metrology->addLog(get_class($this) . ' get param inherited ' . $this->_id . ' - ' . $key . ':not defined (false)', Metrology::LOG_LEVEL_DEBUG); // Log
            return false;
        }
    }

    /**
     * Lit si la valeur d'une clé est forçée.
     *
     * @param string $key
     * @return boolean
     */
    public function getParamForced($key)
    {
        // Initalise les caches.

        if (!isset($this->_propertiesForced[$key])) {
            $this->getParam($key);
        }

        // Retourne l'état de forçage.
        if (isset($this->_propertiesForced[$key])) {
            if ($this->_propertiesForced[$key]) {
                $this->_metrology->addLog(get_class($this) . ' get param forced ' . $this->_id . ' - ' . $key . ':true', Metrology::LOG_LEVEL_DEBUG); // Log
            } else {
                $this->_metrology->addLog(get_class($this) . ' get param forced ' . $this->_id . ' - ' . $key . ':false', Metrology::LOG_LEVEL_DEBUG); // Log
            }
            return $this->_propertiesForced[$key];
        } else {
            $this->_metrology->addLog(get_class($this) . ' get param forced ' . $this->_id . ' - ' . $key . ':not defined (false)', Metrology::LOG_LEVEL_DEBUG); // Log
            return false;
        }
    }

    /**
     * Ecrit un paramètre en lien avec une monnaie ou dérivé.
     * Vérifie que le paramètre n'est pas en lecture seule, càd dans l'objet.
     * Le paramètre est enregistré sous forme d'un lien.
     * Un paramètre ne peut pas être ajouté à l'objet sans modifier son identifiant.
     *
     * @param unknown $key
     * @param unknown $value
     * @return boolean
     */
    public function setParam($key, $value)
    {
        // @todo faire les vérifications des variables.

        return $this->_setParam($key, $value);
    }

    /**
     * Définit la monnaie de référence utilisée.
     * N'est utilisé que pour les sacs de jetons et les jetons.
     *
     * @param $currency string|Currency
     * @return boolean
     */
    public function setCID($currency = '0')
    {
        if (is_string($currency)
            && $currency != ''
            && $currency != '0'
            && $this->_io->checkLinkPresent($currency)
        ) {
            $currency = new Currency($this->_nebuleInstance, $currency);
        }
        if (!get_class($currency) == 'Currency') {
            return false;
        }
        if (get_class($this) != 'TokenPool'
            && get_class($this) != 'Token'
        ) {
            return false;
        }
        if ($currency->getID() == '0') {
            return false;
        }

        // @todo vérifier que le CID est cohérent pour cet item dans les liens.

        $this->_metrology->addLog('set CID ' . $currency->getID() . ' for ' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log
        $this->_inheritedCID = $currency;

        // Ecrit le cache.
        $this->_properties['CID'] = $currency->getID();

        return true;
    }

    /**
     * Définit le sac de jetons de référence utilisé.
     * N'est utilisé que pour les jetons.
     *
     * @param $pool string|TokenPool
     * @return boolean
     */
    public function setPID($pool = '0')
    {
        if (is_string($pool)
            && $pool != ''
            && $pool != '0'
            && $this->_io->checkLinkPresent($pool)
        ) {
            $pool = new TokenPool($this->_nebuleInstance, $pool);
        }
        if (!get_class($pool) == 'TokenPool') {
            return false;
        }
        if (get_class($this) != 'Token') {
            return false;
        }
        if ($pool->getID() == '0') {
            return false;
        }

        // @todo vérifier que le PID est cohérent pour ce jeton dans les liens.

        $this->_metrology->addLog('set PID ' . $pool->getID() . ' for ' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log
        $this->_inheritedPID = $pool;

        // Ecrit le cache.
        $this->_properties['PID'] = $pool->getID();

        return true;
    }

    /**
     * Initialise l'AID, entité autorité de la monnaie.
     * Si l'instance est une monnaie, recherche le paramètre AID dans l'objet de la monnaie.
     *
     * @return boolean
     */
    public function setAID()
    {
        if (get_class($this) == 'Currency') {
            $id = $this->_getParamFromObject('AID', (int)$this->_propertiesList['currency']['CurrencyAutorityID']['limit']);
            $this->_metrology->addLog('set AID by param - AID:' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
        } else {
            $id = $this->_getParamFromCurrency('AID', (int)$this->_propertiesList['currency']['CurrencyAutorityID']['limit']);
            $this->_metrology->addLog('set AID from currency - AID:' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
        }

        // Vérifie l'ID.
        if (is_string($id)
            && $id != ''
            && ctype_xdigit($id)
            && $this->_io->checkObjectPresent($id)
//				&& $this->_io->checkLinkPresent($id)
        ) {
            $this->_properties['AID'] = $id;
            $this->_metrology->addLog('set AID ' . $id . ' for ' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log
            return true;
        }
        $this->_metrology->addLog('error set AID for ' . $this->_id, Metrology::LOG_LEVEL_ERROR); // Log
        return false;
    }

    /**
     * Initialise l'FID, entité forge de la monnaie.
     * Si l'instance est une monnaie, recherche le paramètre FID et ne tient pas compte de l'argument de la fonction.
     *
     * @param unknown $id
     * @return boolean
     */
    public function setFID($id)
    {
        if (get_class($this) == 'Currency') {
            //$id = $this->_getParam('FID', (int)$this->_propertiesList['currency']['CurrencyForgeID']['limit']);
            $id = '';
        } elseif (get_class($this) == 'TokenPool') {
            $id = $this->_getParam('FID', (int)$this->_propertiesList['tokenpool']['PoolForgeID']['limit']);
        } elseif (get_class($this) == 'Token') {
            $id = $this->_getParam('FID', (int)$this->_propertiesList['token']['TokenForgeID']['limit']);
        }
        $this->_metrology->addLog('set FID by param', Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie l'ID.
        if (is_string($id)
            && $id != ''
            && ctype_xdigit($id)
            && $this->_io->checkObjectPresent($id)
//				&& $this->_io->checkLinkPresent($id)
        ) {
            $this->_properties['FID'] = $id;
            $this->_metrology->addLog('set FID ' . $id . ' for ' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log
            return true;
        }
        $this->_metrology->addLog('error set FID for ' . $this->_id, Metrology::LOG_LEVEL_ERROR); // Log
        return false;
    }

    /**
     * Crée un texte pseudo-aléatoire.
     * Retourne une chaine de caractères représentant de l'héxadécimale, c'est à dire une suite de chiffres de 0 à f.
     *
     * La fonction gère une graine afin d'améliorer la génératon successivement de l'aléa.
     *
     * @return string
     */
    protected function _getPseudoRandom()
    {
        // Définit l'algorithme de divergence.
        $algo = 'sha256';

        // Résultat à remplir.
        $result = '';

        // Si besoin, génère le compteur interne.
        if ($this->_seed == '') {
            $this->_seed = $this->_nebuleInstance->getCrypto()->getPseudoRandom(32);
            $this->_seed = hash($algo, $this->_seed);
        }

        // Fait évoluer le compteur interne.
        $this->_seed = hash($algo, $this->_seed);

        // Fait diverger le compteur interne pour la sortie.
        // La concaténation avec un texte empêche de remonter à la valeur du compteur interne.
        $result = hash($algo, $this->_seed . 'liberté égalité fraternité');

        return $result;
    }

    /**
     * Crée un lien.
     *
     * @return boolean
     */
    protected function _createLink($signer, $date, $action, $source, $target, $meta, $obfuscate = false)
    {
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);

        // Signe le lien.
        $newLink->sign($signer);

        // Si besoin, obfuscation du lien.
        if ($obfuscate
            && $this->_nebuleInstance->getOption('permitObfuscatedLink')
        ) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        return $newLink->write();
    }

    /**
     * Extrait les capacités de la monnaie dans le champs CAP dans un tableau.
     * Ce tableau doit faciliter la vérification des champs à utiliser.
     *
     * @return void
     */
    private function _extractCAParray()
    {
        $this->_CAParray = array();

        if (!isset($this->_propertiesForced['CAP'])
            || sizeof($this->_propertiesForced['CAP']) == 0
        ) {
            return;
        }

        $this->_propertiesForced['CAP'];
        $subitems = explode(' ', $value);
        foreach ($subitems as $subitem) {

        }
    }

    /**
     * Retourne la liste des propriétés des objets monnaies et hérités.
     *
     * @return array
     */
    public function getPropertiesList()
    {
        return $this->_propertiesList;
    }


    /**
     * Extrait la valeur relative de la monnaie à un instant donné.
     *
     * @param $date string
     * @return double
     */
    public function getRelativeValue($date)
    {

        // Récupère la liste des jetons.
        $items = $this->_getItemList('CID');

        $total = 0;

        foreach ($items as $item) {
            $instance = $this->_nebuleInstance->newTokenPool($item);
            if ($instance->getID() != '0') {
                $total += $instance->getRelativeValue($date);
            }
        }

        return $total;
    }


    /**
     * Affiche la partie menu de la documentation.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#om">OM / Monnaie</a>
            <ul>
                <li><a href="#omf">OMF / Fonctionnement</a></li>
                <li><a href="#omn">OMN / Nommage</a></li>
                <li><a href="#omp">OMP / Protection</a></li>
                <li><a href="#omd">OMD / Dissimulation</a></li>
                <li><a href="#oml">OML / Liens</a></li>
                <li><a href="#omv">OMV / Valeur</a></li>
                <li><a href="#omc">OMC / Création</a>
                    <ul>
                        <li><a href="#omcl">OMCL / Liens</a></li>
                        <li><a href="#omcp">OMCP / Propriétés</a>
                            <ul>
                                <li><a href="#omcph">OMCPH / Héritage</a></li>
                                <li><a href="#omcphct">OMCPHCT / HCT</a></li>
                                <li><a href="#omcptyp">OMCPTYP / TYP</a></li>
                                <li><a href="#omcpsid">OMCPSID / SID</a></li>
                                <li><a href="#omcpcap">OMCPCAP / CAP</a></li>
                                <li><a href="#omcpmod">OMCPMOD / MOD</a></li>
                                <li><a href="#omcpaid">OMCPAID / AID</a></li>
                                <li><a href="#omcpmid">OMCPMID / MID</a></li>
                                <li><a href="#omcpfid">OMCPFID / FID</a></li>
                                <li><a href="#omcpcid">OMCPCID / CID</a></li>
                                <li><a href="#omcpnam">OMCPNAM / NAM</a></li>
                                <li><a href="#omcpuni">OMCPUNI / UNI</a></li>
                                <li><a href="#omcpdta">OMCPDTA / DTA</a></li>
                                <li><a href="#omcpdtc">OMCPDTC / DTC</a></li>
                                <li><a href="#omcpdtd">OMCPDTD / DTD</a></li>
                                <li><a href="#omcpcom">OMCPCOM / COM</a></li>
                                <li><a href="#omcpcpr">OMCPCPR / CPR</a></li>
                                <li><a href="#omcpidm">OMCPIDM / IDM</a></li>
                                <li><a href="#omcpidr">OMCPIDR / IDR</a></li>
                                <li><a href="#omcpidp">OMCPIDP / IDP</a></li>
                                <li><a href="#omcpvmd">OMCPVMD / VMD</a></li>
                                <li><a href="#omcpvid">OMCPVID / VID</a></li>
                                <li><a href="#omcptrs">OMCPTRS / TRS</a></li>
                                <li><a href="#omcppcn">OMCPPCN / PCN</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#oms">OMS / Stockage</a></li>
                <li><a href="#omt">OMT / Transfert</a></li>
                <li><a href="#omr">OMR / Réservation</a></li>
                <li><a href="#omio">OMIO / Implémentation des Options</a></li>
                <li><a href="#omia">OMIA / Implémentation des Actions</a></li>
                <li><a href="#omo">OMO / Oubli</a></li>
                <li><a href="#omg">OMG / Sac de jetons</a>
                    <ul>
                        <li><a href="#omgf">OMGF / Fonctionnement</a></li>
                        <li><a href="#omgn">OMGN / Nommage</a></li>
                        <li><a href="#omgp">OMGP / Protection</a></li>
                        <li><a href="#omgd">OMGD / Dissimulation</a></li>
                        <li><a href="#omgl">OMGL / Liens</a></li>
                        <li><a href="#omgv">OMGV / Valeur</a></li>
                        <li><a href="#omgc">OMGC / Création</a>
                            <ul>
                                <li><a href="#omgcl">OMGCL / Liens</a></li>
                                <li><a href="#omgcp">OMGCP / Propriétés</a>
                                    <ul>
                                        <li><a href="#omgcph">OMGCPH / Héritage</a></li>
                                        <li><a href="#omgcphct">OMGCPHCT / HCT</a></li>
                                        <li><a href="#omgcptyp">OMGCPTYP / TYP</a></li>
                                        <li><a href="#omgcpsid">OMGCPSID / SID</a></li>
                                        <li><a href="#omgcpcap">OMGCPCAP / CAP</a></li>
                                        <li><a href="#omgcpfid">OMGCPFID / FID</a></li>
                                        <li><a href="#omgcpmid">OMGCPMID / MID</a></li>
                                        <li><a href="#omgcppid">OMGCPPID / PID</a></li>
                                        <li><a href="#omgcpcid">OMGCPCID / CID</a></li>
                                        <li><a href="#omgcpdta">OMGCPDTA / DTA</a></li>
                                        <li><a href="#omgcpdtc">OMGCPDTC / DTC</a></li>
                                        <li><a href="#omgcpdtd">OMGCPDTD / DTD</a></li>
                                        <li><a href="#omgcpcom">OMGCPCOM / COM</a></li>
                                        <li><a href="#omgcpcpr">OMGCPCPR / CPR</a></li>
                                        <li><a href="#omgcpidm">OMGCPIDM / IDM</a></li>
                                        <li><a href="#omgcpidr">OMGCPIDR / IDR</a></li>
                                        <li><a href="#omgcpidp">OMGCPIDP / IDP</a></li>
                                        <li><a href="#omgcptcn">OMGCPTCN / TCN</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#omgs">OMGS / Stockage</a></li>
                        <li><a href="#omgt">OMGT / Transfert</a></li>
                        <li><a href="#omgr">OMGR / Réservation</a></li>
                        <li><a href="#omgo">OMGO / Oubli</a></li>
                    </ul>
                </li>
                <li><a href="#omj">OMJ / Jeton</a>
                    <ul>
                        <li><a href="#omjf">OMJF / Fonctionnement</a></li>
                        <li><a href="#omjn">OMJN / Nommage</a></li>
                        <li><a href="#omjp">OMJP / Protection</a></li>
                        <li><a href="#omjd">OMJD / Dissimulation</a></li>
                        <li><a href="#omjl">OMJL / Liens</a></li>
                        <li><a href="#omjv">OMJV / Valeur</a></li>
                        <li><a href="#omjc">OMJC / Création</a>
                            <ul>
                                <li><a href="#omjcl">OMJCL / Liens</a></li>
                                <li><a href="#omjcp">OMJCP / Propriétés</a>
                                    <ul>
                                        <li><a href="#omjcph">OMJCPH / Héritage</a></li>
                                        <li><a href="#omjcphct">OMJCPHCT / HCT</a></li>
                                        <li><a href="#omjcptyp">OMJCPTYP / TYP</a></li>
                                        <li><a href="#omjcpsid">OMJCPSID / SID</a></li>
                                        <li><a href="#omjcpcap">OMJCPCAP / CAP</a></li>
                                        <li><a href="#omjcpcid">OMJCPCID / CID</a></li>
                                        <li><a href="#omjcppid">OMJCPPID / PID</a></li>
                                        <li><a href="#omjcptid">OMJCPTID / TID</a></li>
                                        <li><a href="#omjcpfid">OMJCPFID / FID</a></li>
                                        <li><a href="#omjcpbid">OMJCPBID / BID</a></li>
                                        <li><a href="#omjcpnam">OMJCPNAM / NAM</a></li>
                                        <li><a href="#omjcpuni">OMJCPUNI / UNI</a></li>
                                        <li><a href="#omjcpval">OMJCPVAL / VAL</a></li>
                                        <li><a href="#omjcpdta">OMJCPDTA / DTA</a></li>
                                        <li><a href="#omjcpdtc">OMJCPDTC / DTC</a></li>
                                        <li><a href="#omjcpdtd">OMJCPDTD / DTD</a></li>
                                        <li><a href="#omjcpcom">OMJCPCOM / COM</a></li>
                                        <li><a href="#omjcpcpr">OMJCPCPR / CPR</a></li>
                                        <li><a href="#omjcpidm">OMJCPIDM / IDM</a></li>
                                        <li><a href="#omjcpidr">OMJCPIDR / IDR</a></li>
                                        <li><a href="#omjcpidp">OMJCPIDP / IDP</a></li>
                                        <li><a href="#omjcpsvc">OMJCPSVC / SVC</a></li>
                                        <li><a href="#omjcpclb">OMJCPCLB / CLB</a></li>
                                        <li><a href="#omjcpcld">OMJCPCLD / CLD</a></li>
                                        <li><a href="#omjcptrs">OMJCPTRS / TRS</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#omjs">OMJS / Stockage</a></li>
                        <li><a href="#omjt">OMJT / Transfert</a>
                            <ul>
                                <li><a href="#omjti">OMJCTI / Transfert d'information</a></li>
                                <li><a href="#omjtv">OMJCTV / Transfert de valeur</a></li>
                            </ul>
                        </li>
                        <li><a href="#omjm">OMJM / Modes de transfert</a>
                            <ul>
                                <li><a href="#omjmlns">OMJMLNS / Mode LNS</a></li>
                            </ul>
                        </li>
                        <li><a href="#omjr">OMJR / Réservation</a></li>
                        <li><a href="#omjo">OMJO / Oubli</a></li>
                    </ul>
                </li>
            </ul>
        </li>

        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h2 id="om">OM / Monnaie</h2>
        <p>Certains objets permettre de mettre en place et de gérer plusieurs types de monnaies et plusieurs monnaies
            concurrentes.</p>

        <h3 id="omf">OMF / Fonctionnement</h3>
        <p>Une monnaie est un objet de référence qui va gérer des sac de jetons. La gestion se fait par différentes
            entités détenant des rôles spécifiques aux monnaies.</p>
        <p>Une monnaie va disposer de plusieurs propriétés connues par leurs abréviations, voir <a href="#omcp">OMCP</a>.
        </p>
        <p>L'objet de référence de la monnaie peut être virtuel ou non. Aujourd'hui le code ne gère que des monnaies
            avec un objet de référence non virtuel.</p>
        <p>Si l'objet de référence de la monnaie est virtuel, il est forçément généré aléatoirement. Sinon il dépend du
            contenu de l'objet et est rendu unique grâce à la propriété <code>SID</code>.</p>
        <p>Exemple d'objet de monnaie :</p>
        <pre>
TYP:currency
SID:5f3ad5265bb3306b3266e1935d067d9ec15965d0a970554bc6161eb3328907a9
CAP:TYP MOD SID CAP AID MID NAM UNI DTA DTC DTD COM CPR IDM IDR IDP VMD VID TRS CID PID FID BID VAL CLB CLD SVC TID
MOD:CTL
AID:f0f7cf5c921320b97daedeb7c53f2417921c747c77b696f8a25ff29277661d2f
MID:f0f7cf5c921320b97daedeb7c53f2417921c747c77b696f8a25ff29277661d2f
NAM:poux
UNI:pou
CPR:(c) nebule/qantion 2020
</pre>

        <h3 id="omn">OMN / Nommage</h3>
        <p>Une monnaie peut disposer d'un nom complet. Ce nom est définit par la propriété <code>NAM</code> et est
            doublé par un lien de nommage classique comme tout objet.</p>
        <p>Une monnaie peut aussi disposer d'une abréviation définit par la propriété <code>UNI</code>.</p>
        <p>Le nom complet d'un objet de type monnaie est uniquement extrait de la propriété <code>NAM</code>. Dans
            certains cas il peut êrte formé de <code>NAM(UNI)</code> mais la propriété <code>UNI</code> a plutôt
            vocation a être utilisée dans un affichage condensé.</p>

        <h3 id="omp">OMP / Protection</h3>
        <p>A faire...</p>

        <h3 id="omd">OMD / Dissimulation</h3>
        <p>A faire...</p>

        <h3 id="oml">OML / Liens</h3>
        <p>A faire...</p>

        <h3 id="omv">OMV / Valeur</h3>
        <p>La valeur de la monnaie, à un instant donné, est égale à la somme des sac de jetons de la monnaie au même
            instant.</p>

        <h3 id="omc">OMC / Création</h3>
        <p>A faire...</p>

        <h4 id="omcl">OMCL / Liens</h4>
        <p>Liste des liens à générer lors de la création d'une monnaie.</p>
        <p>A faire...</p>

        <h4 id="omcp">OMCP / Propriétés</h4>
        <p></p>

        <h5 id="omcph">OMCPH / Héritage</h5>
        <p>Certaines propriétés des sacs de jetons et jetons sont héritées de la monnaie, si ces propriétés sont
            définies dans la monnaie. Les héritages sont prioritaires sur les propriétés définies via l'objet et les
            liens des sacs de jetons et jetons.</p>

        <h5 id="omcphct">OMCPHCT / HCT</h5>
        <p>Définit si l'objet de la monnaie a un contenu. Si il n'a pas de contenu l'objet de la monnaie est virtuel et
            correspond à son SID, et les paramètres de la monnaie ne peuvent pas être forcés.</p>
        <p>Ce n'est pas écrit dans l'objet de la monnaie ni enregistré via des liens. Cela sert uniquement au moment de
            la création d'une monnaie.</p>

        <h5 id="omcptyp">OMCPTYP / TYP</h5>
        <p>Le type de monnaie.</p>
        <p>Toujours à la valeur <i>cryptocurrency</i>.</p>
        <p>Présence obligatoire en ligne 1 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpsid">OMCPSID / SID</h5>
        <p>Le numéro de série identifiant de la monnaie (<i>serial</i>).</p>
        <p>Si l'objet de référence de la monnaie est virtuel, l'identifiant de la monnaie <code>CID</code> sera le
            <code>SID</code>.</p>
        <p>Si l'objet de référence de la monnaie n'est pas virtuel, l'identifiant de la monnaie <code>CID</code> dépend
            du contenu de l'objet et est rendu unique grâce à la propriété <code>SID</code>.</p>
        <p>La valeur est de préférence aléatoire mais peut être un compteur à condition d'être unique. L’utilisation
            d’un compteur de faible valeur est fortement déconseillée.</p>
        <p>Si aléatoire, la génération pseudo aléatoire du <code>SID</code> est faite en partant d’un dérivé de la date
            avec quelques valeurs locales. Il n’y a pas de contrainte de sécurité sur cette valeur. Puis une boucle
            interne génère un bon aléa au fur et à mesure de la génération des jetons via une fonction de hash. Le tout
            ne consomme pas du tout de précieux aléa de bonne qualité.</p>
        <p>Présence obligatoire en ligne 2 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpcap">OMCPCAP / CAP</h5>
        <p>Liste des capacités connues de la monnaie.</p>
        <p>Si une capacité n'est pas présente elle ne peut être invoquée, même si elle est forcée.</p>
        <p>Présence obligatoire en ligne 3 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpmod">OMCPMOP / MOP</h5>
        <p>Définit le mode d'exploitation de la monnaie.</p>
        <p>Si une capacité n'est pas présente elle ne peut être invoquée, même si elle est forcée.</p>
        <p>Présence obligatoire en ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpaid">OMCPAID / AID</h5>
        <p>Identifiant de l'entité authorité de la monnaie (<i>autority</i>).</p>
        <p>C'est l'entité qui forge la monnaie et délègue la gestion aux entités gestionnaires (MID).</p>
        <p>Présence obligatoire en ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpmid">OMCPMID / MID</h5>
        <p>Identifiant d'une entité de gestion de la monnaie (<i>manage</i>).</p>
        <p>Une monnaie peut avoir plusieurs entités de gestion.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpfid">OMCPFID / FID</h5>
        <p>Non utilisé !!!</p>
        <p>Identifiant de l'entité ayant forgé la monnaie (<i>forge</i>).</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpcid">OMCPCID / CID</h5>
        <p>Identifiant de l’objet de la monnaie (<i>currency</i>).</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème. Ce qui va faire la différence c'est l'autorité et ses liens.</p>
        <p>L'objet d'une monnaie ne peut en aucun cas contenir son propre identifiant <code>CID</code>.</p>

        <h5 id="omcpnam">OMCPNAM / NAM</h5>
        <p>Le nom de la monnaie. Limité à 256 caractères.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpuni">OMCPUNI / UNI</h5>
        <p>Le nom de l'unité de la monnaie en 3 lettres maximum. Pas de chiffre.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpdta">OMCPDTA / DTA</h5>
        <p>Identifiant de l’entité autorité de temps pour les limites de temps.</p>
        <p>La gestion du temps avec une autorité de temps permet de prendre en compte sérieusement les suppression
            programmées de jeton (<code>DTC</code>/<code>DTD</code>) ainsi que leur inflation/déflation automatique
            (<code>IDM</code>/<code>IDR</code>/<code>IDP</code>).</p>
        <p>L’autorité de temps peut être spécifique pour chaque jeton mais il est plus logique qu’elle soit commune à
            une monnaie ou dans certains cas à un sac de jetons.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpdtc">OMCPDTC / DTC</h5>
        <p>Date de création de la monnaie.</p>
        <p>Forme texte libre limitée à 128 caractères. Doit pourvoir être interprété comme une date.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpdtd">OMCPDTD / DTD</h5>
        <p>Date de suppression programmée de la monnaie.</p>
        <p> Forme texte libre limitée à 128 caractères. Doit pourvoir être interprété comme une date pour être
            fonctionel.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpcom">OMCPCOM / COM</h5>
        <p>Commentaire texte libre limité à 4096 caractères.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpcpr">OMCPCPR / CPR</h5>
        <p>Licence du jeton sous forme d’une texte libre limité à 1024 caractères.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpidm">OMCPIDM / IDM</h5>
        <p>Mode de fonctionnement du mécanisme d’inflation/déflation (<i>mode</i>) de tous les jetons de la monnaie.</p>
        <p>Les modes sont <i>creation</i> ou <i>transaction</i> ou <i>disabled</i>.</p>
        <p>Suivant le mode, le mécanisme tient compte du temps passé depuis la dernière transaction ou depuis l’émission
            du jeton.</p>
        <p>Le mécanisme d’inflation/déflation (<code>IDM</code>/<code>IDR</code>/<code>IDP</code>), si activé, avec un
            taux de variation inférieur à 1, donc en déflation, permet de forcer les détenteurs de jeton à les utiliser
            plutôt que de les stocker. Les jetons concernés vont donc perdre de la valeur par rapport aux nouveaux
            jetons ou par rapport à ceux qui circulent.</p>
        <p>Si activé, avec un taux de variation suppérieur à 1, donc en inflation, permet de favoriser la conservation
            des jetons et valorise les vieux jetons sur les nouveaux ou ceux qui circulent beaucoup.</p>
        <p>En ne forçant pas cette propriété dans l'objet des jetons, il est possible d'avoir un taux de variation
            fluctuant en fonction des besoins. En le positionnant forçé à <i>disabled</i> cela désactive définitivement
            ce mécanisme au niveau de la monnaie et donc pour tous les jetons.</p>
        <p>Un jeton peut se déprécier avec le temps mais une entité peut demander à l’autorité émettrice de la monnaie
            un échange de jeton ancien contre un jeton plus jeune, si l’autorité émettrice le permet.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>CF <a href="#omgcpidm">P/IDM</a> et <a href="#omjcpidm">T/IDM</a>.</p>

        <h5 id="omcpidr">OMCPIDR / IDR</h5>
        <p>Taux de variation du mécanisme d’inflation/déflation (<i>rate</i>) de tous les jetons de la monnaie.</p>
        <p>Égal à 1 (un), taux constant donc pas de variation.</p>
        <p>Doit être activé par <code>IDM</code>.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpidp">OMCPIDP / IDP</h5>
        <p>Périodicité d’application du taux de variation du mécanisme d’inflation/déflation (<i>period</i>) de tous les
            jetons de la monnaie.</p>
        <p>Unité exprimée en minutes.</p>
        <p>Si à 0 (zéro), la période n'est pas utilisé, donc la variation est non effective.</p>
        <p>Doit être activé par <code>IDM</code>.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpvmd">OMCPVMD / VMD</h5>
        <p>Définit le mode de validation des transactions de jetons de la monnaie. C'est le mode de fonctionnement
            global de la monnaie.</p>
        <p>Actuellement seul est supporté le mode centralisé.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcpvid">OMCPVID / VID</h5>
        <p>Dans le mode de validation centralisé, c'est l'entité de validation des transactions de jetons de la
            monnaie.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcptrs">OMCPTRS / TRS</h5>
        <p>Liste des méthodes de transaction supportées.</p>
        <p>Le code <code>LNS</code> désigne la méthode de base avec un lien (L) matérialisant une transaction et
            imposant un jeton non sécable (NS).</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omcppcn">OMCPPCN / PCN</h5>
        <p>Non utilisé !!!</p>
        <p>Définit le nombre de sacs de jetons à créer avec la monnaie. Ce nombre multiplié par le <a href="#omgcptcn">TCN</a>
            donne le nombre total de jetons créés pour la monnaie.</p>
        <p>Ce n'est pas écrit dans l'objet de la monnaie, ni dans les sacs de jetons ni enregistré via des liens. Cela
            sert uniquement au moment de la création de la monnaie. Cependant un lien de rattachement sera créé pour
            chaque sac de jeton depuis la monnaie avec en meta le <a href="#omgcppid"></a>PID</a>.</p>

        <h3 id="oms">OMS / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="omt">OMT/ Transfert</h3>
        <p>A faire...</p>

        <h3 id="omr">OMR / Réservation</h3>
        <p>Les objets réservés spécifiquement pour les monnaies :</p>
        <ul>
            <li>nebule/objet/monnaie</li>
        </ul>

        <h4 id="omio">OMIO / Implémentation des Options</h4>
        <p>A faire...</p>

        <h4 id="omia">OMIA / Implémentation des Actions</h4>
        <p>A faire...</p>

        <h3 id="omo">OMO / Oubli</h3>
        <p>L'oubli vonlontaire de certains liens et objets n'est encore ni théorisé ni implémenté mais deviendra
            indispensable lorsque l'espace viendra à manquer (cf <a href="#cn">CN</a>).</p>


        <h3 id="omg">OMG / Sac de jetons</h3>
        <p>A faire...</p>

        <h3 id="omgf">OMGF / Fonctionnement</h3>
        <p>A faire...</p>
        <p>Exemple d'objet de sac de jetons :</p>
        <pre>
TYP:tokenpool
SID:5f3ad5265bb3306b3266e1935d067d9ec15965d0a970554bc6161eb3328907a9
CAP:TYP MOD SID CAP AID MID NAM UNI DTA DTC DTD COM CPR IDM IDR IDP VMD VID TRS CID PID FID BID VAL CLB CLD SVC TID
CID:daf832e3042cc849efcd5b6531df835a9c5f6251b2101e20972f9a9db2a8ae24
FID:f0f7cf5c921320b97daedeb7c53f2417921c747c77b696f8a25ff29277661d2f
MID:f0f7cf5c921320b97daedeb7c53f2417921c747c77b696f8a25ff29277661d2f
</pre>
        <p>Un sac de jetons va disposer de plusieurs propriétés connues par leurs abréviations, voir <a href="#omgcp">OMGCP</a>.
        </p>
        <p>A faire...</p>

        <h3 id="omgn">OMGN / Nommage</h3>
        <p>Un sac de jetons hérite du nommage de la monnaie à laquelle il est rattaché.</p>
        <p>Le nom complet d'un objet de type sac de jetons est uniquement extrait de la propriété <code>NAM</code>. Dans
            certains cas il peut êrte formé de <code>NAM(UNI)</code> mais la propriété <code>UNI</code> a plutôt
            vocation a être utilisée dans un affichage condensé.</p>

        <h3 id="omgp">OMGP / Protection</h3>
        <p>A faire...</p>

        <h3 id="omgd">OMGD / Dissimulation</h3>
        <p>A faire...</p>

        <h3 id="omgl">OMGL / Liens</h3>
        <p>A faire...</p>

        <h3 id="omgv">OMGV / Valeur</h3>
        <p>La valeur du sac de jeton, à un instant donné, est égale à la somme des jetons du sac au même instant.</p>

        <h3 id="omgc">OMGC / Création</h3>
        <p>A faire...</p>

        <h4 id="omgcl">OMGCL / Liens</h4>
        <p>Liste des liens à générer lors de la création d'un sac de jetons.</p>
        <p>A faire...</p>

        <h4 id="omgcp">OMGCP / Propriétés</h4>
        <p></p>

        <h5 id="omgcph">OMGCPH / Héritage</h5>
        <p>Certaines propriétés sont héritées de la monnaie, si ces propriétés sont définies dans la monnaie. Ce doit
            être la monnaie déclarée en cours d'utilisation et le sac de jetons doit dépendre de cette monnaie
            directement. Les héritages sont prioritaires sur les propriétés définies via l'objet et les liens.</p>

        <h5 id="omgcphct">OMGCPHCT / HCT</h5>
        <p>Définit si l'objet du sac de jetons a un contenu. Si il n'a pas de contenu l'objet du sac de jetons est
            virtuel et correspond à son SID, et les paramètres du sac de jetons ne peuvent pas être forcés.</p>
        <p>Ce n'est pas écrit dans l'objet du sac de jetons ni enregistré via des liens. Cela sert uniquement au moment
            de la création d'un sac de jetons.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie.</p>

        <h5 id="omgcptyp">OMGCPTYP / TYP</h5>
        <p>Le type de sac de jetons.</p>
        <p>Toujours à la valeur <i>tokenpool</i>.</p>
        <p>Présence obligatoire en ligne 1 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie.</p>

        <h5 id="omgcpsid">OMGCPSID / SID</h5>
        <p>Le numéro de série identifiant du sac de jetons (<i>serial</i>).</p>
        <p>Si l'objet de référence du sac de jetons est virtuel, l'identifiant du sac de jetons <code>PID</code> sera le
            <code>SID</code>.</p>
        <p>Si l'objet de référence du sac de jetons n'est pas virtuel, l'identifiant du sac de jetons <code>PID</code>
            dépend du contenu de l'objet et est rendu unique grâce à la propriété <code>SID</code>.</p>
        <p>La valeur est de préférence aléatoire mais peut être un compteur à condition d'être unique. L’utilisation
            d’un compteur de faible valeur est fortement déconseillée.</p>
        <p>Si aléatoire, la génération pseudo aléatoire du <code>SID</code> est faite en partant d’un dérivé de la date
            avec quelques valeurs locales. Il n’y a pas de contrainte de sécurité sur cette valeur. Puis une boucle
            interne génère un bon aléa au fur et à mesure de la génération des jetons via une fonction de hash. Le tout
            ne consomme pas du tout de précieux aléa de bonne qualité.</p>
        <p>Présence obligatoire en ligne 2 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie.</p>

        <h5 id="omgcpcap">OMGCPCAP / CAP</h5>
        <p>Liste des capacités connues du sac de jetons.</p>
        <p>Si une capacité n'est pas présente elle ne peut être invoquée, même si elle est forcée.</p>
        <p>Présence obligatoire en ligne 3 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omgcpcid">OMGCPCID / CID</h5>
        <p>Identifiant de l’objet de la monnaie auquel est rattaché le sac de jetons (<i>currency</i>).</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence obligatoire en ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omgcpfid">OMGCPFID / FID</h5>
        <p>Identifiant de l'entité ayant forgé le sac de jetons (<i>forge</i>).</p>
        <p>L'entité forge doit désigner une entité de gestion, par défaut c'est elle-même.</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie.</p>

        <h5 id="omgcpmid">OMGCPMID / MID</h5>
        <p>Identifiant de l'entité de gestion du sac de jetons (<i>manage</i>).</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie.</p>

        <h5 id="omgcppid">OMGCPPID / PID</h5>
        <p>Identifiant de l’objet du sac de jetons (<i>pool</i>).</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>L'objet d'un sac de jetons ne peut en aucun cas contenir son propre identifiant <code>PID</code>.</p>

        <h5 id="omgcpdta">OMGCPDTA / DTA</h5>
        <p>Identifiant de l’entité autorité de temps pour les limites de temps.</p>
        <p>La gestion du temps avec une autorité de temps permet de prendre en compte sérieusement les suppression
            programmées de jeton (<code>DTC</code>/<code>DTD</code>) ainsi que leur inflation/déflation automatique
            (<code>IDM</code>/<code>IDR</code>/<code>IDP</code>).</p>
        <p>L’autorité de temps peut être spécifique pour chaque jeton mais il est plus logique qu’elle soit commune à
            une monnaie ou dans certains cas à un sac de jetons.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omgcpdtc">OMGCPDTC / DTC</h5>
        <p>Date de création du sac de jetons.</p>
        <p>Forme texte libre limitée à 128 caractères. Doit pourvoir être interprété comme une date.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omgcpdtd">OMGCPDTD / DTD</h5>
        <p>Date de suppression programmée du sac de jetons.</p>
        <p> Forme texte libre limitée à 128 caractères. Doit pourvoir être interprété comme une date pour être
            fonctionel.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omgcpcom">OMGCPCOM / COM</h5>
        <p>Commentaire texte libre limité à 4096 caractères.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie.</p>

        <h5 id="omgcpcpr">OMGCPCPR / CPR</h5>
        <p>Licence du jeton sous forme d’une texte libre limité à 1024 caractères.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie.</p>

        <h5 id="omgcpidm">OMGCPIDM / IDM</h5>
        <p>Mode de fonctionnement du mécanisme d’inflation/déflation (<i>mode</i>) des jetons dépendants du sac de
            jetons.</p>
        <p>Les modes sont <i>creation</i> ou <i>transaction</i> ou <i>disabled</i>.</p>
        <p>Suivant le mode, le mécanisme tient compte du temps passé depuis la dernière transaction ou depuis l’émission
            du jeton.</p>
        <p>Le mécanisme d’inflation/déflation (<code>IDM</code>/<code>IDR</code>/<code>IDP</code>), si activé, avec un
            taux de variation inférieur à 1, donc en déflation, permet de forcer les détenteurs de jeton à les utiliser
            plutôt que de les stocker. Les jetons concernés vont donc perdre de la valeur par rapport aux nouveaux
            jetons ou par rapport à ceux qui circulent.</p>
        <p>Si activé, avec un taux de variation suppérieur à 1, donc en inflation, permet de favoriser la conservation
            des jetons et valorise les vieux jetons sur les nouveaux ou ceux qui circulent beaucoup.</p>
        <p>En ne forçant pas cette propriété dans l'objet des jetons, il est possible d'avoir un taux de variation
            fluctuant en fonction des besoins. En le positionnant forçé à <i>disabled</i> cela désactive définitivement
            ce mécanisme au niveau du sac de jetons et de tous les jetons en dépendant.</p>
        <p>Un jeton peut se déprécier avec le temps mais une entité peut demander à l’autorité émettrice de la monnaie
            un échange de jeton ancien contre un jeton plus jeune, si l’autorité émettrice le permet.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>CF <a href="#omcpidm">C/IDM</a>.</p>

        <h5 id="omgcpidr">OMGCPIDR / IDR</h5>
        <p>Taux de variation du mécanisme d’inflation/déflation (<i>rate</i>) des jetons dépendants du sac de jetons.
        </p>
        <p>Égal à 1 (un), taux constant donc pas de variation.</p>
        <p>Doit être activé par <code>IDM</code>.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omgcpidp">OMGCPIDP / IDP</h5>
        <p>Périodicité d’application du taux de variation du mécanisme d’inflation/déflation (<i>period</i>) des jetons
            dépendants du sac de jetons.</p>
        <p>Unité exprimée en minutes.</p>
        <p>Si à 0 (zéro), la période n'est pas utilisé, donc la variation est non effective.</p>
        <p>Doit être activé par <code>IDM</code>.</p>
        <p>Présence facultative sans ordre après la ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omgcptcn">OMGCPTCN / TCN</h5>
        <p>Non utilisé !!!</p>
        <p>Définit le nombre de jetons à créer dans le pool ou par pools créés (cf <a href="#omcppcn">PCN</a>).</p>
        <p>Ce n'est pas écrit dans l'objet du sac de jetons ni enregistré via des liens. Cela sert uniquement au moment
            de la création d'un sac de jetons. Cependant un lien de rattachement sera créé pour chaque jeton depuis le
            sac de jeton avec en meta le <a href="#omjcptid"></a>TID</a>.</p>

        <h3 id="omgs">OMGS / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="omgt">OMGT/ Transfert</h3>
        <p>A faire...</p>

        <h3 id="omgr">OMGR / Réservation</h3>
        <p>Les objets réservés spécifiquement pour les sacs de jetons :</p>
        <ul>
            <li>nebule/objet/monnaie/sac</li>
        </ul>

        <h3 id="omgo">OMGO / Oubli</h3>
        <p>L'oubli vonlontaire de certains liens et objets n'est encore ni théorisé ni implémenté mais deviendra
            indispensable lorsque l'espace viendra à manquer (cf <a href="#cn">CN</a>).</p>


        <h3 id="omj">OMJ / Jeton</h3>
        <p>A faire...</p>

        <h3 id="omjf">OMJF / Fonctionnement</h3>
        <p>Un jeton est un objet de référence qui va servir de support de transmission de valeur. Il est attaché à un ou
            plusieurs sacs de jetons. Sa gestion se fait dans des monnaies par l'intermédiaire de sacs de jetons
            attachés aux monnaies.</p>
        <p>Le jeton plus simple est un objet virtuel dont l’identifiant (<code>TID</code>) est généré aléatoirement. Ce
            peut être un simple compteur aussi mais chaque identifiant doit être unique par monnaie, et donc par sac de
            jetons aussi. L’utilisation d’un compteur de faible valeur est fortement déconseillé pour le
            <code>TID</code>. Par exemple :</p>
        <code>4d831b11bbf828b9cfd4752223bb8918cbd634c4b858691736afd8b34f1f0c62</code>
        <p>La deuxième forme de jeton est donc un objet dont le contenu va donner par son empreinte cryptographique un
            identifiant de jeton unique (<code>TID</code>). Il n’est dans ce cas pas possible d’avoir un compteur
            puisque les valeurs de identifiant sont assimilées à des valeurs aléatoires.</p>
        <p>Exemple d'objet de jeton :</p>
        <pre>
TYP:cryptoken
SID:5f3ad5265bb3306b3266e1935d067d9ec15965d0a970554bc6161eb3328907a9
CAP:TYP MOD SID CAP AID MID NAM UNI DTA DTC DTD COM CPR IDM IDR IDP VMD VID TRS CID PID FID BID VAL CLB CLD SVC TID
CID:daf832e3042cc849efcd5b6531df835a9c5f6251b2101e20972f9a9db2a8ae24
PID:37aa32a2cec224ae908226eb1c600fbeacd5faf1f84b2e292c0be808c0296333
FID:f0f7cf5c921320b97daedeb7c53f2417921c747c77b696f8a25ff29277661d2f
NAM:poux
UNI:pou
VAL:100
</pre>
        <p>Un jeton va disposer de plusieurs propriétés connues par leurs abréviations, voir <a href="#omjcp">OMJCP</a>.
        </p>

        <h3 id="omjn">OMJN / Nommage</h3>
        <p>Un jeton hérite du nommage de la monnaie via le sac de jeton auquel il est rattaché.</p>
        <p>Le nom complet d'un objet de type jeton est uniquement extrait de la propriété <code>NAM</code>. Dans
            certains cas il peut êrte formé de <code>NAM(UNI)</code> mais la propriété <code>UNI</code> a plutôt
            vocation a être utilisée dans un affichage condensé avec une valeur.</p>

        <h3 id="omjp">OMJP / Protection</h3>
        <p>A faire...</p>

        <h3 id="omjd">OMJD / Dissimulation</h3>
        <p>A faire...</p>

        <h3 id="omjl">OMJL / Liens</h3>
        <p>A faire...</p>

        <h3 id="omjv">OMJV / Valeur</h3>
        <p>C’est une valeur calculée strictement numérique du jeton à un instant donné par rapport à une monnaie. Elle
            s'appelle la valeur relative du jeton.</p>
        <p>Par défaut, si <code>VAL</code> non défini, la valeur de <code>VAL</code> est à interpréter comme équivalente
            à 1 (un).</p>
        <p>Ce n'est pas écrit dans l'objet du jeton ni enregistré via des liens. La valeur relative du jeton est
            recalculée à chaque usage du jeton en fonction des paramêtres <code>DTA</code>, <code>DTC</code>,
            <code>DTD</code>, <code>IDM</code>, <code>IDR</code>, <code>IDP</code>, <code>CLB</code> et <code>CLD</code>.
        </p>
        <p>Si le jeton est désactivé, sa valeur relative est nulle.</p>
        <p>A faire... le détail des calculs de la valeur relative en fonction de chaque propriétés citées.</p>

        <h3 id="omjc">OMJC / Création</h3>
        <p>Si l'objet de référence du jeton est virtuel, il est forçément généré aléatoirement. Sinon il dépend du
            contenu de l'objet et est rendu unique grâce à la propriété <a href="#omjcpsid">SID</a>.</p>
        <p>Un jeton va disposer de plusieurs propriétés connues par leurs abréviations.</p>
        <p>Le contenu des objets des jetons va recevoir plusieurs lignes de type <code>clé:valeur</code>. Chaque ligne
            débute par trois lettre en majuscules définissant le sens sémantique (<i>clé</i>) de la ligne, suivi d’un
            deux-points ( <code>:</code> ) et de la valeur associée. La valeur est un texte en minuscule sans caractères
            spéciaux, l’espace des caractères est limité aux lettres minuscules, aux chiffres, à l’espace (sauf au début
            et à la fin), au point, à la virgule et à l’égal. La valeur est par défaut limité en taille à 1024
            caractères sauf mention contraire pour une propriété. Il ne doit pas y avoir d’espace sur une ligne, ni en
            début et fin de ligne, ni autour du deux-points. Chaque ligne est terminée par un retour chariot type UNIX.
        </p>
        <p>Chaque propriété d’un jeton que l’on retrouve sous forme <code>clé:valeur</code> va être doublé d’un lien.
            Cependant les liens pouvant être annulés, les propriétés à figer sont écrites dans le jeton. Ainsi, une
            <code>clé:valeur</code> inscrite dans le jeton est prioritaire sur un lien équivalent.</p>
        <p>Dans l'objet du jeton, les clés <a href="#omjcptyp">TYP</a> et <a href="#omjcpsid">SID</a> sont obligatoires,
            toujours au début et dans cet ordre.</p>
        <p>Le début de contenu avec <code>TYP:cryptoken</code> permet de marquer un type de contenu facile à vérifier.
        </p>
        <p>La seconde ligne avec le <a href="#omjcpsid">SID</a> permet d’avoir un contenu unique et donc une empreinte
            unique pour chaque jeton.</p>

        <h4 id="omjcl">OMJCL / Liens</h4>
        <p>Liste des liens à générer lors de la création d'un jeton.</p>
        <p>A faire...</p>

        <h4 id="omjcp">OMJCP / Propriétés</h4>
        <p></p>

        <h5 id="omjcph">OMJCPH / Héritage</h5>
        <p>Certaines propriétés sont héritées de la monnaie, si ces propriétés sont définies dans la monnaie. Ce doit
            être la monnaie déclarée en cours d'utilisation et le jeton doit dépendre de cette monnaie via un sac de
            jetons. De la même façon certaines propriétés sont héritées en second lieu du sac de jeton. Les héritages
            sont prioritaires sur les propriétés définies via l'objet et les liens.</p>

        <h5 id="omjcphct">OMJCPHCT / HCT</h5>
        <p>Définit si l'objet du jeton a un contenu. Si il n'a pas de contenu l'objet du jeton est virtuel et correspond
            à son SID, et les paramètres du jeton ne peuvent pas être forcés.</p>
        <p>Ce n'est pas écrit dans l'objet du jeton ni enregistré via des liens. Cela sert uniquement au moment de la
            création d'un jeton.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie ou du sac de jetons.</p>

        <h5 id="omjcptyp">OMJCPTYP / TYP</h5>
        <p>Le type de jeton.</p>
        <p>Toujours à la valeur <i>cryptoken</i>.</p>
        <p>Présence obligatoire en ligne 1 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie ou du sac de jetons.</p>

        <h5 id="omjcpsid">OMJCPSID / SID</h5>
        <p>Le numéro de série identifiant le jeton (<i>serial</i>).</p>
        <p>Si l'objet de référence du jeton est virtuel, l'identifiant du jeton <code>TID</code> sera le
            <code>SID</code>.</p>
        <p>Si l'objet de référence du jeton n'est pas virtuel, l'identifiant du jeton <code>TID</code> dépend du contenu
            de l'objet et est rendu unique grâce à la propriété <code>SID</code>.</p>
        <p>La valeur est de préférence aléatoire mais peut être un compteur à condition d'être unique. L’utilisation
            d’un compteur de faible valeur est fortement déconseillée.</p>
        <p>Si aléatoire, la génération pseudo aléatoire du <code>SID</code> est faite en partant d’un dérivé de la date
            avec quelques valeurs locales. Il n’y a pas de contrainte de sécurité sur cette valeur. Puis une boucle
            interne génère un bon aléa au fur et à mesure de la génération des jetons via une fonction de hash. Le tout
            ne consomme pas du tout de précieux aléa de bonne qualité.</p>
        <p>Présence obligatoire en ligne 2 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie ou du sac de jetons.</p>

        <h5 id="omjcpcap">OMJCPCAP / CAP</h5>
        <p>Liste des capacités connues du jeton.</p>
        <p>Si une capacité n'est pas présente elle ne peut être invoquée, même si elle est forcée.</p>
        <p>Le contenu de cette propriété est hérité de la monnaie.</p>
        <p>Présence obligatoire en ligne 3 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpcid">OMJCPCID / CID</h5>
        <p>Identifiant de l’objet de la monnaie (<i>currency</i>).</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence obligatoire en ligne 4 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcppid">OMJCPPID / PID</h5>
        <p>Identifiant de l’objet du sac de jetons (<i>pool</i>).</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence facultative sans ordre après la ligne 2 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Présence obligatoire en ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcptid">OMJCPTID / TID</h5>
        <p>Identifiant du jeton.</p>
        <p>Sa valeur est égale à l'identifiant de l'objet.</p>
        <p>L'objet d'un jeton ne peut en aucun cas contenir son propre identifiant <code>TID</code>.</p>

        <h5 id="omjcpfid">OMJCPFID / FID</h5>
        <p>Identifiant de l'entité ayant forgé le jeton (<i>forge</i>).</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie ou du sac de jetons.</p>

        <h5 id="omjcpbid">OMJCPBID / BID</h5>
        <p>Identifiant du bloc de forge (<i>blockchain</i>).</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie ou du sac de jetons.</p>

        <h5 id="omjcpnam">OMJCPNAM / NAM</h5>
        <p>Le nom de la monnaie. Limité à 256 caractères.</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpuni">OMJCPUNI / UNI</h5>
        <p>Le nom de l'unité de la monnaie en 3 lettres maximum. Pas de chiffre.</p>
        <p>Une monnaie peut tout à fait réutiliser un sac de jetons et des propriétés d’une autre monnaie sans qu’il y
            ai conflit dans la gestion des jetons et de leurs transactions. Les valeurs associées peuvent être copiées
            sans que cela ne pose de problème.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpval">OMJCPVAL / VAL</h5>
        <p>Indication de valeur numérique initiale du jeton dans l’unité de la monnaie qui utilise le jeton.</p>
        <p>C’est une valeur strictement numérique.</p>
        <p>Par défaut, si non présent, la valeur est à interpréter comme équivalente à 1 (un).</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpdta">OMJCPDTA / DTA</h5>
        <p>Identifiant de l’entité autorité de temps pour les limites de temps.</p>
        <p>La gestion du temps avec une autorité de temps permet de prendre en compte sérieusement les suppression
            programmées de jeton (<code>DTC</code>/<code>DTD</code>) ainsi que leur inflation/déflation automatique
            (<code>IDM</code>/<code>IDR</code>/<code>IDP</code>).</p>
        <p>L’autorité de temps peut être spécifique pour chaque jeton mais il est plus logique qu’elle soit commune à
            une monnaie ou dans certains cas à un sac de jetons.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpdtc">OMJCPDTC / DTC</h5>
        <p>Date de création du jeton.</p>
        <p>Forme texte libre limitée à 128 caractères. Doit pourvoir être interprété comme une date.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpdtd">OMJCPDTD / DTD</h5>
        <p>Date de suppression programmée du jeton.</p>
        <p> Forme texte libre limitée à 128 caractères. Doit pourvoir être interprété comme une date pour être
            fonctionel.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpcom">OMJCPCOM / COM</h5>
        <p>Commentaire texte libre limité à 4096 caractères.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie ou du sac de jetons.</p>

        <h5 id="omjcpcpr">OMJCPCPR / CPR</h5>
        <p>Licence du jeton sous forme d’une texte libre limité à 1024 caractères.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>Cette propriété ne peut pas être hérité de la monnaie ou du sac de jetons.</p>

        <h5 id="omjcpidm">OMJCPIDM / IDM</h5>
        <p>Mode de fonctionnement du mécanisme d’inflation/déflation (<i>mode</i>) du jeton.</p>
        <p>Les modes sont <i>creation</i> ou <i>transaction</i> ou <i>disabled</i>.</p>
        <p>Suivant le mode, le mécanisme tient compte du temps passé depuis la dernière transaction ou depuis l’émission
            du jeton.</p>
        <p>Le mécanisme d’inflation/déflation (<code>IDM</code>/<code>IDR</code>/<code>IDP</code>), si activé, avec un
            taux de variation inférieur à 1, donc en déflation, permet de forcer les détenteurs de jeton à les utiliser
            plutôt que de les stocker. Les jetons concernés vont donc perdre de la valeur par rapport aux nouveaux
            jetons ou par rapport à ceux qui circulent.</p>
        <p>Si activé, avec un taux de variation suppérieur à 1, donc en inflation, permet de favoriser la conservation
            des jetons et valorise les vieux jetons sur les nouveaux ou ceux qui circulent beaucoup.</p>
        <p>En ne forçant pas cette propriété dans l'objet des jetons, il est possible d'avoir un taux de variation
            fluctuant en fonction des besoins. En le positionnant forçé à <i>disabled</i> cela désactive définitivement
            ce mécanisme au niveau du jeton.</p>
        <p>Un jeton peut se déprécier avec le temps mais une entité peut demander à l’autorité émettrice de la monnaie
            un échange de jeton ancien contre un jeton plus jeune, si l’autorité émettrice le permet.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>
        <p>CF <a href="#omcpidm">C/IDM</a>.</p>

        <h5 id="omjcpidr">OMJCPIDR / IDR</h5>
        <p>Taux de variation du mécanisme d’inflation/déflation (<i>rate</i>) du jeton.</p>
        <p>Égal à 1 (un), taux constant donc pas de variation.</p>
        <p>Doit être activé par <code>IDM</code>.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpidp">OMJCPIDP / IDP</h5>
        <p>Périodicité d’application du taux de variation du mécanisme d’inflation/déflation (<i>period</i>) du jeton.
        </p>
        <p>Unité exprimée en minutes.</p>
        <p>Si à 0 (zéro), la période n'est pas utilisé, donc la variation est non effective.</p>
        <p>Doit être activé par <code>IDM</code>.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpsvc">OMJCPSVC / SVC</h5>
        <p>Le jeton fait référence à un type de service rendu (<i>service</i>).</p>
        <p>Taille limitée à 1024 caractères.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpclb">OMJCPCLB / CLB</h5>
        <p>Le jeton peut être désactivé (<i>cancelable</i>).</p>
        <p>Par défaut un jeton n’est pas désactivable. Si cette option est présente, quelque soit son contenu, cela
            active la capacité de désactivation à la demande du jeton par la propriété <code>CLD</code>.</p>
        <p>Elle n’a pas d’action sur la propriété de désactivation programmée <code>DTD</code>. Un jeton peut avoir une
            date de suppression programmée et être non désactivable avant la date de suppression. Activer la propriété
            <code>CLD</code> de façon forcée dans le contenu du jeton est faisable mais n’a pas de sens. Des jetons
            peuvent être générés désactivés et activés à posteriori.</p>
        <p>Un jeton désactivé ne peut pas faire parti d’une transaction.</p>
        <p>La taille est de un caractère maximum.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcpcld">OMJCPCLD / CLD</h5>
        <p>Le jeton est désactivé (<i>canceled</i>).</p>
        <p>Cette propriété n’est d’utilisée que si <code>CLB</code> est activé.</p>
        <p>Si cette option est présente, quelque soit son contenu, cela désactive le jeton.</p>
        <p>Un jeton désactivé ne peut pas faire parti d’une transaction.</p>
        <p>La taille est de un caractère maximum.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h5 id="omjcptrs">OMJCPTRS / TRS</h5>
        <p>Liste des méthodes de transaction supportées.</p>
        <p>Les modes sont définis dans le chapitre <a href="omjm">modes de transfert</a>. Les modes supportés sont
            écrits les uns après les autres sur une seule ligne et séparés par un caractère espace.</p>
        <p>Le contenu de cette propriété est hérité de la monnaie.</p>
        <p>Présence facultative sans ordre après la ligne 5 dans l'objet si l'objet n'est pas virtuel.</p>

        <h3 id="omjs">OMJS / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="omjt">OMJT/ Transfert</h3>
        <p>Le jeton peut faire l'objet de deux types de transferts. Il y a la méthode de transfert de l'information
            (liens et objets) et le marquage du transfert de valeur.</p>
        <h4 id="omjti">OMJTI/ Transfert d'information</h4>
        <p>A faire...</p>

        <h4 id="omjtv">OMJTV/ Transfert de valeur</h4>
        <p>Le transfert de valeur est appelé transaction.</p>
        <p>La transaction unitaire marque l'attribution univoque et unidirectionnel d'une valeur appartenant à une
            entité vers une autre entité. Cette transaction unitaire peut être faite en contrepartie d'une autre valeur
            physique ou virtuelle, mais cette autre valeur n'est pas directement représentée dans la transaction
            unitaire traitée.</p>
        <p>Ici nous appelerons transaction soit une transaction unitaire, soit un block de plusieurs transactions
            unitaires. Les valeurs attribuées dans un block de transactions sont soit des jetons complets, soit des
            parties de jetons. Cependant une transaction unitaire ne peut traiter qu'un unique jeton ou qu'une unique
            partie d'un unique jeton. Dans un block de transactions, toutes les transactions unitaires doivent traiter
            de la même monnaie.</p>
        <p>Une contrepartie d'une autre valeur physique ou virtuelle peut au besoin être inscrite dans un jeton comme
            description. Ce mécanisme nécessite un suivi particulier qui n'est pas pris en charge ici.</p>
        <p>Dans le code, la transaction est traité comme un lien. Si le lien est suffisant, dans le mode LNS (cf <a
                    href="omjcptrs">TRS</a>), alors l'attribution du jeton peut être faite sur le lien uniquement. Si le
            lien fait référence à un objet tier, celui est considéré comme un block de transaction et est lu afin d'en
            extraire toutes les transactions unitaires.</p>

        <h4 id="omjm">OMJM/ Modes de transfert</h4>

        <h5 id="omjmlns">OMJMLNS/ Mode LNS</h5>
        <p>Le code <code>LNS</code> désigne la méthode de base avec un lien (L) matérialisant une transaction et
            imposant un jeton non sécable (NS).</p>
        <p>A faire...</p>

        <h3 id="omjr">OMJR / Réservation</h3>
        <p>Les objets réservés spécifiquement pour les jetons :</p>
        <ul>
            <li>nebule/objet/monnaie/jeton</li>
        </ul>

        <h3 id="omjo">OMJO / Oubli</h3>
        <p>L'oubli vonlontaire de certains liens et objets n'est encore ni théorisé ni implémenté mais deviendra
            indispensable lorsque l'espace viendra à manquer (cf <a href="#cn">CN</a>).</p>

        <?php
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe TokenPool.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID d'un sac de jetons ou 'new' ;
 * - un tableau des paramètres du nouveau sac de jetons.
 *
 * L'ID d'un sac de jetons est forcément un texte en hexadécimal.
 *
 * Si une erreur survient lors de la lecture de le sac de jetons ou lors de la création, assigne l'ID 0.
 * ------------------------------------------------------------------------------------------
 */
class TokenPool extends Currency
{
    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_id',
        '_fullname',
        '_cachePropertyLink',
        '_cachePropertiesLinks',
        '_cachePropertyID',
        '_cachePropertiesID',
        '_cacheProperty',
        '_cacheProperties',
        '_cacheMarkDanger',
        '_cacheMarkWarning',
        '_cacheMarkProtected',
        '_idProtected',
        '_idUnprotected',
        '_idProtectedKey',
        '_idUnprotectedKey',
        '_markProtectedChecked',
        '_cacheCurrentEntityUnlocked',
        '_usedUpdate',
        '_isEntity',
        '_isGroup',
        '_isConversation',
        '_isCurrency',
        '_isTokenPool',
        '_isToken',
        '_isWallet',
        '_properties',
        '_propertiesInherited',
        '_propertiesForced',
        '_seed',
        '_inheritedCID',
        '_inheritedPID',
    );

    /**
     * Constructeur.
     *
     * Toujours transmettre l'instance de la librairie nebule.
     * Si le sac de jetons existe, juste préciser l'ID de celui-ci.
     * Si c'est un nouveau sac de jetons à créer, mettre l'ID à 'new'.
     *
     * @param nebule $nebuleInstance
     * @param string $id
     * @param array $param si $id == 'new'
     * @param boolean $protected si $id == 'new'
     * @param boolean $obfuscated si $id == 'new'
     */
    public function __construct(nebule $nebuleInstance, $id, $param = array(), $protected = false, $obfuscated = false)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();

        // Complément des paramètres.
        //$this->_propertiesList['currency']['CurrencyForgeID']['force'] = $this->_nebuleInstance->getCurrentEntity();
//		$this->_propertiesList['tokenpool']['PoolCurrencyID']['force'] = $this->_nebuleInstance->getCurrentCurrency();
//		$this->_propertiesList['tokenpool']['PoolForgeID']['force'] = $this->_nebuleInstance->getCurrentEntity();
//		$this->_propertiesList['token']['TokenForgeID']['force'] = $this->_nebuleInstance->getCurrentEntity();

        $id = trim(strtolower($id));
        $this->_metrology->addLog('New instance token pool ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.

        if (is_string($id)
            && $id != ''
            && ctype_xdigit($id)
        ) {
            // Si l'ID est cohérent et l'objet nebule présent, c'est bon.
            $this->_loadTokenPool($id);
        } elseif (is_string($id)
            && $id == 'new'
        ) {
            // Si c'est un nouveau sac de jetons à créer, renvoie à la création.
            $this->_createNewTokenPool($param, $protected, $obfuscated);
        } else {
            // Sinon, le sac de jetons est invalide, retourne 0.
            $this->_id = '0';
        }
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     *  Chargement d'un sac de jetons existant.
     *
     * @param string $id
     */
    private function _loadTokenPool($id)
    {
        // Vérifie que c'est bien un objet.
        if (!is_string($id)
            || $id == ''
            || !ctype_xdigit($id)
            || !$this->_io->checkLinkPresent($id)
            || !$this->_nebuleInstance->getOption('permitCurrency')
        ) {
            $id = '0';
        }

        $this->_id = $id;
        $this->_metrology->addLog('Load token pool ' . $id, Metrology::LOG_LEVEL_DEBUG); // Log

        // On ne recherche pas les paramètres si ce n'est pas un sac de jetons.
        if ($this->getIsTokenPool('myself')) {
            $this->setAID();
            $this->setFID('0');
        }

        // Vérifie le sac de jetons.
        $TYP = $this->_getParamFromObject('TYP', (int)$this->_propertiesList['tokenpool']['PoolType']['limit']);
        $SID = $this->_getParamFromObject('SID', (int)$this->_propertiesList['tokenpool']['PoolSerialID']['limit']);
        $CID = $this->_getParamFromObject('CID', (int)$this->_propertiesList['tokenpool']['PoolCurrencyID']['limit']);
        if ($TYP == ''
            || $SID == ''
            || $CID == ''
        ) {
            $this->_id = '0';
        } else {
            $this->_propertiesList['tokenpool']['PoolID']['force'] = $id;
            $this->_properties['PID'] = $id;
        }
        $this->_propertiesForced['TYP'] = true;
        $this->_propertiesForced['SID'] = true;
        $this->_propertiesForced['CID'] = true;
        $this->_propertiesForced['PID'] = true;
    }

    /**
     * Création d'une nouveau sac de jetons.
     *
     * @param array $param
     * @return boolean
     */
    private function _createNewTokenPool($param, $protected = false, $obfuscated = false)
    {
        $this->_metrology->addLog('Ask create token pool', Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie que l'on puisse créer un sac de jetons.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCurrency')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            // Génère la nouveau sac de jetons.
            $this->_id = $this->_createTokenPool($param, $protected, $obfuscated);

            // Si la génération s'est mal passée.
            if ($this->_id == '0') {
                $this->_metrology->addLog('Create token pool error on generation', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_id = '0';
                return false;
            }
        } else {
            $this->_metrology->addLog('Create token pool error not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_id = '0';
            return false;
        }
    }


    /**
     * Crée un sac de jetons.
     *
     * Les paramètres force* ne sont utilisés que si PoolHaveContent est à true.
     * Pour l'instant le code commence à prendre en compte PoolHaveContent à false mais le paramètre est forçé à true tant que le code n'est pas prêt.
     *
     * Les options pour la génération d'un sac de jetons :
     * poolHaveContent
     * poolSerialID
     * poolForgeID
     * poolCurrencyID
     * poolComment
     * poolCopyright
     * poolTokenCount
     *
     * forcePoolForgeID
     * forcePoolCurrencyID
     * forcePoolComment
     * forcePoolCopyright
     *
     * Retourne la chaine avec 0 si erreur.
     *
     * @param array $param
     * @param boolean $protected
     * @param boolean $obfuscated
     * @return string
     */
    private function _createTokenPool($param, $protected = false, $obfuscated = false)
    {
        // Identifiant final du sac de jetons.
        $this->_id = '0';

        // Normalise les paramètres.
        $this->_normalizeInputParam($param);

        // Force l'écriture de l'objet du sac de jetons.
        $param['PoolHaveContent'] = true;

        // Force l'écriture du serial.
        $param['ForcePoolSerialID'] = true;

        // Détermine si le sac de jetons a un numéro de série fourni.
        $sid = '';
        if (isset($param['PoolSerialID'])
            && is_string($param['PoolSerialID'])
            && $param['PoolSerialID'] != ''
            && ctype_xdigit($param['PoolSerialID'])
        ) {
            $sid = $this->_stringFilter($param['PoolSerialID']);
            $this->_metrology->addLog('Generate token pool asked SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        } else {
            // Génération d'un identifiant de sac de jetons unique aléatoire.
            $sid = $this->_getPseudoRandom();
            $param['PoolSerialID'] = $sid;
            $this->_metrology->addLog('Generate token pool rand SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        }

        // Détermine la monnaie associée.
        $instanceCurrency = $this->_nebuleInstance->getCurrentCurrencyInstance();
        if ($instanceCurrency->getID() != '0') {
            $this->_propertiesList['tokenpool']['PoolCurrencyID']['force'] = $instanceCurrency->getID();
            $param['PoolCurrencyID'] = $instanceCurrency->getID();
        } else {
            $this->_metrology->addLog('Generate token pool SID:' . $sid . ' - error no valid CID selected', Metrology::LOG_LEVEL_ERROR); // Log
            return '0';
        }

        // Détermine le forgeur.
        $this->_propertiesList['tokenpool']['PoolForgeID']['force'] = $this->_nebuleInstance->getCurrentEntity();
        $param['PoolForgeID'] = $this->_nebuleInstance->getCurrentEntity();


        // Détermine si le jeton doit avoir un contenu.
        if (isset($param['PoolHaveContent'])
            && $param['PoolHaveContent'] === true
        ) {
            $this->_metrology->addLog('Generate token pool SID:' . $sid . ' HCT:true', Metrology::LOG_LEVEL_DEBUG); // Log

            // Le contenu final commence par l'identifiant interne du sac de jetons.
            $content = 'TYP:' . $this->_propertiesList['tokenpool']['PoolType']['force'] . "\n"; // @todo peut être intégré au reste.
            $this->_metrology->addLog('Generate token pool SID:' . $sid . ' TYP:' . $this->_propertiesList['tokenpool']['PoolType']['force'], Metrology::LOG_LEVEL_DEBUG); // Log
            $content .= 'SID:' . $sid . "\n";
            $content .= 'CID:' . $param['PoolCurrencyID'] . "\n";
            $this->_metrology->addLog('Generate token pool SID:' . $sid . ' CID:' . $param['PoolCurrencyID'], Metrology::LOG_LEVEL_NORMAL); // Log

            // Pour chaque propriété, si présente et forcée, l'écrit dans l'objet.
            foreach ($this->_propertiesList['tokenpool'] as $name => $property) {
                if ($property['key'] != 'HCT'
                    && $property['key'] != 'TYP'
                    && $property['key'] != 'SID'
                    && $property['key'] != 'CID'
                    //&& $property['key'] != 'PCN'
                    //&& $property['key'] != 'TCN'
                    && isset($property['forceable'])
                    && $property['forceable'] === true
                    && isset($param['Force' . $name])
                    && $param['Force' . $name] === true
                    && isset($param[$name])
                    && $param[$name] != ''
                    && $param[$name] != null
                ) {
                    $value = null;
                    if ($property['type'] == 'boolean') {
                        if ($param[$name] === true) {
                            $value = true;
                        } else {
                            $value = false;
                        }
                    } elseif ($property['type'] == 'number') {
                        $value = (string)$param[$name];
                    } else {
                        $value = $param[$name];
                    }

                    // Ajoute la ligne.
                    $content .= $property['key'] . ':' . $value . "\n";
                    $this->_metrology->addLog('Generate token pool SID:' . $sid . ' force ' . $property['key'] . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }

            // Crée l'objet avec le contenu et l'écrit.
            $this->_data = $content;
            $this->_haveData = true;
            unset($content);

            // calcul l'ID.
            $this->_id = $this->_crypto->hash($this->_data);

            // Si l'objet doit être protégé.
            if ($protected) {
                $this->setProtected($obfuscated);
            } else {
                // Sinon écrit l'objet directement.
                $this->write();
            }
        } else {
            $this->_id = $sid;
            $this->_metrology->addLog('Generate token pool SID:' . $sid . ' HCT:false', Metrology::LOG_LEVEL_DEBUG); // Log
        }

        // Le sac de jetons a maintenant un PID.
        $this->_metrology->addLog('Generate token pool SID:' . $sid . ' PID:' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log


        // Prépare la génération des liens.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $source = $this->_id;
        $argObf = $obfuscated;

        // Le lien de type.
        $action = 'l';
        $target = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_MONNAIE_SAC);
        $meta = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE);
        $this->_createLink($signer, $date, $action, $source, $target, $meta, false);

        // Crée les liens associés au sac de jetons.
        $action = 'l';

        // Pour chaque propriété, si présente et a un méta, écrit le lien.
        foreach ($this->_propertiesList['tokenpool'] as $name => $property) {
            if (isset($param[$name])
                && $param[$name] != null
                && $property['key'] != 'PCN'
                && $property['key'] != 'TCN'
            ) {
                $value = null;
                if ($property['type'] == 'boolean') {
                    if ($param[$name] === true) {
                        $value = 'true';
                    } else {
                        $value = 'false';
                    }
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                } elseif ($property['type'] == 'number') {
                    $value = (string)$param[$name];
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                } elseif ($property['type'] == 'hexadecimal') {
                    $value = $param[$name];
                    $target = $value;
                } else {
                    $value = $param[$name];
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                }

                if ($value != null) {
                    $this->_metrology->addLog('Generate token pool SID:' . $sid . ' add ' . $property['key'] . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                    $meta = $this->_nebuleInstance->getCrypto()->hash($property['key']);
                    $this->_createLink($signer, $date, $action, $source, $target, $meta, $argObf);
                    $this->_metrology->addLog('Generate token pool SID:' . $sid . ' link=' . $target . '_' . $meta, Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }
        }


        // Retourne l'identifiant du sac de jetons.
        $this->_metrology->addLog('Generate token pool end SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        return $this->_id;
    }

    /**
     * Retourne la liste des jetons du sac.
     *
     * @return array:string
     */
    public function getTokenList()
    {
        return $this->_getItemList('PID');
    }

    /**
     * Retourne le nombre de jetons du sac.
     *
     * @return integer
     */
    public function getTokenCount()
    {
        return sizeof($this->_getItemList('PID'));
    }


    /**
     * Extrait la valeur relative du sac de jetons à un instant donné.
     *
     * @param $date string
     * @return double
     */
    public function getRelativeValue($date)
    {
        // Récupère la liste des jetons.
        $items = $this->_getItemList('PID');

        $total = 0;

        foreach ($items as $item) {
            $instance = $this->_nebuleInstance->newToken($item);
            if ($instance->getID() != '0') {
                $total += $instance->getRelativeValue($date);
            }
        }

        return $total;
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Token.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID d'un jeton ou 'new' ;
 * - un tableau des paramètres du nouveau jeton.
 *
 * L'ID d'un jeton est forcément un texte en hexadécimal.
 *
 * Si une erreur survient lors de la lecture de le jeton ou lors de la création, assigne l'ID 0.
 * ------------------------------------------------------------------------------------------
 */
class Token extends TokenPool
{
    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_id',
        '_fullname',
        '_cachePropertyLink',
        '_cachePropertiesLinks',
        '_cachePropertyID',
        '_cachePropertiesID',
        '_cacheProperty',
        '_cacheProperties',
        '_cacheMarkDanger',
        '_cacheMarkWarning',
        '_cacheMarkProtected',
        '_idProtected',
        '_idUnprotected',
        '_idProtectedKey',
        '_idUnprotectedKey',
        '_markProtectedChecked',
        '_cacheCurrentEntityUnlocked',
        '_usedUpdate',
        '_isEntity',
        '_isGroup',
        '_isConversation',
        '_isCurrency',
        '_isTokenPool',
        '_isToken',
        '_isWallet',
        '_properties',
        '_propertiesInherited',
        '_propertiesForced',
        '_seed',
        '_inheritedCID',
        '_inheritedPID',
    );

    /**
     * Constructeur.
     *
     * Toujours transmettre l'instance de la librairie nebule.
     * Si le jeton existe, juste préciser l'ID de celui-ci.
     * Si c'est un nouveau jeton à créer, mettre l'ID à 'new'.
     *
     * @param nebule $nebuleInstance
     * @param string $id
     * @param array $param si $id == 'new'
     * @param boolean $protected si $id == 'new'
     * @param boolean $obfuscated si $id == 'new'
     */
    public function __construct(nebule $nebuleInstance, $id, $param = array(), $protected = false, $obfuscated = false)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();

        // Complément des paramètres.
        //$this->_propertiesList['currency']['CurrencyForgeID']['force'] = $this->_nebuleInstance->getCurrentEntity();
//		$this->_propertiesList['tokenpool']['PoolForgeID']['force'] = $this->_nebuleInstance->getCurrentEntity();
//		$this->_propertiesList['token']['TokenCurrencyID']['force'] = $this->_nebuleInstance->getCurrentCurrency();
//		$this->_propertiesList['token']['TokenForgeID']['force'] = $this->_nebuleInstance->getCurrentEntity();

        $id = trim(strtolower($id));
        $this->_metrology->addLog('New instance token ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.

        if (is_string($id)
            && $id != ''
            && ctype_xdigit($id)
        ) {
            // Si l'ID est cohérent et l'objet nebule présent, c'est bon.
            $this->_loadToken($id);
        } elseif (is_string($id)
            && $id == 'new'
        ) {
            // Si c'est un nouveau jeton à créer, renvoie à la création.
            $this->_createNewToken($param, $protected, $obfuscated);
        } else {
            // Sinon, le jeton est invalide, retourne 0.
            $this->_id = '0';
        }
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     *  Chargement d'un jeton existant.
     *
     * @param string $id
     */
    private function _loadToken($id)
    {
        // Vérifie que c'est bien un objet.
        if (!is_string($id)
            || $id == ''
            || !ctype_xdigit($id)
            || !$this->_io->checkLinkPresent($id)
            || !$this->_nebuleInstance->getOption('permitCurrency')
        ) {
            $id = '0';
        }

        $this->_id = $id;
        $this->_metrology->addLog('Load token ' . $id, Metrology::LOG_LEVEL_DEBUG); // Log

        // On ne recherche pas les paramètres si ce n'est pas un jeton.
        if ($this->getIsToken('myself')) {
            $this->setAID();
            $this->setFID('0');
        }

        // Vérifie le jeton.
        $TYP = $this->_getParamFromObject('TYP', (int)$this->_propertiesList['token']['TokenType']['limit']);
        $SID = $this->_getParamFromObject('SID', (int)$this->_propertiesList['token']['TokenSerialID']['limit']);
        $CID = $this->_getParamFromObject('CID', (int)$this->_propertiesList['token']['TokenCurrencyID']['limit']);
        $PID = $this->_getParamFromObject('PID', (int)$this->_propertiesList['token']['TokenPoolID']['limit']);
        if ($TYP == ''
            || $SID == ''
            || $CID == ''
            || $PID == ''
        ) {
            $this->_id = '0';
        } else {
            $this->_propertiesList['token']['TokenID']['force'] = $id;
            $this->_properties['TID'] = $id;
        }
        $this->_propertiesForced['TYP'] = true;
        $this->_propertiesForced['SID'] = true;
        $this->_propertiesForced['CID'] = true;
        $this->_propertiesForced['PID'] = true;
        $this->_propertiesForced['TID'] = true;
    }

    /**
     * Création d'une nouveau jeton.
     *
     * @param array $param
     * @return boolean
     */
    private function _createNewToken($param, $protected = false, $obfuscated = false)
    {
        $this->_metrology->addLog('Ask create token', Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie que l'on puisse créer un jeton.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCurrency')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            // Génère la nouveau jeton.
            $this->_id = $this->_createToken($param, $protected, $obfuscated);

            // Si la génération s'est mal passée.
            if ($this->_id == '0') {
                $this->_metrology->addLog('Create token error on generation', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_id = '0';
                return false;
            }
        } else {
            $this->_metrology->addLog('Create token error not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_id = '0';
            return false;
        }
    }


    /**
     * Crée un jeton.
     *
     * Les paramètres force* ne sont utilisés que si tokenHaveContent est à true.
     * Pour l'instant le code commence à prendre en compte tokenHaveContent à false mais le paramètre est forçé à true tant que le code n'est pas prêt.
     *
     * Retourne la chaine avec 0 si erreur.
     *
     * @param array $param
     * @param boolean $protected
     * @param boolean $obfuscated
     * @return string
     */
    private function _createToken($param, $protected = false, $obfuscated = false)
    {
        // Identifiant final du sac de jetons.
        $this->_id = '0';

        // Normalise les paramètres.
        $this->_normalizeInputParam($param);

        // Force l'écriture de l'objet du sac de jetons.
        $param['TokenHaveContent'] = true;

        // Force l'écriture du serial.
        $param['ForceTokenSerialID'] = true;

        // Détermine si le sac de jetons a un numéro de série fourni.
        $sid = '';
        if (isset($param['TokenSerialID'])
            && is_string($param['TokenSerialID'])
            && $param['TokenSerialID'] != ''
            && ctype_xdigit($param['TokenSerialID'])
        ) {
            $sid = $this->_stringFilter($param['TokenSerialID']);
            $this->_metrology->addLog('Generate token asked SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        } else {
            // Génération d'un identifiant de sac de jetons unique aléatoire.
            $sid = $this->_getPseudoRandom();
            $param['TokenSerialID'] = $sid;
            $this->_metrology->addLog('Generate token rand SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        }

        // Détermine la monnaie associée.
        $instanceCurrency = $this->_nebuleInstance->getCurrentCurrencyInstance();
        if ($instanceCurrency->getID() != '0') {
            $this->_propertiesList['token']['TokenCurrencyID']['force'] = $instanceCurrency->getID();
            $param['TokenCurrencyID'] = $instanceCurrency->getID();
        } else {
            $this->_metrology->addLog('Generate token SID:' . $sid . ' - error no valid CID selected', Metrology::LOG_LEVEL_ERROR); // Log
            return '0';
        }

        // Détermine le sac de jetons associé.
        $instancePool = $this->_nebuleInstance->getCurrentTokenPoolInstance();
        if ($instancePool->getID() != '0') {
            $this->_propertiesList['token']['TokenPoolID']['force'] = $instancePool->getID();
            $param['TokenPoolID'] = $instancePool->getID();
        } else {
            $this->_metrology->addLog('Generate token SID:' . $sid . ' - error no valid PID selected', Metrology::LOG_LEVEL_ERROR); // Log
            return '0';
        }

        // Détermine le forgeur.
        $this->_propertiesList['token']['TokenForgeID']['force'] = $this->_nebuleInstance->getCurrentEntity();
        $param['TokenForgeID'] = $this->_nebuleInstance->getCurrentEntity();


        // Détermine si le jeton doit avoir un contenu.
        if (isset($param['TokenHaveContent'])
            && $param['TokenHaveContent'] === true
        ) {
            $this->_metrology->addLog('Generate token SID:' . $sid . ' HCT:true', Metrology::LOG_LEVEL_DEBUG); // Log

            // Le contenu final commence par l'identifiant interne du sac de jetons.
            $content = 'TYP:' . $this->_propertiesList['token']['TokenType']['force'] . "\n"; // @todo peut être intégré au reste.
            $this->_metrology->addLog('Generate token SID:' . $sid . ' TYP:' . $this->_propertiesList['token']['TokenType']['force'], Metrology::LOG_LEVEL_DEBUG); // Log
            $content .= 'SID:' . $sid . "\n";
            $content .= 'CID:' . $param['TokenCurrencyID'] . "\n";
            $this->_metrology->addLog('Generate token SID:' . $sid . ' CID:' . $param['TokenCurrencyID'], Metrology::LOG_LEVEL_NORMAL); // Log
            $content .= 'PID:' . $param['TokenPoolID'] . "\n";
            $this->_metrology->addLog('Generate token SID:' . $sid . ' PID:' . $param['TokenPoolID'], Metrology::LOG_LEVEL_NORMAL); // Log

            // Pour chaque propriété, si présente et forcée, l'écrit dans l'objet.
            foreach ($this->_propertiesList['token'] as $name => $property) {
                if ($property['key'] != 'HCT'
                    && $property['key'] != 'TYP'
                    && $property['key'] != 'SID'
                    && $property['key'] != 'CID'
                    && $property['key'] != 'PID'
                    //&& $property['key'] != 'PCN'
                    //&& $property['key'] != 'TCN'
                    && isset($property['forceable'])
                    && $property['forceable'] === true
                    && isset($param['Force' . $name])
                    && $param['Force' . $name] === true
                    && isset($param[$name])
                    && $param[$name] != ''
                    && $param[$name] != null
                ) {
                    $value = null;
                    if ($property['type'] == 'boolean') {
                        if ($param[$name] === true) {
                            $value = true;
                        } else {
                            $value = false;
                        }
                    } elseif ($property['type'] == 'number') {
                        $value = (string)$param[$name];
                    } else {
                        $value = $param[$name];
                    }

                    // Ajoute la ligne.
                    $content .= $property['key'] . ':' . $value . "\n";
                    $this->_metrology->addLog('Generate token SID:' . $sid . ' force ' . $property['key'] . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }

            // Crée l'objet avec le contenu et l'écrit.
            $this->_data = $content;
            $this->_haveData = true;
            unset($content);

            // calcul l'ID.
            $this->_id = $this->_crypto->hash($this->_data);

            // Si l'objet doit être protégé.
            if ($protected) {
                $this->setProtected($obfuscated);
            } else {
                // Sinon écrit l'objet directement.
                $this->write();
            }
        } else {
            $this->_id = $sid;
            $this->_metrology->addLog('Generate token SID:' . $sid . ' HCT:false', Metrology::LOG_LEVEL_DEBUG); // Log
        }

        // Le sac de jetons a maintenant un PID.
        $this->_metrology->addLog('Generate token SID:' . $sid . ' TID:' . $this->_id, Metrology::LOG_LEVEL_DEBUG); // Log


        // Prépare la génération des liens.
        $signer = $this->_nebuleInstance->getCurrentEntity();
        $date = date(DATE_ATOM);
        $source = $this->_id;
        $argObf = $obfuscated;

        // Le lien de type.
        $action = 'l';
        $target = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_MONNAIE_JETON);
        $meta = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_TYPE);
        $this->_createLink($signer, $date, $action, $source, $target, $meta, false);

        // Crée les liens associés au sac de jetons.
        $action = 'l';

        // Pour chaque propriété, si présente et a un méta, écrit le lien.
        foreach ($this->_propertiesList['token'] as $name => $property) {
            if (isset($param[$name])
                && $param[$name] != null
                && $property['key'] != 'PCN'
                && $property['key'] != 'TCN'
            ) {
                $value = null;
                if ($property['type'] == 'boolean') {
                    if ($param[$name] === true) {
                        $value = 'true';
                    } else {
                        $value = 'false';
                    }
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                } elseif ($property['type'] == 'number') {
                    $value = (string)$param[$name];
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                } elseif ($property['type'] == 'hexadecimal') {
                    $value = $param[$name];
                    $target = $value;
                } else {
                    $value = $param[$name];
                    $object = new Node($this->_nebuleInstance, '0', $value, false, false);
                    $object->setType(nebule::REFERENCE_OBJECT_TEXT);
                    $target = $object->getID();
                }

                if ($value != null) {
                    $this->_metrology->addLog('Generate token SID:' . $sid . ' add ' . $property['key'] . ':' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
                    $meta = $this->_nebuleInstance->getCrypto()->hash($property['key']);
                    $this->_createLink($signer, $date, $action, $source, $target, $meta, $argObf);
                    $this->_metrology->addLog('Generate token SID:' . $sid . ' link=' . $target . '_' . $meta, Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }
        }


        // Retourne l'identifiant du sac de jetons.
        $this->_metrology->addLog('Generate token end SID:' . $sid, Metrology::LOG_LEVEL_NORMAL); // Log
        return $this->_id;
    }


    /**
     * Extrait la valeur relative du jeton à un instant donné.
     *
     * @param $date string
     * @return double
     */
    public function getRelativeValue($date = '')
    {
        // Prépare la date de traitement.
        if (is_string($date)
            && $date != ''
        ) {
            $dateRef = strtotime($date);
        } else {
            $dateRef = microtime(true);
        }

        // Extraction de la valeur d'origine du jeton.
        $result = (double)$this->getParam('VAL');

        // Vérifie si désactivable et désactivé.
        $CLB = $this->getParam('CLB');
        $CLD = $this->getParam('CLD');
        if ($CLB
            && $CLD
        ) {
            $result = 0;
        }

        // Vérifie si dans l'interval de temps prévu.
        $DTA = $this->getParam('DTA');
        $DTC = $this->getParam('DTC');
        $DTD = $this->getParam('DTD');
        if ($DTA !== null) {
            // @todo
        }

        // Si paramétré, calcul l'inflation (ou déflation) de la valeur.
        $IDM = $this->getParam('IDM');
        $IDR = $this->getParam('IDR');
        $IDP = $this->getParam('IDP');
        if ($IDM != 'disabled') {
            // @todo
        }

        return $result;
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Wallet.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant l'ID d'un jeton ou 'new' ;
 * - un tableau des paramètres du nouveau portefeuille.
 *
 * L'ID d'un portefeuille est forcément un texte en hexadécimal.
 *
 * Si une erreur survient lors de la lecture du portefeuille ou lors de la création, assigne l'ID 0.
 * ------------------------------------------------------------------------------------------
 */
class Wallet extends Entity
{
    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_id',
        '_fullname',
        '_cachePropertyLink',
        '_cachePropertiesLinks',
        '_cachePropertyID',
        '_cachePropertiesID',
        '_cacheProperty',
        '_cacheProperties',
        '_cacheMarkDanger',
        '_cacheMarkWarning',
        '_cacheMarkProtected',
        '_idProtected',
        '_idUnprotected',
        '_idProtectedKey',
        '_idUnprotectedKey',
        '_markProtectedChecked',
        '_cacheCurrentEntityUnlocked',
        '_usedUpdate',
        '_isEntity',
        '_isGroup',
        '_isConversation',
        '_isCurrency',
        '_isTokenPool',
        '_isToken',
        '_isWallet',
    );

    /**
     * Constructeur.
     *
     * Toujours transmettre l'instance de la librairie nebule.
     * Si le portefeuille existe, juste préciser l'ID de celui-ci.
     * Si c'est un nouveau portefeuille à créer, mettre l'ID à 'new'.
     *
     * @param nebule $nebuleInstance
     * @param string $id
     * @param array $param si $id == 'new'
     * @param boolean $protected si $id == 'new'
     * @param boolean $obfuscated si $id == 'new'
     */
    public function __construct(nebule $nebuleInstance, $id, $param = array(), $protected = false, $obfuscated = false)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_social = $nebuleInstance->getSocial();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();

        $id = trim(strtolower($id));
        $this->_metrology->addLog('New instance wallet ' . $id, Metrology::LOG_LEVEL_DEBUG); // Métrologie.

        if (is_string($id)
            && $id != ''
            && ctype_xdigit($id)
        ) {
            // Si l'ID est cohérent et l'objet nebule présent, c'est bon.
            $this->_loadWallet($id);
        } elseif (is_string($id)
            && $id == 'new'
        ) {
            // Si c'est un nouveau portefeuille à créer, renvoie à la création.
            $this->_createNewWallet($param, $protected, $obfuscated);
        } else {
            // Sinon, le portefeuille est invalide, retourne 0.
            $this->_id = '0';
        }
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     *  Chargement d'un portefeuille existant.
     *
     * @param string $id
     */
    private function _loadWallet($id)
    {
        // Vérifie que c'est bien un objet.
        if (!is_string($id)
            || $id == ''
            || !ctype_xdigit($id)
            || !$this->_io->checkLinkPresent($id)
            || !$this->_nebuleInstance->getOption('permitCurrency')
        ) {
            $id = '0';
        }

        $this->_id = $id;
        $this->_metrology->addLog('Load wallet ' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
    }

    /**
     * Création d'une nouveau portefeuille.
     *
     * @param array $param
     * @return boolean
     */
    private function _createNewWallet($param, $protected = false, $obfuscated = false)
    {
        $this->_metrology->addLog('Ask create wallet', Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie que l'on puisse créer un sac de jetons.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCurrency')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getCurrentEntityUnlocked()
        ) {
            // Génère la nouveau sac de jetons.
            $this->_id = $this->_createWallet($param, $protected, $obfuscated);

            // Si la génération s'est mal passée.
            if ($this->_id == '0') {
                $this->_metrology->addLog('Create wallet error on generation', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_id = '0';
                return false;
            }
        } else {
            $this->_metrology->addLog('Create wallet error not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_id = '0';
            return false;
        }
    }


    /**
     * Crée un portefeuille.
     *
     * Retourne la chaine avec 0 si erreur.
     *
     * @param array $param
     * @param boolean $protected
     * @param boolean $obfuscated
     * @return string
     */
    private function _createTokenPool($param, $protected = false, $obfuscated = false)
    {
        // Identifiant final du portefeuille.
        $this->_id = '0';

        // @todo
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Transaction.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant le lien ;
 * - un texte contenant la version du lien.
 *
 * Le nombre de champs du lien doit être de 7 exactement.
 * Le champs signature peut être vide ou à 0 si c'est pour un nouveau lien à signer.
 * La signature doit être explicitement demandée par l'appelle de sign() après la création du lien.
 *
 * Un lien peut être valide si sa structure est correcte, et peut être signé si la signature est valide.
 *
 * Une transaction est un lien entre une monnaie, un jeton et un objet contenant la description de la transaction.
 * La description de la transaction peut en fait contenir plusieurs transactions élémentaires.
 * ------------------------------------------------------------------------------------------
 */
class Transaction extends Link
{
    /**
     * Booléen si le lien est une transaction ET qu'elle est valide.
     *
     * @var boolean
     */
    private bool $_isTransaction = false;

    /**
     * ID de l'objet contenant les transactions.
     * Reste à null en mode LNS.
     *
     * @var string
     */
    private string $_transactionsObjectID = '';

    /**
     * Mode de transaction, si valide dans la monnaie.
     *
     * @var string
     */
    private string $_transactionsMode = '';

    /**
     * Date des transactions.
     *
     * @var DateTime|null
     */
    private DateTime|null $_transactionsTimestamp = null;

    /**
     * Table des transactions unitaires.
     *
     * Les transactions unitaires sont incrémentées à partir de 0.
     * Chaque transaction unitaire est un sous-tableau :
     * - CID
     * - D : horodatage
     * - S : ID détenteur
     * - D : ID destinataire
     * - TID
     * - R : ratio du jeton utilisé, de 0 à 1, 1 = tout
     * - TRS : mode de transaction
     *
     * @var array
     */
    private array $_transactionsArray = array();

    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_fullLink',
        '_signe',
        '_signeValue',
        '_signeAlgo',
        '_signed',
        '_hashSigner',
        '_date',
        '_action',
        '_hashSource',
        '_hashTarget',
        '_hashMeta',
        '_obfuscated',
        '_verified',
        '_valid',
        '_validStructure',
        '_verifyNumError',
        '_verifyTextError',
        '_isTransaction',
    );

    /**
     * Initialisation post-constructeur.
     *
     * @return void
     */
    protected function _initialisation()
    {
        // Vérifications de base.
        if ($this->_action != 'f'
            || $this->_hashSource == '0'
            || $this->_hashTarget == '0'
            || $this->_hashMeta == '0'
        ) {
            return;
        }

        $this->_extractByMode();
    }

    /**
     * Tri par mode de transaction détecté.
     *
     * @return void
     */
    private function _extractByMode()
    {
        // Si transaction en mode mode LNS.
        $hashLNS = $this->_crypto->hash(nebule::REFERENCE_NEBULE_OBJET_MONNAIE_TRANSACTION);
        if ($this->_hashMeta == $hashLNS) {
            $this->_extractModeLNS();
        } else {
            $this->_isTransaction = false;
        }
    }

    /**
     * Extrait une transaction en mode LNS.
     *
     * Une transaction en mode LNS est marquée par un lien :
     * - hashsign : signataire et entité source disposant du jeton.
     * - date : date de la prise en compte de la transaction.
     * - action : type f.
     * - hashsource : ID du jeton.
     * - hashtarget : ID du destinataire.
     * - hashmeta : hash de 'nebule/objet/monnaie/transaction', marque que c'est une transaction.
     * Elle est repérée par rapport au champs méta.
     * Il faut vérifier que la source est un jeton et en extraire la monnaie affairante.
     * Il faut vérifier que la destination est une entité ou un dérivé.
     *
     * @return void
     */
    private function _extractModeLNS()
    {
        $this->_transactionsMode = 'LNS';

        // Vérifie si l'objet source est un jeton.
        $instanceSource = $this->_nebuleInstance->newToken($this->_hashSource);
        $instanceTarget = $this->_nebuleInstance->newWallet($this->_hashTarget);
        if ($instanceSource->getID() != '0'
            && $instanceSource->getIsToken('all') // @todo modifier le filtre social.
            && $instanceSource->getID() != '0'
            && $instanceSource->getIsWallet('all') // @todo modifier le filtre social.
        ) {
            // Extrait la monnaie.
            $CID = $instanceSource->getParam('CID');
            $instanceCID = $this->_nebuleInstance->newCurrency($CID);
            $modesCID = ' ' . $instanceCID->getParam('TRS') . ' ';

            // Vérifie que le mode LNS est présent dans les modes supportés par la monnaie
            if ($modesCID != '  '
                && strpos($modesCID, ' LNS ') !== false
            ) {
                $this->_transactionsArray[0]['CID'] = $CID;
                $this->_transactionsArray[0]['D'] = $this->_date;
                $this->_transactionsArray[0]['S'] = $this->_hashSigner;
                $this->_transactionsArray[0]['T'] = $this->_hashTarget;
                $this->_transactionsArray[0]['TID'] = $this->_hashSource;
                $this->_transactionsArray[0]['R'] = '1';
                $this->_transactionsArray[0]['TRS'] = 'LNS';
                $this->_isTransaction = true;
            } else {
                $this->_isTransaction = false;
            }
        } else {
            $this->_isTransaction = false;
        }
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Retourne si le lien est bien une transaction.
     *
     * @return boolean
     */
    public function getIsTransaction()
    {
        return $this->_isTransaction;
    }

    /**
     * Retourne l'ID de l'objet des transactions.
     * Retourne null en mode LNS
     *
     * @return string
     */
    public function getTransactionsObjetID()
    {
        return $this->_transactionsObjectID;
    }

    /**
     * Retourne la marque de temps des transactions.
     * Retourne null en mode LNS
     *
     * @return string
     */
    public function getTransactionsTimestamp()
    {
        return $this->_transactionsTimestamp;
    }

    /**
     * Retourne la liste des transactions unitaires.
     * Retourne null en mode LNS
     *
     * @return string
     */
    public function getTransactionsArray()
    {
        return $this->_transactionsArray;
    }
}


/**
 * La classe Link.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Attend à la création :
 * - l'instance nebule utilisé ;
 * - un texte contenant le lien ;
 * - un texte contenant la version du lien.
 *
 * Le nombre de champs du lien doit être de 7 exactement.
 * Le champs signature peut être vide ou à 0 si c'est pour un nouveau lien à signer.
 * La signature doit être explicitement demandée par l'appelle de sign() après la création du lien.
 *
 * La version du lien n'est pas prise en compte.
 *
 * Un lien peut être valide si sa structure est correcte, et peut être signé si la signature est valide.
 *
 * Un lien dissimulé peut ne pas pouvoir être lu si l'entité n'est pas destinataire, donc n'a pas accès à la clé de déchiffrement.
 * Il reste dans ce cas géré comme un lien normal mais de type c.
 * Cependant, si l'entité destinataire est déverrouillée mais ne peut déchiffrer le lien, alors le lien est considéré corrompu.
 */
class Link
{
    /**
     * Liste des variables à enregistrer dans la session php lors de la mise en sommeil de l'instance.
     *
     * @var array:string
     */
    const SESSION_SAVED_VARS = array(
        '_fullLink',
        '_signe',
        '_signeValue',
        '_signeAlgo',
        '_signed',
        '_hashSigner',
        '_date',
        '_action',
        '_hashSource',
        '_hashTarget',
        '_hashMeta',
        '_obfuscated',
        '_verified',
        '_valid',
        '_validStructure',
        '_verifyNumError',
        '_verifyTextError',
    );

    /**
     * Instance nebule en cours.
     *
     * @var nebule
     */
    protected nebule $_nebuleInstance;

    /**
     * Instance io en cours.
     *
     * @var io
     */
    protected ioInterface $_io;

    /**
     * Instance crypto en cours.
     *
     * @var CryptoInterface $_crypto
     */
    protected CryptoInterface $_crypto;

    /**
     * Instance métrologie en cours.
     *
     * @var Metrology
     */
    protected Metrology $_metrology;

    /**
     * Texte lien complet "s.a_s_d_a_s_t_m" .
     *
     * @var string
     */
    protected string $_fullLink = '';

    /**
     * Parsed link contents.
     *
     * @var array $_parsedLink
     */
    protected array $_parsedLink = array();

    /**
     * Texte signature avec algorithme.
     *
     * @var string $_signe
     */
    protected string $_signe = '0';

    /**
     * Texte valeur hexa de la signature.
     *
     * @var string $_signeValue
     */
    protected string $_signeValue = '';

    /**
     * Texte algorithme de signature.
     *
     * @var string $_signeAlgo
     */
    protected string $_signeAlgo = '';

    /**
     * Texte hexa entité signataire.
     *
     * @var string $_hashSigner
     */
    protected string $_hashSigner = '0';

    /**
     * Texte date du lien.
     *
     * @var string $_date
     */
    protected string $_date = '';

    /**
     * Texte action du lien, sur un octet.
     *
     * @var string $_action
     */
    protected string $_action = '';

    /**
     * Texte hexa objet source.
     *
     * @var string $_hashSource
     */
    protected string $_hashSource = '0';

    /**
     * Texte hexa objet destination.
     *
     * @var string $_hashTarget
     */
    protected string $_hashTarget = '0';

    /**
     * Texte hexa objet méta.
     *
     * @var string $_hashMeta
     */
    protected string $_hashMeta = '0';

    /**
     * Booléen si le lien est dissimulé.
     *
     * @var boolean $_obfuscated
     */
    protected bool $_obfuscated = false;

    /**
     * Booléen si le lien a été vérifié.
     *
     * @var boolean $_verified
     */
    protected bool $_verified = false;

    /**
     * Booléen si le lien est vérifié et valide.
     *
     * @var boolean $_valid
     */
    protected bool $_valid = false;

    /**
     * Booléen si le lien a une structure valide.
     *
     * @var boolean $_validStructure
     */
    protected bool $_validStructure = false;

    /**
     * Booléen si le lien est signé.
     *
     * @var boolean $_signed
     */
    protected bool $_signed = false;

    /**
     * Nombre représentant un code d'erreur de vérification.
     *
     * @var integer $_verifyNumError
     */
    protected int $_verifyNumError = 0;

    /**
     * Texte de la description de l'erreur de vérification.
     *
     * @var string $_verifyTextError
     */
    protected string $_verifyTextError = 'Initialisation';

    /**
     * Booléen si la dissimulation de lien est autorisée.
     *
     * @var boolean $_permitObfuscated
     */
    protected bool $_permitObfuscated = false;


    /**
     * Constructeur.
     *
     * @param nebule $nebuleInstance
     * @param string $link
     * @return boolean
     */
    public function __construct(nebule $nebuleInstance, string $link)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();
        $this->_permitObfuscated = (bool)$nebuleInstance->getOption('permitObfuscatedLink');
        $this->_metrology->addLinkRead(); // Metrologie.

        // Extrait le lien et vérifie sa structure.
        if (!$this->_extract($link))
            return false;

        // Vérifie la validité du lien.
        if (!$this->_verify())
            return false;

        // Détecte si c'est un lien dissimulé.
        $this->_obfuscated = false;
        if ($this->_action == 'c') {
            // Extrait la partie dissimulée du lien si la clé de déchiffrement est accessible à l'entité.
            if (!$this->_extractObfuscated())
                return false;

            // Vérifie la validité de la partie dissimulée du lien.
            if ($this->_obfuscated
                && !$this->_verifyObfuscated()
            )
                return false;
        }

        // Actions supplémentaires pour les dérivés de liens.
        $this->_initialisation();

        return true;
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->_fullLink;
    }

    /**
     * Mise en sommeil de l'instance.
     *
     * @return string[]
     */
    public function __sleep()
    {
        return self::SESSION_SAVED_VARS;
    }

    /**
     * Fonction de réveil de l'instance et de ré-initialisation de certaines variables non sauvegardées.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
        $this->_io = $nebuleInstance->getIO();
        $this->_crypto = $nebuleInstance->getCrypto();
        $this->_metrology = $nebuleInstance->getMetrologyInstance();
        $this->_permitObfuscated = (bool)$nebuleInstance->getOption('permitObfuscatedLink');
    }


    /**
     * Initialisation post-constructeur.
     *
     * @return void
     */
    protected function _initialisation(): void
    {
        // Rien à faire ici.
    }

    /**
     * Retourne le lien complet.
     *
     * @return string
     */
    public function getFullLink(): string
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_fullLink;
    }

    /**
     * Retourne le lien pré-décomposé.
     *
     * @return array
     */
    public function getParsedLink(): array
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_parsedLink;
    }

    /**
     * Retourne la valeur de la signature.
     *
     * @return string
     */
    public function getSigneValueAlgo_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_signeValue . '.' . $this->_signeAlgo;
    }

    /**
     * Retourne la valeur de la signature.
     *
     * @return string
     */
    public function getSigneValue_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_signeValue;
    }

    /**
     * Retourne l'algorithme de la signature.
     *
     * @return string
     */
    public function getSigneAlgo_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_signeAlgo;
    }

    /**
     * Retourne l'entité signataire du lien.
     *
     * @return string
     */
    public function getHashSigner_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_hashSigner;
    }

    /**
     * Retourne l'action du lien.
     *
     * @return string
     */
    public function getAction_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_action;
    }

    /**
     * Retourne la date du lien.
     *
     * @return string
     */
    public function getDate_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_date;
    }

    /**
     * Retourne l'objet source du lien.
     *
     * @return string
     */
    public function getHashSource_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_hashSource;
    }

    /**
     * Retourne l'objet cible du lien.
     *
     * @return string
     */
    public function getHashTarget_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_hashTarget;
    }

    /**
     * Retourne l'objet méta (contextualisation) du lien.
     *
     * @return string
     */
    public function getHashMeta_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_hashMeta;
    }

    /**
     * Retourne l'état de vérification et de validité du lien.
     *
     * @return boolean
     */
    public function getValid(): bool
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_valid;
    }

    /**
     * Retourne l'état de validité de la forme syntaxique du lien.
     *
     * @return boolean
     */
    public function getValidStructure(): bool
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_validStructure;
    }

    /**
     * Retourne si le lien a été vérifié dans sa forme syntaxique.
     *
     * @return boolean
     */
    public function getVerified(): bool
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_verified;
    }

    /**
     * Retourne le code d'erreur de vérification.
     * -1 : option activée de demande de ne pas tester les liens lors de la vérification - DANGER !!!
     * 0 : Le lien est valide.
     * 1 : Le lien a une structure invalide.
     * 2 : La signature a une structure invalide.
     * 3 : Le lien a une structure sale, sa reconstruction ne donne pas le même lien.
     * 11 : La signature est vide.
     * 12 : La valeur de la signature est invalide.
     * 13 : l'algorithme de signature est invalide.
     * 14 : La valeur de la signature est inconnue.
     * 15 : La signature est invalide.
     * 16 : Mode récupération, l'entité signataire n'est pas le puppetmaster.
     * 21 : L'identifiant du signataire est invalide.
     * 22 : L'objet du signataire n'est pas disponible.
     * 31 : La date est vide.
     * 32 : La date contient des carctères invalides.
     * 41 : L'action est invalide.
     * 51 : L'identifiant de l'objet source est invalide.
     * 52 : L'identifiant de l'objet source est null.
     * 61 : L'identifiant de l'objet cible est invalide.
     * 62 : L'identifiant de l'objet cible est null avec une action f/u/e/c/k.
     * 71 : L'identifiant de l'objet méta est invalide.
     * 72 : L'identifiant de l'objet méta est null avec une action c/k.
     *
     * @return number
     */
    public function getVerifyNumError()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_verifyNumError;
    }

    /**
     * Retourne le texte de description de l'erreur de vérification.
     * -1 : Option ask to not permit check sign on verify - DANGER !!!
     * 0 : Link is valid.
     * 1 : Link have invalid structure.
     * 2 : Signe have invalid structure.
     * 3 : Link have insane structure.
     * 11 : Signe is null.
     * 12 : Signe value is invalid.
     * 13 : Signe algorithm is invalid.
     * 14 : Signe value is unknown.
     * 15 : Signe is invalid.
     * 16 : RESCUE mode, signer is not code master.
     * 21 : Signer ID is invalid.
     * 22 : Signer object is not available.
     * 31 : Date is null.
     * 32 : Date have invalid char.
     * 41 : Action is invalid.
     * 51 : Source object ID is invalid.
     * 52 : Source object ID is null.
     * 61 : Target object ID is invalid.
     * 62 : Target object ID is null with action f/u/e/c/k.
     * 71 : Meta object ID is invalid.
     * 72 : Meta object ID is null with action c/k.
     *
     * @return string
     */
    public function getVerifyTextError()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_verifyTextError;
    }

    /**
     * Retourne si le lien est signé et si la signature est valide.
     * @return boolean
     */
    public function getSigned()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_signed;
    }

    /**
     * Retourne si le lien est dissimulé.
     * Dans ce cas les informations retournées sont les informations du lien non dissimulé.
     *
     * @return boolean
     */
    public function getObfuscated()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return $this->_obfuscated;
    }

    /**
     * Retourne la version avec laquelle est exploité le lien.
     * TODO à supprimer !
     * @return string
     */
    public function getVersion_disabled()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        return '';
    }


    protected function _parse(string $link): array
    {
        // Extract blocs from link L : BH_BL_BS
        $bh = strtok(trim($link), '_');
        $bl = strtok('_');
        $bs = strtok('_');

        $bh_rf = strtok($bh, '/');
        $bh_rv = strtok('/');

        // Check items from RF : APP:TYP
        $bh_rf_app = strtok($bh_rf, ':');
        $bh_rf_typ = strtok(':');

        // Check items from RV : VER:SUB
        $bh_rv_ver = strtok($bh_rv, ':');
        $bh_rv_sub = strtok(':');

        $bl_rc = strtok($bl, '/');
        $bl_rl = strtok('/');

        // Check items from RC : MOD>CHR
        $bl_rc_mod = strtok($bl_rc, '>');
        $bl_rc_chr = strtok('>');

        // Extract items from RL 1 : REQ>NID>NID>NID>NID
        $bl_rl_req = strtok($bl_rl, '>');
        $bl_rl_nid1 = strtok('>');
        $bl_rl_nid2 = strtok('>');
        if ($bl_rl_nid2 === false) $bl_rl_nid2 = '';
        $bl_rl_nid3 = strtok('>');
        if ($bl_rl_nid3 === false) $bl_rl_nid3 = '';
        $bl_rl_nid4 = strtok('>');
        if ($bl_rl_nid4 === false) $bl_rl_nid4 = '';

        $bs_rs1 = strtok($bs, '/');

        // Extract items from RS : NID>SIG
        $bs_rs1_nid = strtok($bs_rs1, '>');
        $bs_rs1_sig = strtok('>');

        // Check hash value.
        $bs_rs1_sig_sign = strtok($bs_rs1_sig, '.');

        // Check algo value.
        $bs_rs1_sig_algo = strtok('.');

        // Check size value.
        $bs_rs1_sig_size = strtok('.');

        return array(
            'link' => $link, // original link
            'bh' => $bh,
            'bh/rf' => $bh_rf,
            'bh/rf/app' => $bh_rf_app,
            'bh/rf/typ' => $bh_rf_typ,
            'bh/rv' => $bh_rv,
            'bh/rv/ver' => $bh_rv_ver,
            'bh/rv/sub' => $bh_rv_sub,
            'bl' => $bl,
            'bl/rc' => $bl_rc,
            'bl/rc/mod' => $bl_rc_mod,
            'bl/rc/chr' => $bl_rc_chr,
            'bl/rl' => $bl_rl,
            'bl/rl/req' => $bl_rl_req,
            'bl/rl/nid1' => $bl_rl_nid1,
            'bl/rl/nid2' => $bl_rl_nid2,
            'bl/rl/nid3' => $bl_rl_nid3,
            'bl/rl/nid4' => $bl_rl_nid4,
            'bs' => $bs,
            'bs/rs' => $bs_rs1,
            'bs/rs1/eid' => $bs_rs1_nid,
            'bs/rs1/sig' => $bs_rs1_sig,
            'bs/rs1/sig/sign' => $bs_rs1_sig_sign,
            'bs/rs1/sig/algo' => $bs_rs1_sig_algo,
            'bs/rs1/sig/size' => $bs_rs1_sig_size,
        );
    }

    /**
     * Extraction du lien.
     * Extrait les champs d'un lien après avoir vérifié la cohérence de sa forme.
     * Ne vérifie pas la cohérence ou la validité des champs !
     *
     * Le nombre de champs doit être de 7.
     * Le champs signature peut être vide ou à 0 si c'est pour un nouveau lien à signer.
     *
     * @param string $link
     * @return boolean
     */
    protected function _extract($link)
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr(trim($link), 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // Doit être un texte.
        if (!is_string($link)) {
            return false;
        }

        $link = trim($link);
        $this->_valid = false;
        $this->_verified = false;

        // Indice du champs lu, de 1 à 7.
        $j = 1;

        // Tableau temporaire des champs du lien.
        $a = array();

        // Vérifie le nombre de champs, doit avoir 7 champs.
        $ok = false;

        // Première lecture des champs, premier champs.
        $e = strtok($link, '_');

        // Extrait le lien.
        while ($e !== false) {
            if ($j == 1) {
                $this->_signe = trim($e);
            } elseif ($j == 2) {
                $this->_hashSigner = trim($e);
            } elseif ($j == 3) {
                $this->_date = trim($e);
            } elseif ($j == 4) {
                $this->_action = trim($e);
            } elseif ($j == 5) {
                $this->_hashSource = trim($e);
            } elseif ($j == 6) {
                $this->_hashTarget = trim($e);
            } elseif ($j == 7) {
                $this->_hashMeta = trim($e);
                $ok = true;
            } else {
                // Ne doit pas avoir plus de 7 champs.
                $ok = false;
            }

            if ($j < 8) {
                // Lecture de la suite des champs, champs suivant.
                $e = strtok('_');
            } else {
                // Ne doit pas avoir plus de 7 champs.
                $e = false;
            }

            $j++;
        }
        unset($j, $a, $e);

        // Si erreur de lecture, quitte immédiatement et retourne le lien en erreur.
        if (!$ok) {
            $this->_verifyNumError = 1;
            $this->_verifyTextError = 'Link have invalid structure.';
            return false;
        }

        // Si le lien n'est pas un nouveau lien à signer.
        if ($this->_signe != '0'
            && $this->_signe != ''
        ) {
            // Extrait la signature et l'algorithme utilisé. Vérifie qu'ils sont présents.
            $this->_signeValue = trim(strtok(trim($this->_signe), '.'));
            $this->_signeAlgo = trim(strtok('.'));
            if ($this->_signeValue == ''
                || $this->_signeAlgo == ''
            ) {
                $this->_verifyNumError = 2;
                $this->_verifyTextError = 'Signe have invalid structure.';
                return false;
            }
        } else {
            $this->_signe = '0';
            $this->_signeValue = '0';
            $this->_signeAlgo = '';
            $this->_verifyNumError = 11;
            $this->_verifyTextError = 'Signe is null.';
        }

        // Reconstitue le lien pour vérification.
        if ($this->_signe == '0') {
            $rebuildLink = '0';
        } else {
            $rebuildLink = $this->_signeValue . '.' . $this->_signeAlgo;
        }
        $rebuildLink .= '_' . $this->_hashSigner;
        $rebuildLink .= '_' . $this->_date;
        $rebuildLink .= '_' . $this->_action;
        $rebuildLink .= '_' . $this->_hashSource;
        $rebuildLink .= '_' . $this->_hashTarget;
        $rebuildLink .= '_' . $this->_hashMeta;

        // Vérifie que le lien initial correspond au lien nettoyé reconstitué, sinon quitte et retourne le lien en erreur.
        if ($rebuildLink != $link) {
            $this->_verifyNumError = 3;
            $this->_verifyTextError = 'Link have insane structure.';
            return false;
        }

        // On mémorise le lien complet.
        $this->_fullLink = $link;

        // La structure du lien est valide.
        $this->_validStructure = true;

        return true;
    }


    /**
     * Vérification du lien.
     * Vérifie la cohérence et la validité des champs du lien.
     *
     * @return boolean
     */
    protected function _verify()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // Tant que le lien n'est pas complètement vérifé, il est marqué invalide.
        $this->_valid = false;
        $this->_signed = false;
        $this->_verified = false;

        // Vérifie les différents champs.
        if (!$this->_verifyHashSigner()) {
            return false;
        }
        if (!$this->_verifyDate()) {
            return false;
        }
        if (!$this->_verifyAction()) {
            return false;
        }
        if (!$this->_verifyHashSource()) {
            return false;
        }
        if (!$this->_verifyHashTarget()) {
            return false;
        }
        if (!$this->_verifyHashMeta()) {
            return false;
        }

        // Ce lien est maintenant marqué comme ayant été vérifié et valide dans sa structure même si sa signature n'est pas encore reconnu valide.
        $this->_valid = true;
        $this->_verified = true;

        //         La vérification est-elle permise ?
        //   / \   DANGER !!! Si non permit, c'est très dangereux !!!
        //  / ! \
        //   ---   Is verify permitted ?
        //         DANGER !!! If not permitted, it's very dangerous !!!
        if (!$this->_nebuleInstance->getOption('permitCheckSignOnVerify')) {
            $this->_signed = false;
            $this->_verifyNumError = -1;
            $this->_verifyTextError = 'Option ask to not permit check sign on verify - DANGER !!!';
            return false;
        }

        // En dernier.
        if (!$this->_verifySign()) {
            return false;
        }

        // Fin de vérification.
        // Tout est bon.
        $this->_metrology->addLinkVerify(); // Metrologie.
        $this->_signed = true;     // Le lien est marqué avec signature valide.
        $this->_verifyNumError = 0;
        $this->_verifyTextError = 'Link is valid.';

        return true;
    }

    /**
     * Vérifie l'empreinte de l'objet signataire.
     *
     * @return boolean
     */
    protected function _verifyHashSigner()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // L'ID du signataire doit être en hexadécimal.
        if (!ctype_xdigit($this->_hashSigner)) {
            $this->_verifyNumError = 21;
            $this->_verifyTextError = 'Signer ID is invalid.';
            return false;
        }

        // L'objet du signataire doit être présent pour que la signature puisse être vérifiée.
        if (!$this->_io->checkObjectPresent($this->_hashSigner)) {
            $this->_verifyNumError = 22;
            $this->_verifyTextError = 'Signer object is not available.';
            return false;
        }

        return true;
    }

    /**
     * Vérifie la date.
     *
     * @return boolean
     */
    protected function _verifyDate()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_date == '') {
            $this->_verifyNumError = 31;
            $this->_verifyTextError = 'Date is null.';
            return false;
        }

        $d = strlen($this->_date);
        for ($i = 0; $i < $d; $i++) {
            // Filtre sur les caractères 0-9 T W Z R Y P M D , : + - / et .
            // Spécifique au format de date ISO 8601:2004.
            $a = ord($this->_date[$i]);
            if (($a < 48
                    || $a > 57
                )
                && $a != 84 // T
                && $a != 87 // W
                && $a != 90 // Z
                && $a != 82 // R
                && $a != 89 // Y
                && $a != 80 // P
                && $a != 77 // M
                && $a != 68 // D
                && $a != 44 // ,
                && $a != 58 // :
                && $a != 43 // +
                && $a != 45 // -
                && $a != 47 // /
                && $a != 46 // .
            ) {
                $this->_verifyNumError = 32;
                $this->_verifyTextError = 'Date have invalid char. ' . $i . '(' . $a . '=' . $this->_date[$i] . ')' . $this->_date;
                return false;
            }
        }
        unset($d);

        return true;
    }

    /**
     * Vérifie l'action.
     *
     * @return boolean
     */
    protected function _verifyAction()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie que l'action est d'un type connu.
        if ($this->_action != 'l'
            && $this->_action != 'f'
            && $this->_action != 'u'
            && $this->_action != 'd'
            && $this->_action != 'e'
            && $this->_action != 'c'
            && $this->_action != 'k'
            && $this->_action != 's'
            && $this->_action != 'x'
        ) {
            $this->_verifyNumError = 41;
            $this->_verifyTextError = 'Action is invalid.';
            return false;
        }

        // Vérifie que l'action de dissimulation de lien est autorisée.
        if ($this->_action == 'k'
            && !$this->_nebuleInstance->getOption('permitProtectedObject')
        ) {
            $this->_verifyNumError = 42;
            $this->_verifyTextError = 'Action k is not autorized.';
            return false;
        }

        // Vérifie que l'action de dissimulation de lien est autorisée.
        if ($this->_action == 'c'
            && !$this->_nebuleInstance->getOption('permitObfuscatedLink')
        ) {
            $this->_verifyNumError = 43;
            $this->_verifyTextError = 'Action c is not autorized.';
            return false;
        }

        return true;
    }

    /**
     * Vérifie l'empreinte de l'objet source.
     *
     * @return boolean
     */
    protected function _verifyHashSource()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // L'ID de l'objet source doit être en hexadécimal.
        if (!ctype_xdigit($this->_hashSource)) {
            $this->_verifyNumError = 51;
            $this->_verifyTextError = 'Source object ID is invalid.';
            return false;
        }

        // L'ID de l'objet source ne doit pas être nul.
        if ($this->_hashSource == '0'
            || $this->_hashSource == ''
        ) {
            $this->_verifyNumError = 52;
            $this->_verifyTextError = 'Source object ID is null.';
            return false;
        }

        return true;
    }

    /**
     * Vérifie l'empreinte de l'objet cible.
     *
     * @return boolean
     */
    protected function _verifyHashTarget()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // L'ID de l'objet cible doit être en hexadécimal.
        if (!ctype_xdigit($this->_hashTarget)) {
            $this->_verifyNumError = 61;
            $this->_verifyTextError = 'Target object ID is invalid.';
            return false;
        }

        // L'ID de l'objet cible ne doit pas être nul si c'est un lien f/u/e/c/k.
        if (($this->_hashTarget == '0'
                && ($this->_action == 'f'
                    || $this->_action == 'u'
                    || $this->_action == 'e'
                    || $this->_action == 'c'
                    || $this->_action == 'k'
                )
            )
            || $this->_hashTarget == ''
        ) {
            $this->_verifyNumError = 62;
            $this->_verifyTextError = 'Target object ID is null with action f/u/e/c/k.';
            return false;
        }

        return true;
    }

    /**
     * Vérifie l'empreinte de l'objet méta.
     *
     * @return boolean
     */
    protected function _verifyHashMeta()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // L'ID de l'objet méta doit être en hexadécimal.
        if (!ctype_xdigit($this->_hashMeta)) {
            $this->_verifyNumError = 71;
            $this->_verifyTextError = 'Meta object ID is invalid.';
            return false;
        }

        // L'ID de l'objet méta ne doit pas être nul si c'est un lien c/k.
        if (($this->_hashMeta == '0'
                && ($this->_action == 'c'
                    || $this->_action == 'k'
                )
            )
            || $this->_hashMeta == ''
        ) {
            $this->_verifyNumError = 72;
            $this->_verifyTextError = 'Meta object ID is null with action c/k.';
            return false;
        }

        return true;
    }

    /**
     * Vérifie la signature.
     * Doit être à la fin des vérifications !
     *
     * @return boolean
     */
    protected function _verifySign()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // La valeur de la signature ne doit pas être nulle.
        if ($this->_signe == '0') {
            $this->_verifyNumError = 11;
            $this->_verifyTextError = 'Signe is null.';
            return false;
        }

        // La valeur de la signature doit être en hexadécimal.
        if (!ctype_xdigit($this->_signeValue)) {
            $this->_verifyNumError = 12;
            $this->_verifyTextError = 'Signe value is invalid.';
            return false;
        }

        // La valeur de l'algorithme de signature doit être en alphadécimal.
        $s = strlen($this->_signeAlgo);
        for ($i = 0; $i < $s; $i++) {
            $a = ord($this->_signeAlgo[$i]);
            if ($a < 48
                || $a > 122
                || ($a > 57
                    && $a < 97
                )
            ) {
                $this->_verifyNumError = 13;
                $this->_verifyTextError = 'Signe algorithm is invalid.';
                return false;
            }
        }
        unset($s);

        // L'aglorithme doit être reconnu.
        if (!$this->_crypto->checkHashAlgorithm($this->_signeAlgo)) {
            $this->_verifyNumError = 14;
            $this->_verifyTextError = 'Signe value is unknown.';
            return false;
        }

        // Lit la clé publique.
        $pubkey = $this->_io->objectRead($this->_hashSigner, Entity::ENTITY_MAX_SIZE);

        // Génère le lien sans signature et son hash pour vérification.
        $shortLink = '_' . $this->_hashSigner . '_' . $this->_date . '_' . $this->_action . '_' . $this->_hashSource . '_' . $this->_hashTarget . '_' . $this->_hashMeta;
        $hashShortLink = $this->_crypto->hash($shortLink, $this->_signeAlgo);
        // Vérifie la signature avec la clé publique du signataire.
        if (!$this->_crypto->verify($hashShortLink, $this->_signeValue, $pubkey)) {
            $this->_verifyNumError = 15;
            $this->_verifyTextError = 'Signe is invalid.';
            return false;
        }
        unset($pubkey, $shortLink, $hashShortLink);

        // Si mode rescue, vérifie que le lien est du code master.
        if ($this->_nebuleInstance->getModeRescue()
            && $this->_hashSigner != $this->_nebuleInstance->getCodeAuthority()
        ) {
            $this->_verifyNumError = 16;
            $this->_verifyTextError = 'RESCUE mode, signer is not code master.';
            return false;
        }

        // Tout est bon.
        return true;
    }


    /**
     * Extraction de la partie dissimulée du lien.
     * Ne vérifie pas la cohérence ou la validité des champs !
     *
     * @return boolean
     */
    protected function _extractObfuscated()
    {
        // @todo
    }


    /**
     * Vérification de la partie dissimulée du lien.
     * Vérifie la cohérence et la validité des champs du lien extraits de la partie dissimulée.
     *
     * @return boolean
     */
    protected function _verifyObfuscated()
    {
        // @todo
    }


    /**
     * Signature du lien par l'entité en cours.
     *
     * @param string $publicKey
     * @return boolean
     */
    public function sign($publicKey = '0')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si autorisé à signer.
        if (!$this->_nebuleInstance->getOption('permitCreateLink')) {
            $this->_nebuleInstance->getMetrologyInstance()->addLog('Can not sign link', Metrology::LOG_LEVEL_DEBUG); // Log
            return false;
        }

        // Si le lien est valide.
        if ($this->_validStructure
            && $this->_verified
            && $this->_valid
            && $this->_verifyNumError == 11
            && $this->_signe == '0'
        ) {
            // Lit la clé publique.
            if (is_a($publicKey, 'Entity')) {
                $pubkeyInstance = $publicKey;
                $pubkeyID = $publicKey->getID();
            } else {
                if ($publicKey == '0') {
                    $pubkeyID = $this->_nebuleInstance->getCurrentEntity();
                    $pubkeyInstance = $this->_nebuleInstance->getCurrentEntityInstance();
                } elseif ($publicKey == $this->_nebuleInstance->getCurrentEntity()) {
                    $pubkeyInstance = $this->_nebuleInstance->getCurrentEntityInstance();
                    $pubkeyID = $publicKey;
                } else {
                    $pubkeyInstance = $this->_nebuleInstance->newEntity($publicKey);
                    $pubkeyID = $publicKey;
                }
            }
            $this->_nebuleInstance->getMetrologyInstance()->addLog('Sign link for ' . $pubkeyID, Metrology::LOG_LEVEL_DEBUG); // Log

            // Récupère l'algorithme de hash.
            $hashAlgo = $this->_crypto->hashAlgorithmName();

            // Génère le lien sans signature et son hash pour vérification.
            $shortLink = '_' . $pubkeyID . '_' . $this->_date . '_' . $this->_action . '_' . $this->_hashSource . '_' . $this->_hashTarget . '_' . $this->_hashMeta;

            // Génère la signature.
            $sign = $pubkeyInstance->signLink($shortLink, $hashAlgo);

            if ($sign !== false) {
                $this->_signeValue = $sign;
                $this->_signeAlgo = $hashAlgo;
                $this->_signe = $sign . '.' . $hashAlgo;
                $this->_hashSigner = $pubkeyID;
                $this->_fullLink = $this->_signe . $shortLink;
                $this->_signed = true;
                $this->_valid = true;
                $this->_verified = true;
                $this->_verifyNumError = 0;
                $this->_verifyTextError = 'Signe is valid.';
                return true;
            }
        } else {
            $this->_nebuleInstance->getMetrologyInstance()->addLog('Invalid link', Metrology::LOG_LEVEL_DEBUG); // Log
        }

        return false;
    }

    /**
     * Ecrit le lien pour les objets concernés.
     *
     * @return boolean
     */
    public function write()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // Si autorisé à écrire.
        if (!$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
        ) {
            return false;
        }

        // Métrologie.
        $this->_nebuleInstance->getMetrologyInstance()->addAction('addlnk', $this->_fullLink, $this->_verified);

        // Si le lien n'est pas valide, quitte.
        if (!$this->_validStructure
            || !$this->_verified
            || !$this->_valid
            || !$this->_signed
        ) {
            $this->_nebuleInstance->getMetrologyInstance()->addLog('Link unsigned', Metrology::LOG_LEVEL_DEBUG); // Log
            return false;
        }

        // Ecrit l'historique.
        if ($this->_nebuleInstance->getOption('permitHistoryLinksSign')) {
            $history = nebule::NEBULE_LOCAL_HISTORY_FILE;
            $this->_io->linkWrite($history, $this->_fullLink);
        }

        // Ecrit le lien pour l'objet de l'entité signataire.
        if ($this->_nebuleInstance->getOption('permitAddLinkToSigner')) {
            $this->_io->linkWrite($this->_hashSigner, $this->_fullLink);
        }

        if ($this->_action != 'c') {
            // Ecrit le lien pour l'objet source.
            $this->_io->linkWrite($this->_hashSource, $this->_fullLink);

            // Ecrit le lien pour l'objet cible.
            if ($this->_hashTarget != $this->_hashSource
                && $this->_hashTarget != '0'
            ) {
                $this->_io->linkWrite($this->_hashTarget, $this->_fullLink);
            }

            // Ecrit le lien pour l'objet méta.
            if ($this->_hashMeta != $this->_hashSource
                && $this->_hashMeta != $this->_hashTarget
                && $this->_hashMeta != '0'
            ) {
                $this->_io->linkWrite($this->_hashMeta, $this->_fullLink);
            }
        } elseif ($this->_nebuleInstance->getOption('permitObfuscatedLink')) {
            // Ecrit le lien dissimulé.
            $this->_io->linkWrite($this->_hashSigner . '-' . $this->_hashSource, $this->_fullLink); // @todo
        } else {
            return false;
        }

        return true;
    }

    /**
     * Signe et écrit le lien.
     *
     * @param string $publicKey
     * @return boolean
     */
    public function signWrite($publicKey = '0')
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->sign($publicKey)) {
            return $this->write();
        }
        return false;
    }


    /**
     * Offusque le lien. Ne pas oublier de l'écrire.
     * @return boolean
     * @todo
     *
     * Le lien à dissimulé est concaténé avec un bourrage (padding) d'espace de taille aléatoire compris entre 3 et 5 fois la taille du champs source.
     *
     */
    public function obfuscate()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        if (!$this->_obfuscated
            && $this->_verified
            && $this->_valid
            && $this->_verifyNumError == 0
            && $this->_permitObfuscated
        ) {
            // @todo
        }

        return false;
    }

    /**
     * Offusque et écrit le lien.
     *
     * @return boolean
     */
    public function obfuscateWrite()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        // Vérifie si autorisé à dissimuler des liens.
        if (!$this->_permitObfuscated)
            return false;

        $this->obfuscate();
        return $this->write();
    }

    /**
     * Désoffusque le lien. Ne pas oublier de l'écrire.
     * @return boolean
     * @todo
     *
     */
    public function deobfuscate()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_obfuscated
            && $this->_verified
            && $this->_valid
            && $this->_verifyNumError == 0
        ) {
            // @todo
        }

        return false;
    }

    /**
     * Désoffusque et écrit le lien.
     *
     * @return boolean
     */
    public function deobfuscateWrite()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        $this->deobfuscate();
        return $this->write();
    }

    /**
     * Extrait le lien offusqué.
     * @return boolean
     * @todo
     *
     */
    public function decrypt()
    {
        $this->_metrology->addLog(__METHOD__ . ' ' . substr($this->_fullLink, 0, 32), Metrology::LOG_LEVEL_FUNCTION); // Log

        if ($this->_obfuscated
            && $this->_verified
            && $this->_valid
            && $this->_verifyNumError == 0
        ) {
            // @todo
        }
    }


    /**
     * Affiche la partie menu de la documentation.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#l">L / Lien</a>
            <ul>
                <li><a href="#lelpo">LELPO / Liens à Propos d’un Objet</a></li>
                <li><a href="#lelco">LELCO / Liens Contenu dans un Objet</a></li>
                <li><a href="#le">LE / Entête</a></li>
                <li><a href="#lr">LR / Registre</a>
                    <ul>
                        <li><a href="#lrsi">LRSI / Le champ <code>Signature</code></a></li>
                        <li><a href="#lrusi">LRHSI / Le champ <code>HashSignataire</code></a></li>
                        <li><a href="#lrt">LRT / Le champ <code>TimeStamp</code></a></li>
                        <li><a href="#lra">LRA / Le champ <code>Action</code></a>
                            <ul>
                                <li><a href="#lral">LRAL / Action <code>l</code> – Lien entre objets</a></li>
                                <li><a href="#lraf">LRAF / Action <code>f</code> – Dérivé d’objet</a></li>
                                <li><a href="#lrau">LRAU / Action <code>u</code> – Mise à jour d’objet</a></li>
                                <li><a href="#lrad">LRAD / Action <code>d</code> – Suppression d’objet</a></li>
                                <li><a href="#lrae">LRAE / Action <code>e</code> – Équivalence d’objets</a></li>
                                <li><a href="#lrac">LRAC / Action <code>c</code> – Chiffrement de lien</a></li>
                                <li><a href="#lrak">LRAK / Action <code>k</code> – Chiffrement d’objet</a></li>
                                <li><a href="#lras">LRAS / Action <code>s</code> – Subdivision d’objet</a></li>
                                <li><a href="#lrax">LRAX / Action <code>x</code> – Suppression de lien</a></li>
                            </ul>
                        </li>
                        <li><a href="#lrhs">LRHS / Le champ <code>HashSource</code></a></li>
                        <li><a href="#lrhc">LRHC / Le champ <code>HashCible</code></a></li>
                        <li><a href="#lrhm">LRHM / Le champ <code>HashMeta</code></a></li>
                    </ul>
                </li>
                <li><a href="#l1">L1 / Lien simple</a></li>
                <li><a href="#l2">L2 / Lien double</a></li>
                <li><a href="#l3">L3 / Lien triple</a></li>
                <li><a href="#ls">LS / Stockage</a>
                    <ul>
                        <li><a href="#lsa">LSA / Arborescence</a></li>
                        <li><a href="#lsd">LSD / Dissimulation</a>
                            <ul>
                                <li><a href="#lsdrp">LSDRP / Registre public</a></li>
                                <li><a href="#lsdrd">LSDRD / Registre dissimulé</a></li>
                                <li><a href="#lsda">LSDA / Attaque sur la dissimulation</a></li>
                                <li><a href="#lsds">LSDS / Stockage et transcodage</a>
                                    <ul>
                                        <li><a href="#lsdst">LSDST / Translation de lien</a></li>
                                        <li><a href="#lsdsp">LSDSP / Protection de translation</a></li>
                                    </ul>
                                </li>
                                <li><a href="#lsdt">LSDT / Transfert et partage</a></li>
                                <li><a href="#lsdc">LSDC / Compromission</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#lt">LT / Transfert</a></li>
                <li><a href="#lv">LV / Vérification</a></li>
                <li><a href="#lo">LO / Oubli</a></li>
            </ul>
        </li>

        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h1 id="l">L / Lien</h1>
        <p>Le lien est la matérialisation dans un graphe d’une relation entre deux objets pondéré par un troisième
            objet.</p>

        <h5 id="lelpo">LELPO / Liens à Propos d’un Objet</h5>
        <p>Les liens d’un objet sont consultables séquentiellement. Il doivent être perçus comme des méta-données d’un
            objet.</p>
        <p>Les liens sont séparés soit par un caractère espace «&nbsp;», soit par un retour chariot «&nbsp;\n&nbsp;». Un
            lien est donc une suite de caractères ininterrompue, c’est à dire sans espace ou retour à la ligne.</p>
        <p>La taille du lien dépend de la taille de chaque champs.</p>
        <p>Chaque localisation contenant des liens doit avoir un entête de version.</p>

        <h5 id="lelco">LELCO / Liens Contenu dans un Objet</h5>
        <p>Certains liens d’un objet peuvent être contenus dans un autre objet.</p>
        <p>Cette forme de stockage des liens permet de les transmettre et de les manipuler sous la forme d’un objet. On
            peut ainsi profiter du découpage et du chiffrement. Plusieurs liens peuvent être stockés sans être
            nécessairement en rapport avec les mêmes objets.</p>
        <p>Les liens stockés dans un objet ne peuvent pas faire référence à ce même objet.</p>
        <p>Tout ajout de lien crée implicitement un nouvel objet de mise à jour, c’est à dire lié par un lien de type
            u.</p>
        <p>Chaque fichier contenant des liens doit avoir un entête de version.</p>
        <p>Les objets contenants des liens ne sont pas reconnus et exploités lors de la lecture des liens. Ceux-ci
            doivent d’abord être extraits et injectés dans les liens des objets concernés. En clair, on ne peux pas s’en
            servir facilement pour de l’anonymisation.</p>

        <h2 id="le">LE / Entête</h2>
        <p>L’entête des liens est constitué du texte <code>nebule/liens/version/1.2</code>. Il est séparé du premier
            lien soit par un caractère espace «&nbsp;», soit par un retour chariot «&nbsp;\n&nbsp;».</p>
        <p>Il doit être transmit avec les liens, en premier.</p>

        <h2 id="lr">LR / Registre</h2>
        <p>Le registre du lien décrit la syntaxe du lien :</p>
        <p style="text-align:center">
            <code>Signature_HashSignataire_TimeStamp_Action_HashSource_HashCible_HashMeta</code></p>
        <p>Ce registre a un nombre de champs fixe. Chaque champs a une place fixe dans le lien. Les champs ont une
            taille variable. Le séparateur de champs est l’underscore «&nbsp;_&nbsp;». Les champs ne peuvent contenir ni
            l’underscore «&nbsp;_&nbsp;» ni l’espace &nbsp;» &nbsp;» ni le retour chariot «&nbsp;\n&nbsp;».</p>
        <p>Tout lien qui ne respecte pas cette syntaxe est à considérer comme invalide et à supprimer. Tout lien dont la
            <code>Signature</code> est invalide est à considérer comme invalide et à supprimer. La vérification peut
            être réalisée en ré-assemblant les champs après nettoyage.</p>

        <h4 id="lrsi">LRSI / Le champ <code>Signature</code></h4>
        <p>Le champ <code>Signature</code> est représenté en deux parties séparées par un point «&nbsp;.&nbsp;» . La
            première partie contient la valeur de la signature. La deuxième partie contient le nom court de la fonction
            de prise d’empreinte utilisée.</p>
        <p>La signature est calculée sur l’empreinte du lien réalisée avec la fonction de prise d’empreinte désignée
            dans la deuxième partie. L’empreinte du lien est calculée sur tout le lien sauf le champs
            <code>signature</code>, c’est à dire sur «&nbsp;<code>_HashSignataire_TimeStamp_Action_HashSource_HashCible_HashMeta</code>&nbsp;»
            avec le premier underscore inclus.</p>
        <p>La signature ne contient que des caractères hexadécimaux, c’est à dire de «&nbsp;0&nbsp;» à «&nbsp;9&nbsp;»
            et de «&nbsp;a&nbsp;» à «&nbsp;f&nbsp;» en minuscule. La fonction de prise d’empreinte est notée en
            caractères alpha-numériques en minuscule.</p>

        <h5 id="lrusi">LRHSI / Le champ <code>HashSignataire</code></h5>
        <p>Le champ <code>HashSignataire</code> désigne l’objet de l’entité qui génère le lien et le signe.</p>
        <p>Il ne contient que des caractères hexadécimaux, c’est à dire de «&nbsp;0&nbsp;» à «&nbsp;9&nbsp;» et de «&nbsp;a&nbsp;»
            à «&nbsp;f&nbsp;» en minuscule.</p>

        <h3 id="lrt">LRT / Le champ <code>TimeStamp</code></h3>
        <p>Le champ <code>TimeStamp</code> est une marque de temps qui donne un ordre temporel aux liens. Ce champs peut
            être une date et une heure au format <a class="external text" title="http://fr.wikipedia.org/wiki/ISO_8601"
                                                    href="http://fr.wikipedia.org/wiki/ISO_8601"
                                                    rel="nofollow">ISO8601</a> ou simplement un compteur incrémental.
        </p>

        <h3 id="lra">LRA / Le champ <code>Action</code></h3>
        <p>Le champ <code>Action</code> détermine la façon dont le lien doit être utilisé.</p>
        <p>Quand on parle du type d’un lien, on fait référence à son champ <code>Action</code>.</p>
        <p>L’interprétation de ce champ est limité au premier caractère. Des caractères alpha-numériques supplémentaires
            sont autorisés mais ignorés.</p>
        <p>Cette interprétation est basée sur un vocabulaire particulier. Ce vocabulaire est spécifique à <i>nebule
                v1.2</i> (et <i>nebule v1.1</i>).</p>
        <p>Le vocabulaire ne reconnaît que les 8 caractères <code>l</code>, <code>f</code>, <code>u</code>,
            <code>d</code>, <code>e</code>, <code>x</code>, <code>k</code> et <code>s</code>, en minuscule.</p>

        <h4 id="lral">LRAL / Action <code>l</code> – Lien entre objets</h4>
        <p>Met en place une relation entre deux objets. Cette relation a un sens de mise en place et peut être pondérée
            par un objet méta.</p>
        <p>Les liens de type <code>l</code> ne devraient avoir ni <code>HashMeta</code> nul ni <code>HashCible</code>
            nul.</p>

        <h4 id="lraf">LRAF / Action <code>f</code> – Dérivé d’objet</h4>
        <p>Le nouvel objet est considéré comme enfant ou parent suivant le sens du lien.</p>
        <p>Le champs <code>ObjetMeta</code> doit être vu comme le contexte du lien. Par exemple, deux objets contenants
            du texte peuvent être reliés simplement sans contexte, c’est à dire reliés de façon simplement hiérarchique.
            Ces deux mêmes textes peuvent être plutôt (ou en plus) reliés avec un contexte comme celui d’une discussion
            dans un blog. Dans ce deuxième cas, la relation entre les deux textes n’a pas de sens en dehors de cette
            discussion sur ce blog. Il est même probable que le blog n’affichera pas les autres textes en relations si
            ils n’ont pas un contexte appartenant à ce blog.</p>
        <p><code>f</code> comme <i>fork</i>.</p>

        <h4 id="lrau">LRAU / Action <code>u</code> – Mise à jour d’objet</h4>
        <p>Mise à jour d’un objet dérivé qui remplace l’objet parent.</p>
        <p><code>u</code> comme <i>update</i>.</p>

        <h4 id="lrad">LRAD / Action <code>d</code> – Suppression d’objet</h4>
        <p>L’objet est marqué comme à supprimer d’un ou de tous ses emplacements de stockage.</p>
        <p><code>d</code> comme <i>delete</i>.</p>
        <p>Le champs <code>HashCible</code> <span style="text-decoration: underline;">peut</span> être nuls, c’est à
            dire égal à <code>0</code>. Si non nul, ce champs doit contenir une entité destinataire de <i>l’ordre</i> de
            suppression. C’est utilisé pour demander à une entité relaie de supprimer un objet spécifique. Cela peut
            être utilisé pour demander à une entité en règle générale de bien vouloir supprimer l’objet, ce qui n’est
            pas forcément exécuté.</p>
        <p>Le champs <code>HashMeta</code> <span style="text-decoration: underline;">doit</span> être nuls, c’est à dire
            égal à <code>0</code>.</p>
        <p>Un lien de suppression sur un objet ne veut pas forcément dire qu’il a été supprimé. Même localement, l’objet
            est peut-être encore présent. Si le lien de suppression vient d’une autre entité, on ne va sûrement pas par
            défaut en tenir compte.</p>
        <p>Lorsque le lien de suppression est généré, le serveur sur lequel est généré le lien doit essayer par défaut
            de supprimer l’objet. Dans le cas d’un serveur hébergeant plusieurs entités, un objet ne sera pas supprimé
            si il est encore utilisé par une autre entité, c’est à dire si une entité a un lien qui le concerne et n’a
            pas de lien de suppression.</p>

        <h4 id="lrae">LRAE / Action <code>e</code> – Équivalence d’objets</h4>
        <p>Définit des objets jugés équivalents, et donc interchangeables par exemple pour une traduction.</p>

        <h4 id="lrac">LRAC / Action <code>c</code> – Chiffrement de lien</h4>
        <p>Ce lien de dissimulation contient un lien dissimulé sans signature. Il permet d’offusquer des liens entre
            objets et donc d’anonymiser certaines actions de l’entité (cf <a href="#ckl">CKL</a>).</p>
        <p>Le champs <code>HashSource</code> fait référence à l’entité destinataire du lien, celle qui peut le
            déchiffrer. A part le champs de l’entité signataire, c’est le seul champs qui fait référence à un objet.</p>
        <p>Le champs <code>HashCible</code> ne contient pas la référence d’un objet mais le lien chiffré et encodé en
            hexadécimal. Le chiffrement est de type symétrique avec la clé de session. Le lien offusqué n’a pas grand
            intérêt en lui même, c’est le lien déchiffré qui en a.</p>
        <p>Le champs <code>HashMeta</code> ne contient pas la référence d’un objet mais la clé de chiffrement du lien,
            dite clé de session. Cette clé est chiffrée (asymétrique) pour l’entité destinataire et encodée en
            hexadécimal. Chaque entités destinataires d'un lien de dissimulé doit disposer d'un lien de dissimulation
            qui lui est propre.</p>
        <p>Lors du traitement des liens, si une entité est déverrouillée, les liens offusqués pour cette entité doivent
            être déchiffrés et utilisés en remplacement des liens offusqués originels. Les liens offusqués doivent être
            vérifiés avant déchiffrement. Les liens déchiffrés doivent être vérifiés avant exploitation.</p>
        <p>Les liens de dissimulations posent un problème pour être efficacement utilisés par les entités émetrices et
            destinataires. Pour résoudre ce problème sans risquer de révéler les identifiants des objets utilisés dans
            un lien dissimulé, les liens de dissimulation sont attachés à des objets virtuels translatés depuis les
            identifiants des objets originaux (cf <a href="#ld">LD</a>).</p>
        <p>L'option <code>permitObfuscatedLink</code> permet de désactiver la dissimulation (offuscation) des liens des
            objets. Dans ce cas le lien de type <code>c</code> est rejeté comme invalide avec le code erreur 43.</p>

        <h4 id="lrak">LRAK / Action <code>k</code> – Chiffrement d’objet</h4>
        <p>Désigne la version chiffrée de l’objet (cf <a href="#cko">CKO</a>).</p>
        <p>L'option <code>permitProtectedObject</code> permet de désactiver la protection (chiffrement) des objets. Dans
            ce cas le lien de type <code>k</code> est rejeté comme invalide avec le code erreur 42.</p>

        <h4 id="lras">LRAS / Action <code>s</code> – Subdivision d’objet</h4>
        <p>Désigne un fragment de l’objet.</p>
        <p>Ce champ nécessite un objet méta qui précise intervalle de contenu de l’objet d’origine. Le contenu de
            l’objet méta doit être de la forme <code>x-y</code> avec :</p>
        <ul>
            <li><code>x</code> et <code>y</code> exprimé en octet sans zéro et sans unité ;</li>
            <li><code>x</code> strictement supérieur à zéro ;</li>
            <li><code>y</code> strictement inférieur ou égal à la taille de l’objet (lien vers
                <i>nebule/objet/taille</i>) ;
            </li>
            <li><code>x</code> inférieur à <code>y</code> ;</li>
            <li>sans espace, tabulation ou retour chariot.</li>
        </ul>

        <h4 id="lrax">LRAX / Action <code>x</code> – Suppression de lien</h4>
        <p>Supprime un ou plusieurs liens précédemment mis en place.</p>
        <p>Les liens concernés par la suppression sont les liens antérieurs de type <code>l</code>, <code>f</code>,
            <code>u</code>, <code>d</code>, <code>e</code>, <code>k</code> et <code>s</code>. Ils sont repérés par les 3
            derniers champs, c’est à dire sur <code>HashSource_HashCible_HashMeta</code>. Les champs nuls sont
            strictement pris en compte.</p>
        <p>Le champ <code>TimeStamp</code> permet de déterminer l’antériorité du lien et donc de déterminer sa
            suppression ou pas.</p>
        <p>C’est la seule action sur les liens et non sur les objets.</p>

        <h4 id="lrhs">LRHS / Le champ <code>HashSource</code></h4>
        <p>Le champ <code>HashSource</code> désigne l’objet source du lien.</p>
        <p>Le champ <code>signataire</code> ne contient que des caractères hexadécimaux, c’est à dire de «&nbsp;0&nbsp;»
            à «&nbsp;9&nbsp;» et de «&nbsp;a&nbsp;» à «&nbsp;f&nbsp;» en minuscule.</p>

        <h4 id="lrhc">LRHC / Le champ <code>HashCible</code></h4>
        <p>Le champ <code>HashCible</code> désigne l’objet destination du lien.</p>
        <p>Le champ <code>signataire</code> ne contient que des caractères hexadécimaux, c’est à dire de «&nbsp;0&nbsp;»
            à «&nbsp;9&nbsp;» et de «&nbsp;a&nbsp;» à «&nbsp;f&nbsp;» en minuscule.</p>
        <p>Il peut être nuls, c’est à dire représentés par la valeur «&nbsp;0&nbsp;» sur un seul caractère.</p>

        <h4 id="lrhm">LRHM / Le champ <code>HashMeta</code></h4>
        <p>Le champ <code>HashMeta</code> désigne l’objet contenant une caractérisation du lien entre l’objet source et
            l’objet destination.</p>
        <p>Le champ <code>signataire</code> ne contient que des caractères hexadécimaux, c’est à dire de «&nbsp;0&nbsp;»
            à «&nbsp;9&nbsp;» et de «&nbsp;a&nbsp;» à «&nbsp;f&nbsp;» en minuscule.</p>
        <p>Il peut être nuls, c’est à dire représentés par la valeur «&nbsp;0&nbsp;» sur un seul caractère.</p>

        <h2 id="l1">L1 / Lien simple</h2>
        <p>Le registre du lien simple a ses champs <code>HashCible</code> et <code>HashMeta</code> égaux à «&nbsp;0&nbsp;».
        </p>
        <p>Il ressemble à :</p>
        <p class="pcenter"><code>Signature_HashSignataire_TimeStamp_Action_HashSource_0_0</code></p>

        <h2 id="l2">L2 / Lien double</h2>
        <p>Le registre du lien double a son champ <code>HashMeta</code> égal à «&nbsp;0&nbsp;».</p>
        <p>Il ressemble à :</p>
        <p class="pcenter"><code>Signature_HashSignataire_TimeStamp_Action_HashSource_HashCible_0</code></p>

        <h2 id="l3">L3 / Lien triple</h2>
        <p>Le registre du lien triple est complètement utilisé.</p>
        <p>Il ressemble à :</p>
        <p class="pcenter"><code>Signature_HashSignataire_TimeStamp_Action_HashSource_HashCible_HashMeta</code></p>

        <h2 id="ls">LS / Stockage</h2>
        <p>Tous les liens sont stockés dans un même emplacement ou sont visible comme étant dans un même emplacement.
            Cet emplacement ne contient pas les contenus des objets (cf <a href="#oos">OOS</a>).</p>
        <p>Le lien dissimulé est stocké dans le même emplacement mais dispose de fichiers de stockages différents du
            fait de la spécificité (cf <a href="#lsds">LSDS</a>).</p>

        <h3 id="lsa">LSA / Arborescence</h3>
        <p>Sur un système de fichiers, tous les liens sont stockés dans des fichiers contenus dans le dossier <code>pub/l/</code>
            (<code>l</code> comme lien).</p>
        <p>A faire...</p>

        <h3 id="lsd">LSD / Dissimulation</h3>
        <p>Le lien de dissimulation, de type <code>c</code>, contient un lien dissimulé sans signature (cf <a
                    href="#lrac">LRAC</a>). Il permet d’offusquer des liens entre objets et donc d’anonymiser certaines
            actions de l’entité (cf <a href="#ckl">CKL</a>).</p>

        <h5 id="lsdrp">LSDRP / Registre public</h5>
        <p>Le registre du lien de dissimulation, public par nature, est conforme au registre des autres liens (cf <a
                    href="#lr">LR</a>). Si ce lien ne respectait pas cette structure il serait automatiquement ignoré ou
            rejeté. Son stockage et sa transmission ont cependant quelques particularités.</p>
        <p>Les champs <code>Signature</code> (cf <a href="#lrsi">LRSI</a>) et <code>HashSignataire</code> (cf <a
                    href="#lrhsi">LRHSI</a>) du registre sont conformes aux autres liens. Ils assurent la protection du
            lien. Le champs signataire fait office d'émeteur du lien dissimulé.</p>
        <p>Le champs <code>TimeStamp</code> (cf <a href="#lrt">LRT</a>) du registre est conformes aux autres liens. Il a
            cependant une valeur non significative et sourtout pas liée au <code>TimeStamp</code> du lien dissimulé.</p>
        <p>Le champs <code>Action</code> (cf <a href="#lrt">LRT</a>) du registre est de type <code>c</code> (cf <a
                    href="#lra">LRA</a> et <a href="#lrac">LRAC</a>).</p>
        <p>Le champs <code>HashSource</code> fait référence à l’entité destinataire du lien, celle qui peut le
            déchiffrer. A part le champs de l’entité signataire, c’est le seul champs qui fait référence à un objet.</p>
        <p>Le champs <code>HashCible</code> ne contient pas la référence d’un objet mais le lien chiffré et encodé en
            hexadécimal. Le chiffrement est de type symétrique avec la clé de session. Le lien offusqué n’a pas grand
            intérêt en lui même, c’est le lien déchiffré qui en a.</p>
        <p>Le champs <code>HashMeta</code> ne contient pas la référence d’un objet mais la clé de chiffrement du lien,
            dite clé de session. Cette clé est chiffrée (asymétrique) pour l’entité destinataire et encodée en
            hexadécimal. Chaque entités destinataires d'un lien de dissimulé doit disposer d'un lien de dissimulation
            qui lui est propre.</p>
        <p>Le registre du lien de dissimulation :</p>
        <ul>
            <li>Signature du lien</li>
            <li>Identifiant du signataire</li>
            <li>Horodatage non significatif</li>
            <li>action : <code>c</code></li>
            <li>source : hash(destinataire)</li>
            <li>cible : Lien dissimulé chiffré</li>
            <li>méta : clé de déchiffrement du lien, chiffrée pour le destinataire</li>
        </ul>

        <h5 id="lsdrd">LSDRD / Registre dissimulé</h5>
        <p>Le registre du lien dissimulé est la partie utile du lien qui est protégée dans le lien de dissimulation.</p>
        <p>L'extraction du lien dissimulé se fait depuis le lien de dissimulation :</p>
        <ol>
            <li>L'entité destinataire vérifie que son identifiant est bien celui présenté par le champs
                <code>HashSource</code>.
            </li>
            <li>Le champs <code>HashMeta</code> est déchiffré (asymétrique) avec la clé privée de l'entité destinataire
                pour obtenir la clé de session.
            </li>
            <li>Le champs <code>HashCible</code> est déchiffré (symétrique) avec la clé de session pour obtenir le lien
                dissimulé.
            </li>
            <li>Le lien dissimulé obtenu ne contient pas les champs <code>Signature</code> et
                <code>HashSignataire</code> mais on peut garder ceux du lien de dissimulation 'pour affichage'.
            </li>
        </ol>
        <p>A faire...</p>
        <p>Le registre du lien dissimulé :</p>
        <ul>
            <li>Horodatage significatif</li>
            <li>action : tout sauf <code>c</code></li>
            <li>source : hash(objet source)</li>
            <li>cible : hash(objet cible)</li>
            <li>méta : hash(objet méta)</li>
        </ul>

        <h4 id="lsda">LSDA / Attaque sur la dissimulation</h4>
        <p>Le fait qu’une entité synchronise des liens dissimulés que d’autres entités partagent et les range dans des
            fichiers transcodés peut révéler l’ID de l’objet transcodé. Et par tâtonnement on peut retourner ainsi le
            transcodage de tous les objets.</p>
        <p>Il suffit qu’une entité attaquante génère un lien dissimulé à destination d’une entité attaquée concernant un
            objet en particulier. L’entité attaquée va alors ranger le lien dissimulé dans le fichier transcodé.
            L’entité attaquante peut alors rechercher quel fichier transcodé contient sont lien dissimulé et en déduire
            que ce fichier transcodé correspond à l’objet.</p>
        <p>En plus, si le lien dissimulé n’a aucune action valable, il ne sera pas exploité, donc pas détecté par
            l’entité attaquée.</p>
        <p>La solution implémentée pour palier à ce problème c'est la méthode dite de translation des liens
            dissimulés.</p>

        <h4 id="lsds">LSDS / Stockage et transcodage</h4>
        <p>Les liens dissimulés sont camouflés dans des liens de dissimulation, ils ne sont donc plus utilisables pour
            assurer le transfert entre entités et le tri dans les fichiers de stockage des liens.</p>
        <p>De plus, les liens de dissimulations ne doivent pas être stockés directement dans des fichiers de stockage
            des liens directement rattachés aux objets concernés, comme les autres liens, sous peine de dévoiler assez
            rapidement les identifiants des objets utilisés... et donc assez facilement le lien dissimulé correspondant.
            Cela poserait en plus un problème lors du nettoyage des liens parce qu'il faut avoir accès aux liens
            dissimulés pour correctement les ranger.</p>
        <p>Le nommage des fichiers contenant ces liens doit aussi être différent des entités signataires et
            destinataires des liens, et ce nommage peut par facilité faire référence simultanément à ces deux entités.
            Ainsi ces fichiers sont stockés dans le dossier des liens. Cette organisation et cette séparation des liens
            dans des fichiers clairement distincts répond au besoin d'utilisation. Et lors du nettoyage des liens, le
            traitement peut être différencié par rapport à la structure du nom des fichiers.</p>

        <h5 id="lsdst">LSDST / Translation de lien</h5>
        <p>La répartition des liens de dissimulation dans des fichiers attachés à l'entité émettrice et l'entité
            destinataire ne permet pas une exmploitation efficace et rapide des liens dissimulés. Il faut trouver un
            moyen d'associer les liens de dissimulations aux objets concernés par les liens dissimulés sans révéler
            publiquement ce lien. Une translation va permettre de camoufler cette association.</p>
        <p>La translation des liens dissimulés signifie la dissimulation par translation des identifiants des objets
            auxquels s'appliquent des liens dissimulés moyennant une clé de translation. Cette translation doit
            permettre de préserver la dissociation entre l'identifiant d'un objet et l'identifiant 'virtuel' auquel sont
            attachés les liens dissimulés.</p>
        <p>Le système de translation est basé sur une clé unique de translation par entité. Cette translation doit être
            une fonction à sens unique, donc à base de prise d’empreinte (hash). Elle doit maintenir la non association
            entre identifiants virtuels et réels des objets, y compris lorsqu’une ou plusieurs translations sont
            connues. Enfin, la translation doit être dépendante de l’entité qui les utilise, c’est à dire qu’une même
            clé peut être commune à plusieurs entités sans donner les mêmes translations.</p>
        <p>A faire...</p>

        <h5 id="lsdsp">LSDSP / Protection de translation</h5>
        <p>A faire...</p>

        <h4 id="lsdt">LSDT / Transfert et partage</h4>
        <p>A faire...</p>

        <h4 id="lsdc">LSDC / Compromission</h4>
        <p>A faire...</p>

        <h2 id="lt">LT / Transfert</h2>
        <p>A faire...</p>

        <h2 id="lv">LV / Vérification</h2>
        <p>La signature d’un lien doit être vérifiée lors de la fin de la réception du lien. La signature d’un lien
            devrait être vérifiée avant chaque utilisation de ce lien. Un lien avec une signature invalide doit être
            supprimé. Lors de la suppression d’un lien, les autres liens de cet objet ne sont pas supprimés et l'objet
            n'est pas supprimé. La vérification de la validité des objets est complètement indépendante de celle des
            liens, et inversement (cf <a href="#cl">CL</a> et <a href="#oov">OOV</a>).</p>
        <p>Toute modification de l’un des champs du lien entraîne l’invalidation de tout le lien.</p>

        <h2 id="lo">LO / Oubli</h2>
        <p>L'oubli vonlontaire de certains liens et objets n'est encore ni théorisé ni implémenté mais deviendra
            indispensable lorsque l'espace viendra à manquer (cf <a href="#cn">CN</a>).</p>

        <?php
    }
}


/**
 * L'interface ioInterface
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Les classes qui implémentent l'interface ioInterface permettent l'accès bas niveau aux
 *   objets nebule et à leurs liens.
 *
 * Elles permettent de vérifier la présence des objets nebule et leurs liens,
 *   de les lire, de les écrire, et de supprimer leurs contenus.
 *
 * Chaque objet nebule est référencé par une chaine de caractères contenant l'ID en
 *   hexadécimal de l'objet.
 *
 * On ne peut utiliser directement un objet (instance) ici, il faut
 *   préalablement en extraire l'ID hexadécimal sous forme de texte.
 */
interface ioInterface
{
    // Fonctions de gestion des modules.
    /**
     * Retourne le type de système de fichiers.
     *
     * @return string
     */
    public function getType();

    /**
     * Retourne la chaine de filtre de ce type de FS.
     *
     * @return string
     */
    public function getFilterString();

    /**
     * Retourne le mode de lecture/écriture RO/RW.
     *
     * @return string
     */
    public function getMode();

    /**
     * Retourne la chaine de localisation par défaut.
     *
     * @return string
     */
    public function getDefaultLocalisation();

    /**
     * Initialise la clé de transcodage des fichiers de liens dissimulés.
     *
     * @param string $key
     * @return void
     */
    public function setFilesTranscodeKey(&$key);

    /**
     * Supprime la clé de transcodage des fichiers de liens dissimulés.
     *
     * @return void
     */
    public function unsetFilesTranscodeKey();

    /**
     * Retourne l'ID de l'entité locale de l'instance.
     *
     * @param string $localisation
     * @return string
     */
    public function getInstanceEntityID($localisation = '');


    // Fonctions d'auto-test.

    /**
     * Vérifie l'arborescence des liens.
     *
     * @param string $localisation
     * @return boolean
     */
    public function checkLinksDirectory($localisation = '');

    /**
     * Vérifie l'arborescence des objets.
     *
     * @param string $localisation
     * @return boolean
     */
    public function checkObjectsDirectory($localisation = '');

    /**
     * Vérifie les capacité de lecture de l'arborescence des liens.
     *
     * @param string $localisation
     * @return boolean
     */
    public function checkLinksRead($localisation = '');

    /**
     * Vérifie les capacité d'écriture de l'arborescence des liens.
     *
     * @param string $localisation
     * @return boolean
     */
    public function checkLinksWrite($localisation = '');

    /**
     * Vérifie les capacité de lecture de l'arborescence des objets.
     *
     * @param string $localisation
     * @return boolean
     */
    public function checkObjectsRead($localisation = '');

    /**
     * Vérifie les capacité d'écriture de l'arborescence des objets.
     *
     * @param string $localisation
     * @return boolean
     */
    public function checkObjectsWrite($localisation = '');


    // Fonctions de test de présence.

    /**
     * Indique true si l'objet a des liens, ou false sinon.
     * Attend en entrée une chaine avec l'ID de l'objet.
     *
     * @param unknown $object
     * @param string $localisation
     * @return boolean
     */
    public function checkLinkPresent(&$object, $localisation = '');

    /**
     * Indique true si l'objet est présent, ou false sinon.
     * Attend en entrée une chaine avec l'ID de l'objet.
     *
     * @param unknown $object
     * @param string $localisation
     * @return boolean
     */
    public function checkObjectPresent(&$object, $localisation = '');


    // Fonctions de lecture.

    /**
     * Lit les liens de l'objet. Retourne un tableau des liens lus, même vide.
     * Attend en entrée une chaine avec l'ID de l'objet.
     *
     * @param string $object
     * @param string $localisation
     * @return array|boolean
     */
    public function linksRead(&$object, $localisation = '');

    /**
     * Lit les liens dissimulés de l'entité dite destinataire. Retourne un tableau des liens lus, même vide.
     * Attend en entrée une chaine avec l'ID de l'entité et si besoin une chaine avec l'ID du signataire source.
     *
     * Si le signataire n'est pas précisé, il doit être positionné à 0.
     * Dans ce cas la recherche se fera sur tous les signataires qui ont générés des liens dissimulés pour l'entité destinataire.
     *
     * @param string $entity
     * @param string $signer
     * @param string $localisation
     * @return array
     */
    public function obfuscatedLinksRead(&$entity, $signer = '0', $localisation = '');

    /**
     * Lit le contenu de l'objet. Retourne le contenu lu ou false si erreur.
     *
     * @param string $object
     * @param number $maxsize
     * @param string $localisation
     * @return string|boolean
     */
    public function objectRead(&$object, $maxsize = 0, $localisation = '');


    // Fonctions d'écriture.

    /**
     * Ecrit un lien de l'objet. Retourne le nombre d'octets écrits ou false si erreur.
     *
     * @param string $object
     * @param string $link
     * @param string $localisation
     * @return number|boolean
     */
    public function linkWrite(&$object, &$link, $localisation = '');

    /**
     * Ecrit des données dans un objet. Retourne l'empreinte de l'objet écrit ou false si erreur.
     *
     * @param string $data
     * @param string $localisation
     * @return string|boolean
     */
    public function objectWrite(&$data, $localisation = '');


    // Fonctions de suppression.

    /**
     * Supprime la ligne d'un lien dans les liens d'un objet.
     *
     * @param string $object
     * @param string $link
     * @param string $localisation
     * @return boolean
     */

    public function linkDelete(&$object, &$link, $localisation = '');

    /**
     * Supprime tous les liens d'un objet.
     *
     * @param string $object
     * @param string $localisation
     * @return boolean
     */

    public function linksDelete(&$object, $localisation = '');

    /**
     * Supprime le contenu d'un objet. Retourne true si la suppression a réussi ou false si erreur.
     * Attend en entrée une chaine avec l'ID de l'objet.
     *
     * @param string $object
     * @param string $localisation
     * @return boolean
     */
    public function objectDelete(&$object, $localisation = '');
}


/**
 * La classe io.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * C'est une classe qui ne fait aucune action par elle-même.
 * Elle recense les classes de communication pour différents protocoles.
 * Elle est ensuite utilisée comme routeur pour recevoir les requêtes et les rediriger vers
 *   les bonnes classes par rapport aux protocoles utilisés dans les requêtes...
 */
class io implements ioInterface
{
    private $_defaultIO;
    private $_listClasses = array();
    private $_listType = array();
    private $_listLocalisations = array();
    private $_listFilterStrings = array();
    private $_listMode = array();
    private $_listInstances = array();

    public function __construct()
    {
        // Liste toutes les classes io* et les charges une à une.
        $list = get_declared_classes();
        foreach ($list as $i => $class) {
            if (substr($class, 0, 2) == 'io' && $class != 'io') {
                $instance = new $class;
                $type = $instance->getType();
                $filterString = $instance->getFilterString();
                $localisation = $instance->getDefaultLocalisation();
                $mode = $instance->getMode();
                // Renseigne les tableaux de suivi.
                $this->_listClasses[$i] = $class;
                $this->_listTypes[$i] = $type;
                $this->_listLocalisations[$localisation] = $instance;
                $this->_listFilterStrings[$type] = $filterString;
                $this->_listModes[$type] = $mode;
                $this->_listInstances[$type] = $instance;
            }
        }

        $this->_defaultIO = new ioUnixFileSystem();
    }

    public function __sleep()
    {
        return array('_defaultIO', '_listClasses');
    }

    public function __wakeup()
    {
        $list = $this->_listClasses;
        foreach ($list as $i => $class) {
            $instance = new $class;
            $type = $instance->getType();
            $filterString = $instance->getFilterString();
            $mode = $instance->getMode();
            // Renseigne les tableaux de suivi.
            $this->_listClasses[$i] = $class;
            $this->_listTypes[$i] = $type;
            $this->_listFilterStrings[$type] = $filterString;
            $this->_listModes[$type] = $mode;
            $this->_listInstances[$type] = $instance;
        }
    }

    /**
     * Recherche l'instance d'un module IO par rapport à son type de localisation.
     *
     * @param string $localisation
     * @return ioInterface
     */
    private function _findType($localisation)
    {
        if ($localisation == '') {
            return $this->_defaultIO;
        }

        // Fait le tour des modules IO et de leurs filtres pour déterminer le protocole.
        foreach ($this->_listFilterStrings as $type => $pattern) {
            if (preg_match($pattern, $localisation)) {
                return $this->_listInstances[$type];
            }
        }
        return $this->_defaultIO;
    }

    /**
     * Liste les modules IO disponibles. Les noms sont ceux générés par getType().
     *
     * @return array:string
     */
    public function getModulesList()
    {
        return $this->_listTypes;
    }

    /**
     * Recherche l'instance d'un module IO par rapport à son type de protocole, celui généré par getType().
     *
     * @param string $type
     * @return ioInterface
     */
    public function getModule($type)
    {
        if ($type != ''
            && isset($this->_listInstances[$type])
        ) {
            return $this->_listInstances[$type];
        }
        return $this->_defaultIO;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getType()
     */
    public function getType()
    {
        return $this->_defaultIO->getType();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getFilterString()
     */
    public function getFilterString()
    {
        return $this->_defaultIO->getFilterString();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getMode()
     */
    public function getMode()
    {
        return $this->_defaultIO->getMode();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::setFilesTranscodeKey()
     */
    public function setFilesTranscodeKey(&$key)
    {
        // Fait le tour des modules IO pour injecter la clé.
        foreach ($this->_listClasses as $instance) {
            $instance->setFilesTranscodeKey($key);
        }
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::unsetFilesTranscodeKey()
     */
    public function unsetFilesTranscodeKey()
    {
        // Fait le tour des modules IO pour supprimer la clé.
        foreach ($this->_listClasses as $instance) {
            $instance->unsetFilesTranscodeKey();
        }
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getInstanceEntityID()
     */
    public function getInstanceEntityID($localisation = '')
    {
        return $this->_defaultIO->getInstanceEntityID($localisation);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getDefaultLocalisation()
     */
    public function getDefaultLocalisation()
    {
        return $this->_defaultIO->getDefaultLocalisation();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksDirectory()
     */
    public function checkLinksDirectory($localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->checkLinksDirectory();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsDirectory()
     */
    public function checkObjectsDirectory($localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->checkObjectsDirectory();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksRead()
     */
    public function checkLinksRead($localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->checkLinksRead();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksWrite()
     */
    public function checkLinksWrite($localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->checkLinksWrite();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsRead()
     */
    public function checkObjectsRead($localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->checkObjectsRead();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsWrite()
     */
    public function checkObjectsWrite($localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->checkObjectsWrite();
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinkPresent()
     */
    public function checkLinkPresent(&$object, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->checkLinkPresent($object);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectPresent()
     */
    public function checkObjectPresent(&$object, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->checkObjectPresent($object);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linksRead()
     */
    public function linksRead(&$object, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->linksRead($object);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::ObfuscatedLinksRead()
     */
    public function obfuscatedLinksRead(&$entity, $signer = '0', $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->obfuscatedLinksRead($object);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectRead()
     */
    public function objectRead(&$object, $maxsize = 0, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->objectRead($object, $maxsize);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linkWrite()
     */
    public function linkWrite(&$object, &$link, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->linkWrite($object, $link);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectWrite()
     */
    public function objectWrite(&$data, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->objectWrite($data);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linkDelete()
     */
    public function linkDelete(&$object, &$link, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->linkDelete($object, $link);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linksDelete()
     */
    public function linksDelete(&$object, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->linksDelete($object);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectDelete()
     */
    public function objectDelete(&$object, $localisation = '')
    {
        $instance = $this->_findType($localisation);
        return $instance->objectDelete($object);
    }
}


/**
 * La classe ioUnixFileSystem.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
class ioUnixFileSystem implements ioInterface
{
    /**
     * Localisation par défaut de ce module I/O.
     *
     * @var string
     */
    const DEFAULT_LOCALISATION = 'file://';

    /**
     * Nombre maximum de liens à lire.
     *
     * @var number
     */
    private $_maxLink;

    /**
     * Quantité maximum de données à lire dans un objet.
     *
     * @var number
     */
    private $_maxData;

    /**
     * Instance de la bibliothèque nebule.
     *
     * @var nebule
     */
    private $_nebuleInstance;

    /**
     * Le mode d'accès reconnu.
     * Doit être RO ou RW, ou vide au début.
     *
     * @var string
     */
    private $_mode = '';

    /**
     * Valeur de la clé de transcodage des noms des fichiers de liens dissimulés.
     *
     * @var string
     */
    private $_filesTrancodeKey = '';

    /**
     * Construteur.
     * Prépare les dossiers.
     */
    public function __construct()
    {
        global $nebuleInstance;

        if (!file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER)) {
            mkdir(nebule::NEBULE_LOCAL_LINKS_FOLDER);
        }
        if (!file_exists(nebule::NEBULE_LOCAL_OBJECTS_FOLDER)) {
            mkdir(nebule::NEBULE_LOCAL_OBJECTS_FOLDER);
        }

        $this->_nebuleInstance = $nebuleInstance;
        $this->_maxLink = $nebuleInstance->getOption('ioReadMaxLinks');
        $this->_maxData = $nebuleInstance->getOption('ioReadMaxData');
    }

    public function __sleep()
    {
        $this->_filesTrancodeKey = '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
        $this->_filesTrancodeKey = '';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getType()
     */
    public function getType()
    {
        return 'FileSystem';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getFilterString()
     */
    public function getFilterString()
    {
        return '/^\//';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getMode()
     */
    public function getMode()
    {
        if ($this->_mode == '') {
            $this->_mode = 'RO';
            if ($this->checkObjectsWrite()
                && $this->checkLinksWrite()
            ) {
                $this->_mode = 'RW';
            }
        }
        return $this->_mode;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::setFilesTranscodeKey()
     */
    public function setFilesTranscodeKey(&$key)
    {
        $this->_filesTrancodeKey = $key;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::unsetFilesTranscodeKey()
     */
    public function unsetFilesTranscodeKey()
    {
        $this->_filesTrancodeKey = '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
        $this->_filesTrancodeKey = '';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getDefaultLocalisation()
     */
    public function getDefaultLocalisation()
    {
        return self::DEFAULT_LOCALISATION;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getInstanceEntityID()
     */
    public function getInstanceEntityID($localisation = '')
    {
        $filesize = filesize(nebule::NEBULE_LOCAL_ENTITY_FILE);
        $data = file_get_contents(nebule::NEBULE_LOCAL_ENTITY_FILE, null, null, 0, $filesize);

        return $data;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksDirectory()
     */
    public function checkLinksDirectory($localisation = '')
    {
        if ($localisation != ''
            || !file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER)
            || !is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER)
        ) {
            return false;
        }

        return true;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsDirectory()
     */
    public function checkObjectsDirectory($localisation = '')
    {
        if ($localisation != ''
            || !file_exists(nebule::NEBULE_LOCAL_OBJECTS_FOLDER)
            || !is_dir(nebule::NEBULE_LOCAL_OBJECTS_FOLDER)
        ) {
            return false;
        }

        return true;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksRead()
     */
    public function checkLinksRead($localisation = '')
    {
        if ($localisation != '') {
            return false;
        }

        $file = nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . nebule::DEFAULT_PUPPETMASTER;
        $result = false;

        $data = file_get_contents($file, null, null, 0, 16);
        if ($data === false) {
            return false;
        }

        return true;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksWrite()
     */
    public function checkLinksWrite($localisation = '')
    {
        if ($localisation != '') {
            return false;
        }

        $file = nebule::NEBULE_LOCAL_LINKS_FOLDER . '/0';
        $resultCreate = false;
        $resultDelete = false;

        // Test la création si pas déjà présent.
        if (file_exists($file)) {
            $resultCreate = true;
        } else {
            $resultCreate = file_put_contents(
                $file,
                'checkLinksWrite');
        }

        // Test la suppression si le fichier a pu être créé.
        if (file_exists($file)) {
            unlink($file);
        }
        if (!file_exists($file)) {
            $resultDelete = true;
        }

        return ($resultCreate && $resultDelete);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsRead()
     */
    public function checkObjectsRead($localisation = '')
    {
        if ($localisation != '') {
            return false;
        }

        $file = nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . nebule::DEFAULT_PUPPETMASTER;
        $result = false;

        $data = file_get_contents($file, null, null, 0, 16);
        if ($data === false) {
            return false;
        }

        return true;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsWrite()
     */
    public function checkObjectsWrite($localisation = '')
    {
        if ($localisation != '') {
            return false;
        }

        $file = nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/0';
        $resultCreate = false;
        $resultDelete = false;

        // Test la création si pas déjà présent.
        if (file_exists($file)) {
            $resultCreate = true;
        } else {
            $resultCreate = file_put_contents(
                $file,
                'checkObjectsWrite');
        }

        // Test la suppression si le fichier a pu être créé.
        if (file_exists($file)) {
            unlink($file);
        }
        if (!file_exists($file)) {
            $resultDelete = true;
        }

        return ($resultCreate && $resultDelete);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinkPresent()
     */
    public function checkLinkPresent(&$object, $localisation = '')
    {
        if ($localisation != ''
            || !is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
            || !file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)
            || is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)
        ) {
            return false;
        }

        return true;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectPresent()
     */
    public function checkObjectPresent(&$object, $localisation = '')
    {
        if ($localisation != ''
            || !is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
            || !file_exists(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object)
            || is_dir(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object)
        ) {
            return false;
        }

        return true;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linksRead()
     */
    public function linksRead(&$object, $localisation = '')
    {
        /**
         * Compteur de liens lus.
         * @var double $linkRead
         */
        $linkRead = 0;

        /**
         * Table des liens lus.
         * @var array $linkList
         */
        $linkList = array();

        if ($localisation != ''
            || !is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
            || !file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)
            || is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)
        ) {
            return false;
        }

        /**
         * Descripteur du fichier en cours de lecture.
         * @var finfo $file
         */
        $file = file(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object);
        foreach ($file as $link) {
            $linkList[$linkRead] = $link;
            // Vérifie que le nombre maximum de liens à lire n'est pas dépassé.
            $linkRead++;
            if ($linkRead > $this->_maxLink) {
                break 1;
            }
        }

        return $linkList;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::ObfuscatedLinksRead()
     */
    public function obfuscatedLinksRead(&$entity, $signer = '0', $localisation = '')
    {
        /**
         * Compteur de liens lus.
         * @var double $linkRead
         */
        $linkRead = 0;

        /**
         * Liste des fichiers de liens à lire.
         * @var array $fileList
         */
        $fileList = array();

        /**
         * Table des liens lus.
         * @var array $linkList
         */
        $linkList = array();

        // Vérifie la présence d'une clé de transcodage des noms des fichiers.
        if ($this->_filesTrancodeKey == '0') {
            return $linkList; // @todo ou return false ???
        }

        // Vérifie l'entité destinataire des liens dissimulés.
        if ($localisation != ''
            || !is_string($entity)
            || $entity == '0'
            || $entity == ''
            || !ctype_xdigit($entity)
            || !file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $entity)
            || is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $entity)
        ) {
            return $linkList; // @todo ou return false ???
        }

        // Vérifie l'entité signataire des liens dissimulés.
        if (!is_string($signer)
            || $signer == ''
            || !ctype_xdigit($signer)
            || !file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $signer)
            || is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $signer)
        ) {
            $signer = '0';
        }

        if ($signer == '0') {
            // Si aucun signataire particulier n'est demandé, lit tous les fichiers de liens attachés à l'entité destinataire.
            $fileList = glob(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $entity . '-*', GLOB_NOSORT);

            // Vérifie la validité du nom du fichier.
            /* @todo
             * foreach ($list as $l) {
             * if (preg_match("~^a+\.php$~",$file))
             * $files[] = $l;
             * }
             */
        } elseif (file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $entity . '-' . $signer)
            && !is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $entity . '-' . $signer)
        ) {
            // Si un signataire particulier est demandé, lit uniquement le fichier de liens concerné.
            $fileList[0] = $entity . '-' . $signer;
        } else {
            // Sinon il n'y a pas de liens dissimulés entre ces deux entités.
            return $linkList;
        }

        /**
         * Descripteur du fichier en cours de lecture.
         * @var finfo $file
         */
        $file = null;

        // Pour chaque fichier listé, lit les liens.
        foreach ($fileList as $filename) {
            $file = file(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $filename);
            foreach ($file as $link) {
                // @todo vérifier regex que le lien est de type c ...
                if (true) {
                    $linkList[$linkRead] = $link;
                }
                // Vérifie que le nombre maximum de liens à lire n'est pas dépassé.
                $linkRead++;
                if ($linkRead > $this->_maxLink) {
                    break 1;
                }
            }
        }

        return $linkList;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectRead()
     */
    public function objectRead(&$object, $maxsize = 0, $localisation = '')
    {
        if ($localisation != ''
            || !is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
            || !file_exists(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object)
            || is_dir(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object)
        ) {
            return false;
        }

        if ($maxsize == 0) {
            $maxsize = $this->_maxData;
        }

        $filesize = filesize(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object);
        if ($filesize > $maxsize) {
            $filesize = $maxsize;
        }

        $data = file_get_contents(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object, null, null, 0, $filesize);

        return $data;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linkWrite()
     */
    public function linkWrite(&$object, &$link, $localisation = '')
    {
        // Vérifie les arguments.
        if ($localisation != ''
            || !is_string($object)
            || $object == '0'
            || $object == ''
            || $link == ''
            || !$this->_checkFileLink($object, $link)
            || !$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || $this->getMode() != 'RW'
            || is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)
        ) {
            return false;
        }

        if (file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)) {
            // Si le fichier de lien est présent, teste la présence du lien.
            // Extrait un tableau avec une ligne par élément.
            $l = file(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object);
            foreach ($l as $k) {
                // Si déjà présent, on quitte.
                if (trim($k) == trim($link)) {
                    return true;
                }
            }
        } else {
            // Si le fichier de lien n'est pas présent, le crée.
            file_put_contents(
                nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object,
                'nebule/liens/version/' . $this->_nebuleInstance->getOption('defaultLinksVersion') . "\n");
        }

        if (file_put_contents(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object, $link . "\n", FILE_APPEND) !== false) {
            return true;
        }

        $this->_mode = 'RO';
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectWrite()
     */
    public function objectWrite(&$data, $localisation = '')
    {
        if ($localisation != ''
            || !$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteObject')
            || $this->getMode() != 'RW'
        ) {
            return false;
        }

        // Calcul de l'empreinte des données.
        $hash = hash($this->_nebuleInstance->getCrypto()->hashAlgorithmName(), $data, false);

        if (file_exists(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . "/$hash")) {
            return $hash;
        }
        if (file_put_contents(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . "/$hash", $data) !== false) {
            return $hash;
        }

        $this->_mode = 'RO';
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectDelete()
     */
    public function objectDelete(&$object, $localisation = '')
    {
        if ($localisation != ''
            || !is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
            || !$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteObject')
            || $this->getMode() != 'RW'
            || is_dir(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object)
        ) {
            return false;
        }

        if (!file_exists(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object)) {
            return true;
        }

        // Essaye de supprimer le fichier de l'objet.
        unlink(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object);

        if (file_exists(nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object)) {
            $this->_mode = 'RO';
            return false;
        }

        return true;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linkDelete()
     */
    public function linkDelete(&$object, &$link, $localisation = '')
    {
        if ($localisation != ''
            || !is_string($object)
            || $object == '0'
            || $object == ''
            || !$this->_checkFileLink($object, $link)
            || $link == ''
            || !$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || $this->getMode() != 'RW'
            || is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)
        ) {
            return false;
        }

        // Prépare le fichier temporaire de travail des liens.
        if (!file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object . '.rmlnk')) {
            return true;
        }

        // @todo

        return true;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linksDelete()
     */
    public function linksDelete(&$object, $localisation = '')
    {
        if ($localisation != ''
            || !is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
            || !$this->_nebuleInstance->getOption('permitWrite')
            || !$this->_nebuleInstance->getOption('permitWriteLink')
            || $this->getMode() != 'RW'
            || is_dir(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)
        ) {
            return false;
        }

        if (!file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)) {
            return true;
        }

        // Essaye de supprimer le fichier des liens de l'objet.
        unlink(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object);

        if (file_exists(nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object)) {
            $this->_mode = 'RO';
            return false;
        }

        return true;
    }

    /**
     * Retourne l'identifiant traduit d'un objet en fonction de la clé de translation.
     *
     * La traduction se fait par la prise d'empreinte de la concaténation de l'identifiant de l'objet, de l'identifiant de l'entité et de la clé de translation.
     * L'empreinte sur juste l'identifiant de l'objet est déjà non réversible en elle-même.
     * Même sans clé de translation, la translation varie d'une entité à l'autre. Et c'est pareil si deux enttiés utilisent la même clé de translation.
     * La valeur retournée dépend aussi de l'algorithme utilisé, c'est à dire celui par défaut pour les prises d'empreinte.
     *
     * La fonction est non réversible.
     *
     * @param string $id
     * @return string
     */
    private function _getTranlateID($id)
    {
        $val = $id . $this->_nebuleInstance->getCurrentEntity() . $this->_filesTrancodeKey;
        $tid = hash($this->_nebuleInstance->getCrypto()->hashAlgorithmName(), $val, false);
        unset($val);

        return $tid;
    }

    /**
     * Vérification du fichier de liens que l'on doit utiliser.
     * Si le lien est de type c, le fichier à la forme "hash-hash".
     * Si non il a la forme "hash".
     *
     * @param string $object
     * @param string $link
     * @return number|boolean
     */
    private function _checkFileLink(&$object, &$link)
    {
        /**
         * Indice du champs lu, de 1 à 7.
         * @var integer $j
         */
        $j = 1;

        /**
         * Action detectée.
         * @var string $action
         */
        $action = '';

        /**
         * Première lecture des champs, premier champs.
         * @var string $e
         */
        $e = strtok(trim($link), '_');

        // Extrait si lien type c.
        while ($e !== false) {
            if ($j == 4) {
                $action = trim($e);
            }
            if ($j < 8) {
                // Lecture de la suite des champs, champs suivant.
                $e = strtok('_');
            } else {
                // Ne doit pas avoir plus de 7 champs.
                return false;
            }
            $j++;
        }

        // Vérifie l'objet si lien d'offuscation ou non.
        if ($action != 'c') {
            if (!ctype_xdigit($object)) {
                return false;
            }
        } else {
            $hashentsign = '';
            $hashentdest = '';
            $j = 1;
            $e = strtok(trim($link), '-');
            // Extrait les deux hashs.
            while ($e !== false) {
                if ($j == 1) {
                    $hashentsign = trim($e);
                } else {
                    $hashentdest = trim($e);
                }
                if ($j < 3) {
                    // Lecture de la suite des champs, champs suivant.
                    $e = strtok('-');
                } else {
                    // Ne doit pas avoir plus de 2 champs.
                    return false;
                }
                $j++;
            }

            if ($hashentsign = ''
                || $hashentdest = ''
                    || !ctype_xdigit($hashentsign)
                    || !ctype_xdigit($hashentdest)
                    || $hashentsign . '-' . $hashentdest != $object
            ) {
                return false;
            }
        }

        // Si on arrive là c'est que c'estbon.
        return true;
    }

    /**
     * Destructeur.
     * Fin de traitement - Rien à fermer sur un fs.
     */
    public function __destruct()
    {
        $this->_filesTrancodeKey = '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
        $this->_filesTrancodeKey = '';
    }
}


/**
 * La classe ioHTTP.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
class ioHTTP implements ioInterface
{
    /**
     * Localisation par défaut de ce module I/O.
     *
     * @var string
     */
    const DEFAULT_LOCALISATION = 'http://localhost';

    /**
     * Nombre maximum de liens à lire.
     *
     * @var number
     */
    private $_maxLink;

    /**
     * Quantité maximum de données à lire dans un objet.
     *
     * @var number
     */
    private $_maxData;

    /**
     * Localisation par défaut à utiliser.
     *
     * @var string
     */
    private $_defaultLocalisation;

    /**
     * Instance de la bibliothèque nebule.
     *
     * @var nebule
     */
    private $_nebuleInstance;

    /**
     * Valeur de la clé de transcodage des noms des fichiers de liens dissimulés.
     *
     * @var number
     */
    private $_filesTrancodeKey = '0';

    /**
     * Constructeur.
     * Prépare les dossiers.
     */
    public function __construct()
    {
        global $nebuleLibVersion, $nebuleInstance;

        $this->_nebuleInstance = $nebuleInstance;
        $this->_maxLink = $nebuleInstance->getOption('ioReadMaxLinks');
        $this->_maxData = $nebuleInstance->getOption('ioReadMaxData');
        // Détermination de l'URL par défaut.
        $this->_defaultLocalisation = self::DEFAULT_LOCALISATION;
        // Environnement PHP.
        ini_set('allow_url_fopen', true);
        ini_set('allow_url_include', true);
        ini_set('user_agent', 'nebule/ioHTTP/' . $nebuleLibVersion);
        ini_set('default_socket_timeout', $nebuleInstance->getOption('ioTimeout'));
    }

    public function __sleep()
    {
        $this->_filesTrancodeKey = '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
        $this->_filesTrancodeKey = '';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getType()
     */
    public function getType()
    {
        return 'HTTP';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getFilterString()
     */
    public function getFilterString()
    {
        return '/^http:/i';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getMode()
     */
    public function getMode()
    {
        return 'RO';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::setFilesTranscodeKey()
     */
    public function setFilesTranscodeKey(&$key)
    {
        $this->_filesTrancodeKey = $key;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::unsetFilesTranscodeKey()
     */
    public function unsetFilesTranscodeKey()
    {
        $this->_filesTrancodeKey = '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
        $this->_filesTrancodeKey = '';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getDefaultLocalisation()
     */
    public function getDefaultLocalisation()
    {
        return self::DEFAULT_LOCALISATION;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::getInstanceEntityID()
     */
    public function getInstanceEntityID($localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_ENTITY_FILE;
        if ($this->_checkExistOverHTTP($localisation)) {
            return file_get_contents($localisation);
        }
        return '0';
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksDirectory()
     */
    public function checkLinksDirectory($localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_LINKS_FOLDER . '/';
        return $this->_checkExistOverHTTP($localisation);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsDirectory()
     */
    public function checkObjectsDirectory($localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/';
        return $this->_checkExistOverHTTP($localisation);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksRead()
     */
    public function checkLinksRead($localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . nebule::DEFAULT_PUPPETMASTER;
        return $this->_checkExistOverHTTP($localisation);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinksWrite()
     */
    public function checkLinksWrite($localisation = '')
    {
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsRead()
     */
    public function checkObjectsRead($localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . nebule::DEFAULT_PUPPETMASTER;
        return $this->_checkExistOverHTTP($localisation);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectsWrite()
     */
    public function checkObjectsWrite($localisation = '')
    {
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkLinkPresent()
     */
    public function checkLinkPresent(&$object, $localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        if (!is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
        ) {
            return false;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object;
        return $this->_checkExistOverHTTP($localisation);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::checkObjectPresent()
     */
    public function checkObjectPresent(&$object, $localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        if (!is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
        ) {
            return false;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object;
        return $this->_checkExistOverHTTP($localisation);
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linksRead()
     */
    public function linksRead(&$object, $localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        if (!is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
        ) {
            return false;
        }
        if (!$this->_nebuleInstance->getOption('permitSynchronizeLink')) {
            return false;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_LINKS_FOLDER . '/' . $object;
        if (!$this->_checkExistOverHTTP($localisation)) {
            return false;
        }
        $n = 0;
        $t = array();

        // Lecture et extraction des liens.
        $c = file_get_contents($localisation);
        $l = array_filter(explode(' ', strtr($c, "\n", ' ')));
        unset($c);

        // Filtre le nombre de liens lus.
        foreach ($l as $k) {
            $t[$n] = $k;
            if ($n > $this->_maxLink) {
                break 1;
            }
            $n++;
        }
        unset($l, $k, $n);
        return $t;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::ObfuscatedLinksRead()
     */
    public function obfuscatedLinksRead(&$entity, $signer = '0', $localisation = '')
    {
        // @todo
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectRead()
     */
    public function objectRead(&$object, $maxsize = 0, $localisation = '')
    {
        if ($localisation == '') {
            $localisation = $this->_defaultLocalisation;
        }
        if (!is_string($object)
            || $object == '0'
            || $object == ''
            || !ctype_xdigit($object)
        ) {
            return false;
        }
        if (!$this->_nebuleInstance->getOption('permitSynchronizeObject')) {
            return false;
        }
        $localisation = $localisation . '/' . nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object;
        if ($this->_checkExistOverHTTP($localisation)) {
            return file_get_contents($localisation);
        }
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linkWrite()
     */
    public function linkWrite(&$object, &$link, $localisation = '')
    {
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectWrite()
     */
    public function objectWrite(&$data, $localisation = '')
    {
        // Désactivé sur du HTTP
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::objectDelete()
     */
    public function objectDelete(&$object, $localisation = '')
    {
        // Désactivé sur du HTTP
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linkDelete()
     */
    public function linkDelete(&$object, &$link, $localisation = '')
    {
        // Désactivé sur du HTTP
        return false;
    }

    /**
     * {@inheritDoc}
     * @see ioInterface::linksDelete()
     */
    public function linksDelete(&$object, $localisation = '')
    {
        // Désactivé sur du HTTP
        return false;
    }

    /**
     * Destructeur.
     * Fin de traitement - Rien à fermer sur un fs.
     */
    public function __destruct()
    {
        $this->_filesTrancodeKey = '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
        $this->_filesTrancodeKey = '';
    }

    /**
     * Vérifie la présence d'un fichier ou dossier via HTTP.
     *
     * @param string $localisation
     * @return boolean
     */
    private function _checkExistOverHTTP(string $localisation): bool
    {
        $url = parse_url($localisation);

        $handle = fsockopen($url['host'], 80, $errno, $errstr, 1);
        if ($handle === false) {
            return false;
        }

        $out = "HEAD " . $url['path'] . " HTTP/1.1\r\n"
            . "Host: " . $url['host'] . "\r\n"
            . "Connection: Close\r\n\r\n";
        $response = '';

        fwrite($handle, $out);
        while (!feof($handle)) {
            $response .= fgets($handle, 20);
            if (strlen($response) > 0)
                break;
        }
        fclose($handle);

        $pos = strpos($response, ' ');
        if ($pos === false)
            return false;

        $code = substr($response, $pos + 1, 3);
        if ($code == '200')
            return true;

        return false;
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * La classe Metrology.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Gestion de la métrologie et des logs vers le système.
 * ------------------------------------------------------------------------------------------
 */
class Metrology
{
    const DEFAULT_ACTION_STATE_SIZE = 64;

    /**
     * Niveau de log normal, minimal.
     * @var integer
     */
    const LOG_LEVEL_NORMAL = 0;

    /**
     * Niveau de log des erreurs.
     * @var integer
     */
    const LOG_LEVEL_ERROR = 1;

    /**
     * Niveau de log des erreurs.
     * @var integer
     */
    const LOG_LEVEL_DEVELOP = 2;

    /**
     * Niveau de log des fonctions traversées.
     * @var integer
     */
    const LOG_LEVEL_FUNCTION = 4;

    /**
     * Niveau de log complet.
     * @var integer
     */
    const LOG_LEVEL_DEBUG = 8;

    /**
     * Niveau de log par défaut.
     * @var integer
     */
    const DEFAULT_LOG_LEVEL = 1;

    /**
     * Compteur de liens lus.
     * @var integer
     */
    private $_countLinkRead = 0;

    /**
     * Compteur de liens vérifiés.
     * @var integer
     */
    private $_countLinkVerify = 0;

    /**
     * Compteur d'objets lus.
     * @var integer
     */
    private $_countObjectRead = 0;

    /**
     * Compteur d'objets vérifiés.
     * @var integer
     */
    private $_countObjectVerify = 0;

    /**
     * Temps au démarrage du compteur.
     * @var integer
     */
    private $_timeStart = 0;

    /**
     * Nombre de temps intermédiares.
     * @var integer
     */
    private $_timeCount = 0;

    /**
     * Temps intermédiaire précédent.
     * @var integer
     */
    private $_timeTemp = 0;

    /**
     * Tableau des temps intermédiaires.
     * @var array
     */
    private $_timeArray = array();

    /**
     * Nombre d'actions enregistées.
     * @var integer
     */
    private $_actionCount = 0;

    /**
     * Tableau des actions enregistrées.
     * @var array
     */
    private $_actionArray = array();

    /**
     * Instance de la bibliothèque nebule.
     * @var nebule
     */
    private $_nebuleInstance;

    public function __construct(nebule $nebuleInstance)
    {
        $this->_timeStart(); // Démarre le compteur de temps.
        $this->_nebuleInstance = $nebuleInstance;
        $this->_readLogsLevel();
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return 'Metrology';
    }


    /**
     * Incrémente le compteur de liens lus.
     *
     * @return null
     */
    public function addLinkRead()
    {
        $this->_countLinkRead++;
    }

    /**
     * Lit le compteur de liens lus.
     *
     * @return integer
     */
    public function getLinkRead()
    {
        return $this->_countLinkRead;
    }

    /**
     * Incrémente le compteur de liens vérifiés.
     *
     * @return null
     */
    public function addLinkVerify()
    {
        $this->_countLinkVerify++;
    }

    /**
     * Lit le compteur de liens vérifiés.
     *
     * @return integer
     */
    public function getLinkVerify()
    {
        return $this->_countLinkVerify;
    }

    /**
     * Incrémente le compteur d'objets lus.
     *
     * @return null
     */
    public function addObjectRead()
    {
        $this->_countObjectRead++;
    }

    /**
     * Lit le compteur d'objets lus.
     *
     * @return integer
     */
    public function getObjectRead()
    {
        return $this->_countObjectRead;
    }

    /**
     * Incrémente le compteur d'objets vérifiés.
     *
     * @return null
     */
    public function addObjectVerify()
    {
        $this->_countObjectVerify++;
    }

    /**
     * Lit le compteur d'objets vérifiés.
     *
     * @return integer
     */
    public function getObjectVerify()
    {
        return $this->_countObjectVerify;
    }


    /**
     * Démarre le compteur de temps.
     *
     * @return null
     */
    private function _timeStart()
    {
        global $metrologyStartTime;

        $this->_timeStart = $metrologyStartTime;
        $this->_timeTemp = $this->_timeStart;
    }

    /**
     * Retourne le temps depuis le démarrage.
     *
     * @return number
     */
    public function getTime()
    {
        return microtime(true) - $this->_timeStart;
    }

    /**
     * Ajoute un temps au tableau des temps intermédiaires.
     *
     * @return null
     */
    public function addTime()
    {
        $time = microtime(true);
        $this->_timeArray[$this->_timeCount] = $time - $this->_timeTemp;
        $this->_timeTemp = $time;
        $this->_timeCount++;
    }

    /**
     * Retourne le tableau des temps intermédiaires.
     *
     * @return array:double
     */
    public function getTimeArray()
    {
        return $this->_timeArray;
    }


    /**
     * Variable si la journalisation est authorisée.
     *
     * @var string
     */
    private $_permitLogs = false;

    /**
     * Variable du niveau de journalisation.
     *
     * @var integer
     */
    private $_logsLevel = 0;

    /**
     * Lit le niveau de log à utiliser par défaut.
     *
     * @return void
     */
    private function _readLogsLevel()
    {
        $this->_permitLogs = $this->_nebuleInstance->getOption('permitLogs');
        $level = $this->_nebuleInstance->getOption('logsLevel');
        $this->_logsLevel = self::LOG_LEVEL_NORMAL;

        switch ($level) {
            case 'NORMAL':
                $this->_logsLevel = self::LOG_LEVEL_NORMAL;
                break;
            case 'ERROR':
                $this->_logsLevel = self::LOG_LEVEL_ERROR;
                break;
            case 'DEVELOP':
                $this->_logsLevel = self::LOG_LEVEL_DEVELOP;
                break;
            case 'FUNCTION':
                $this->_logsLevel = self::LOG_LEVEL_FUNCTION;
                break;
            case 'DEBUG':
                $this->_logsLevel = self::LOG_LEVEL_DEBUG;
                break;
            default:
                $this->_logsLevel = self::DEFAULT_LOG_LEVEL;
        }

        if ($this->_logsLevel > self::LOG_LEVEL_ERROR) {
            syslog(LOG_INFO, 'LogT=' . (microtime(true) - $this->_timeStart) . ' LogLdef=' . $this->_logsLevel . '(' . $level . ')');
        }
    }

    /**
     * Change le niveau de log courant.
     *
     * @param integer $level
     * @return void
     */
    public function setLogsLevel($level)
    {
        // Vérifie le droit de journaliser.
        if (!$this->_permitLogs) {
            return;
        }

        switch ($level) {
            case 'NORMAL':
                $this->_logsLevel = self::LOG_LEVEL_NORMAL;
                break;
            case 'ERROR':
                $this->_logsLevel = self::LOG_LEVEL_ERROR;
                break;
            case 'DEVELOP':
                $this->_logsLevel = self::LOG_LEVEL_DEVELOP;
                break;
            case 'FUNCTION':
                $this->_logsLevel = self::LOG_LEVEL_FUNCTION;
                break;
            case 'DEBUG':
                $this->_logsLevel = self::LOG_LEVEL_DEBUG;
                break;
            default:
                $this->_logsLevel = self::DEFAULT_LOG_LEVEL;
        }

        syslog(LOG_INFO, 'LogT=' . (microtime(true) - $this->_timeStart) . ' LogLset=' . $this->_logsLevel . '(' . $level . ')');
    }

    /**
     * Restaure le niveau de log par défaut.
     *
     * @return void
     */
    public function setDefaultLogsLevel()
    {
        // Vérifie le droit de journaliser.
        if (!$this->_permitLogs) {
            return;
        }

        $level = $this->_nebuleInstance->getOption('logsLevel');

        switch ($level) {
            case 'NORMAL':
                $this->_logsLevel = self::LOG_LEVEL_NORMAL;
                break;
            case 'ERROR':
                $this->_logsLevel = self::LOG_LEVEL_ERROR;
                break;
            case 'DEVELOP':
                $this->_logsLevel = self::LOG_LEVEL_DEVELOP;
                break;
            case 'FUNCTION':
                $this->_logsLevel = self::LOG_LEVEL_FUNCTION;
                break;
            case 'DEBUG':
                $this->_logsLevel = self::LOG_LEVEL_DEBUG;
                break;
            default:
                $this->_logsLevel = self::DEFAULT_LOG_LEVEL;
        }

        syslog(LOG_INFO, 'LogT=' . (microtime(true) - $this->_timeStart) . ' LogLrst=' . $this->_logsLevel . '(' . $level . ')');
    }

    /**
     * Ajoute une ligne dans les logs système.
     *
     * Le niveau doit être :
     *  - Metrology::LOG_LEVEL_NORMAL
     *  - Metrology::LOG_LEVEL_ERROR
     *  - Metrology::LOG_LEVEL_DEVELOP
     *  - Metrology::LOG_LEVEL_FUNCTION
     *  - Metrology::LOG_LEVEL_DEBUG
     *
     * @param string $message
     * @param string $level
     * @return void
     * @todo modifier la gestion de la journalisation pour avoir plusieurs niveaux concurrents.
     *
     */
    public function addLog($message, $level = self::LOG_LEVEL_ERROR)
    {
        // Vérifie le droit de journaliser.
        if (!$this->_permitLogs) {
            return;
        }

        // Extrait le niveau de log demandé.
        $logLevel = self::DEFAULT_LOG_LEVEL;
        if (is_int($level)) {
            $logLevel = $level;
        }
        /*	elseif ( is_string($level) )
		{
			$level = strtoupper($level);
			switch ( $level )
			{
				case 'NORMAL':
					$logLevel = self::LOG_LEVEL_NORMAL;
					break;
				case 'ERROR':
					$logLevel = self::LOG_LEVEL_ERROR;
					break;
				case 'DEVELOP':
					$logLevel = self::LOG_LEVEL_DEVELOP;
					break;
				case 'FUNCTION':
					$logLevel = self::LOG_LEVEL_FUNCTION;
					break;
				case 'DEBUG':
					$logLevel = self::LOG_LEVEL_DEBUG;
					break;
				default:
					$logLevel = self::DEFAULT_LOG_LEVEL;
			}
		}*/

        // Si le niveau de log est suffisant, écrit le message.
        if ($logLevel <= $this->_logsLevel) {
            // Ajoute le niveau du log.
            $message = 'LogL=' . $logLevel . ' ' . $message;

            // Ajout de l'état système en debug.
            if ($logLevel == self::LOG_LEVEL_DEBUG) {
                $message = 'LogM=' . memory_get_usage() . ' ' . $message;
            }

            // Ajoute la marque de temps.
            $message = 'LogT=' . (microtime(true) - $this->_timeStart) . ' LogL=L LogM="' . $message . '"';

            syslog(LOG_INFO, $message);
        }
    }


    /**
     * Ajoute une ligne dans les actions mémorisées.
     * @param string $type
     * @param undefined $action
     * @param boolean $result
     *
     * Type : addlnk addobj addent delobj
     */
    public function addAction($type, $action, $result)
    {
        // Vérifie si on a atteint la limite de remplissage.
        if ($this->_actionCount >= self::DEFAULT_ACTION_STATE_SIZE)
            $this->getFirstAction();

        // Ajoute une nouvelle action.
        $this->_actionArray[$this->_actionCount]['type'] = $type;
        $this->_actionArray[$this->_actionCount]['action'] = $action;
        $this->_actionArray[$this->_actionCount]['result'] = $result;
        $this->_actionCount++;

        $this->addLog($type . ' ' . $action, self::LOG_LEVEL_DEBUG);
    }

    /**
     * Supprime les actions mémorisées.
     */
    public function flushActions()
    {
        $this->_actionCount = 0;
        $this->_actionArray = array();
    }

    /**
     * Lit la dernière action mémorisée, la plus récente.
     */
    public function getLastAction()
    {
        if ($this->_actionCount > 0) {
            $this->_actionCount--;
            $r = $this->_actionArray[$this->_actionCount];
            $this->_actionArray[$this->_actionCount]['type'] = null;
            $this->_actionArray[$this->_actionCount]['action'] = null;
            $this->_actionArray[$this->_actionCount]['result'] = null;
            $this->_actionArray[$this->_actionCount] = null;
            return $r;
        } else
            return false;
    }

    /**
     * Lit la première action mémorisée, la plus ancienne.
     */
    public function getFirstAction()
    {
        if ($this->_actionCount > 0) {
            $this->_actionCount--;
            $r = $this->_actionArray[0];
            for ($i = 0; $i < $this->_actionCount; $i++)
                $this->_actionArray[$i] = $this->_actionArray[$i + 1];
            return $r;
        } else
            return false;
    }
}


/**
 * ------------------------------------------------------------------------------------------
 * L'interface CryptoInterface
 * ------------------------------------------------------------------------------------------
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
interface CryptoInterface
{
    // Fonction de génération.
    public function getPseudoRandom($size = 32);

    public function getStrongRandom($size = 32);

    public function getEntropy(&$data);

    // Fonction de prise d'empreinte.
    public function hashAlgorithm();

    public function hashAlgorithmName();

    public function hashLength();

    public function checkHashFunction();

    public function setHashAlgorithm($algo);

    public function checkHashAlgorithm($algo);

    public function hash($data, $algo = '');

    // Fonction de chiffrement symétrique.
    public function symetricAlgorithm();

    public function symetricAlgorithmName();

    public function symetricAlgorithmMode();

    public function symetricKeyLength();

    public function checkSymetricFunction();

    public function setSymetricAlgorithm($algo);

    public function checkSymetricAlgorithm($algo);

    public function crypt($data, $hexKey, $hexIV = '');

    public function decrypt($data, $hexKey, $hexIV = '');

    // Fonction de chiffrement asymétrique.
    public function asymetricAlgorithm();

    public function asymetricAlgorithmName();

    public function asymetricKeyLength();

    public function checkAsymetricFunction();

    public function setAsymetricAlgorithm($algo);

    public function checkAsymetricAlgorithm($algo);

    public function sign($hash, $privkey, $privatePassword);

    public function verify($hash, $sign, $pubkey);

    public function cryptTo($data, $pubkey);

    public function decryptTo($code, $privateKey, $privatePassword);

    public function newPkey();

    public function getPkeyPublic($pkey);

    public function getPkeyPrivate($pkey, $password = '');
}

/*
 * ------------------------------------------------------------------------------------------
 * La classe CryptoOpenssl.
 * ------------------------------------------------------------------------------------------
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */

class CryptoOpenssl implements CryptoInterface
{
    private $_nebuleInstance;

    public function __construct(nebule $nebuleInstance)
    {
        $this->_nebuleInstance = $nebuleInstance;
        $this->_genHashAlgorithmList();
        $this->_genSymetricAlgorithmList();
        $this->_genAsymetricAlgorithmList();
    }

    /*
	 * ------------------------------------------------------------------------------------------
	 * Gestion de la génération pseudo-aléatoire.
	 */

    /**
     * Génère de l'aléa avec une source pas forcément fiable.
     * La taille est en octets.
     *
     * La graine de génération pseudo-aléatoire est un mélange de la date,
     *   de l'heure avec une précision de la micro-seconde,
     *   du nom et de la version de la bibliothèque.
     *
     * Ne doit pas être utilisé pour générer des mots de passes !
     *
     * @param int $size
     * @return string
     */
    public function getPseudoRandom($size = 32)
    {
        global $nebuleSurname, $nebuleLibVersion;

        if ($size == 0
            || !is_int($size)
        ) {
            return '';
        }

        // Résultat à remplir.
        $result = '';

        // Définit l'algorithme de divergence.
        $algo = 'sha256';

        // Génère une graine avec la date pour le compteur interne.
        $intcount = date(DATE_ATOM) . microtime(false) . $nebuleSurname . $nebuleLibVersion . $this->_nebuleInstance->getInstanceEntity();

        // Boucle de remplissage.
        while (strlen($result) < $size) {
            $diffsize = $size - strlen($result);

            // Fait évoluer le compteur interne.
            $intcount = hash($algo, $intcount);

            // Fait diverger le compteur interne pour la sortie.
            // La concaténation avec un texte empêche de remonter à la valeur du compteur interne.
            $outvalue = pack("H*", hash($algo, $intcount . 'liberté égalité fraternité'));

            // Tronc au besoin la taille de la sortie.
            if (strlen($outvalue) > $diffsize) {
                $outvalue = substr($outvalue, 0, $diffsize);
            }

            // Ajoute la sortie au résultat final.
            $result .= $outvalue;
        }

        // Nettoyage.
        unset($intcount, $outvalue, $diffsize);

        $this->_nebuleInstance->getMetrologyInstance()->addLog('Calculated rand : ' . strlen($result) . '/' . $size, Metrology::LOG_LEVEL_DEBUG);
        return $result;
    }

    /**
     * Génère de l'aléa avec une source attendue comme fiable.
     * La taille est en octets.
     *
     * Vérifie que générateur se déclare comme retournant une valeur cryptographiquement fiable.
     * Retourne false si ce n'est pas le cas.
     *
     * @param int $size
     * @return string|boolean
     */
    public function getStrongRandom($size = 32)
    {
        if ($size == 0
            || !is_int($size)
        ) {
            return '';
        }
        $strong = false;
        $data = openssl_random_pseudo_bytes($size, $strong);
        if (!$strong) {
            return false;
        }
        return $data;
    }

    /**
     * Calcul l'entropie des données.
     *
     * @param string $data
     * @return float
     */
    public function getEntropy(&$data)
    {
        $h = 0;
        $s = strlen($data);
        if ($s == 0) {
            return 0;
        }
        foreach (count_chars($data, 1) as $v) {
            $p = $v / $s;
            $h -= $p * log($p) / log(2);
        }
        return $h;
    }


    /*
	 * ------------------------------------------------------------------------------------------
	 * Gestion de la prise d'empreinte cryptographique.
	 */
    private $_hashAlgorithmList = array(), // Liste des fonctions de prise d'empreintes.
        $_hashAlgorithm,               // Fonction de prise d'empreintes.
        $_hashAlgorithmName,           // Fonction de prise d'empreintes.
        $_hashLength,                  // Taille d'une empreinte.
        $_hashStrength;                // Classification de résistance de l'algorithme.

    // Retourne l'algorithme de hash en cours d'utilisation.
    public function hashAlgorithm()
    {
        return $this->_hashAlgorithm;
    }

    public function hashAlgorithmName()
    {
        return $this->_hashAlgorithmName;
    }

    // Retourne la longueur de l'empreinte de l'algorithme de hash en cours d'utilisation.
    public function hashLength()
    {
        return $this->_hashLength;
    }

    // Vérifie le bon fonctionnement de l'algorithme de hash en cours d'utilisation.
    public function checkHashFunction()
    {
        $check = false;
        $data = 'Bienvenue dans le projet nebule.';
        $hash = $this->hash($data);
        switch ($this->_hashAlgorithmName) {
            case 'dss1':
                if ($hash == 'd689bc73bbf35e6547e6de4b0ea79a5fd3b83ffa') {
                    $check = true;
                }
                break;
            case 'sha1':
                if ($hash == 'd689bc73bbf35e6547e6de4b0ea79a5fd3b83ffa') {
                    $check = true;
                }
                break;
            case 'sha224':
                if ($hash == '8ee809ef3ec56e4e31273e2ee232697683d260db72d543ce6db4ab64') {
                    $check = true;
                }
                break;
            case 'sha256':
                if ($hash == '0b8dc4408e7ab1c81716ae978abe1f75d4bd3ea9a7b882b8da6afacdafc0e32b') {
                    $check = true;
                }
                break;
            case 'sha384':
                if ($hash == 'fef7e57afdbf243a756eae37fa7c556bc71050f555209d78b29d2e8feef56e62ed92da5e291669b6262170cd4f0dd0ba') {
                    $check = true;
                }
                break;
            case 'sha512':
                if ($hash == 'b9d7b17462c0e2657171975ee0bd37e8dc0cab5d6ebc6496864af2e261f16d35c16642898ba0af5174ad80bada202032c641595be0fc56e4d35599add72f8079') {
                    $check = true;
                }
                break;
            case 'rmd160':
                if ($hash == '148e5adf9723d612de6bd4d2b9477852d6544ee1') {
                    $check = true;
                }
                break;
            case 'md5':
                if ($hash == 'a6675f8e9ac88030bf106d2801089e6e') {
                    $check = true;
                }
                break;
            case 'md4':
                if ($hash == '3c9aaffef0fc30b9cbc598637e6b64e5') {
                    $check = true;
                }
                break;
        }
        unset($data, $hash);
        return $check;
    }

    /**
     * {@inheritDoc}
     * @see CryptoInterface::setHashAlgorithm()
     */
    public function setHashAlgorithm($algo)
    {
        $algo = (string)$algo;
        // Vérifie si la liste des algorithmes n'est pas vide.
        if (sizeof($this->_hashAlgorithmList) == 0) {
            return false;
        }
        if (!in_array($algo, $this->_hashAlgorithmList)) {
            return false;
        }
        $this->_hashAlgorithmName = $algo;
        $this->_genHashAlgorithmProperties();
        return true;
    }

    /**
     * {@inheritDoc}
     * @see CryptoInterface::checkHashAlgorithm()
     */
    public function checkHashAlgorithm($algo)
    {
        if ($algo == '') return false;
        elseif ($algo == 'dss1') return true;
        elseif ($algo == 'sha1') return true;
        elseif ($algo == 'sha224') return true;
        elseif ($algo == 'sha256') return true;
        elseif ($algo == 'sha384') return true;
        elseif ($algo == 'sha512') return true;
        elseif ($algo == 'rmd160') return true;
        elseif ($algo == 'md5') return true;
        elseif ($algo == 'md4') return true;
        else                         return false;
        // @todo ... ajouter une option PERMIT pour gérer les algo non sûrs.
    }

    /**
     * {@inheritDoc}
     * @see CryptoInterface::hash()
     */
    public function hash($data, $algo = '')
    {
        if (strlen($data) == 0) {
            return false;
        }
        if ($algo == '') {
            $algo = $this->_hashAlgorithmName;
        }
        if (!$this->checkHashAlgorithm($algo)) {
            return false;
        }
        return hash($algo, $data);
    }

    /**
     * Génère (récupère) la liste des algorithmes supportés.
     */
    private function _genHashAlgorithmList()
    {
        //$this->_hashAlgorithmList = array('sha128', 'sha256', 'sha512'); // Génère la liste des algorithmes disponibles. @todo A revoir...
        $this->_hashAlgorithmList = openssl_get_md_methods(true); // Génère la liste des algorithmes disponibles.
        $this->_hashAlgorithmName = $this->_nebuleInstance->getOption('cryptoHashAlgorithm');
        $this->_genHashAlgorithmProperties();
    }

    /**
     * Prépare le nom de la fonction de l'algorithme et la taille de hash en fontion du nom court de l'algorithme.
     */
    private function _genHashAlgorithmProperties()
    {
        switch ($this->_hashAlgorithmName) {
            case 'sha1':
                $this->_hashAlgorithm = 'sha1';
                $this->_hashLength = 128;
                break;
            case 'sha224':
                $this->_hashAlgorithm = 'sha2';
                $this->_hashLength = 224;
                break;
            case 'sha256':
                $this->_hashAlgorithm = 'sha2';
                $this->_hashLength = 256;
                break;
            case 'sha384':
                $this->_hashAlgorithm = 'sha2';
                $this->_hashLength = 384;
                break;
            case 'sha512':
                $this->_hashAlgorithm = 'sha2';
                $this->_hashLength = 512;
                break;
            default:
                $this->_hashAlgorithm = ' ';
                $this->_hashLength = 0;
                break;
        }
    }


    /*
	 * ------------------------------------------------------------------------------------------
	 * Gestion du chiffrement symétrique.
	 */
    private $_symetricAlgorithmList = array(), // Liste des fonctions de chiffrement symétrique.
        $_symetricAlgorithm,               // Fonction de chiffrement symétrique.
        $_symetricAlgorithmName,           // Fonction de chiffrement symétrique.
        $_symetricAlgorithmMode,           // Fonction de chiffrement symétrique.
        $_symetricKeyLength;               // Taille d'une clé et d'un bloc de chiffrement.

    // Retourne l'algorithme de chiffrement symétrique en cours d'utilisation.
    public function symetricAlgorithm()
    {
        return $this->_symetricAlgorithm;
    }

    public function symetricAlgorithmName()
    {
        return $this->_symetricAlgorithmName;
    }

    public function symetricAlgorithmMode()
    {
        return $this->_symetricAlgorithmMode;
    }

    // Retourne la longueur de clé de l'algorithme de chiffrement symétrique en cours d'utilisation.
    public function symetricKeyLength()
    {
        return $this->_symetricKeyLength;
    }

    // Vérifie le bon fonctionnement de l'algorithme de chiffrement symétrique en cours d'utilisation.
    public function checkSymetricFunction()
    {
        $check = false;

        // Liste tous les algorithmes de chiffrement supportés.
        $l = openssl_get_cipher_methods(true);

        // Pour chacun...
        foreach ($l as $a) {
            // Si c'est l'algorithme en cours.
            if ($a == $this->_symetricAlgorithmName) {
                // Compile les données sources, la clé et l'IV.
                $data = 'Bienvenue dans le projet nebule.';
                $hexIV = $this->_genSymetricAlgorithmNullIV();
                $binIV = pack("H*", $hexIV);
                $hexKey = "8fdf208b4a79cef62f4e610ef7d409c110cb5d20b0148b9770cad5130106b6a1";
                $binKey = pack("H*", $hexKey);
                // Encode.
                $code = openssl_encrypt($data, $this->_symetricAlgorithmName, $binKey, OPENSSL_RAW_DATA, $binIV);
                // Décode.
                $dcod = openssl_decrypt($code, $this->_symetricAlgorithmName, $binKey, OPENSSL_RAW_DATA, $binIV);
                // Si les données décodées sont les mêmes que les données sources.
                if ($data == $dcod)
                    $check = true; // Le test est bon.
                unset($data, $binIV, $hexIV, $binKey, $hexKey, $code, $dcod);
            }
        }
        unset($l, $a);
        return $check;
    }

    public function setSymetricAlgorithm($algo)
    {
        $algo = (string)$algo;
        if (sizeof($this->_symetricAlgorithmList) == 0) return false; // Vérifie si la liste des algorithmes n'est pas vide.
        if (!in_array($algo, $this->_symetricAlgorithmName)) return false;
        $this->_symetricAlgorithmName = $algo;
        $this->_genSymetricAlgorithmProperties();
        return true;
    }

    public function checkSymetricAlgorithm($algo)
    {
        if ($algo == '') return false;
        // A faire...
    }

    private function _genSymetricAlgorithmList()
    {
        //$this->_symetricAlgorithmList = array('aes-256-cbc', 'aes-256-ctr'); // Génère la liste des algorithmes disponibles. A revoir...
        $this->_symetricAlgorithmList = openssl_get_cipher_methods(true); // Génère la liste des algorithmes disponibles.
        $this->_symetricAlgorithmName = $this->_nebuleInstance->getOption('cryptoSymetricAlgorithm');
        $this->_genSymetricAlgorithmProperties();
    }

    private function _genSymetricAlgorithmProperties()
    {
        switch ($this->_symetricAlgorithmName) {
            case 'aes-256-ctr':
                $this->_symetricAlgorithm = 'aes';
                $this->_symetricKeyLength = 256;
                $this->_symetricAlgorithmMode = 'ctr';
                break;
            case 'aes-256-ecb':
                $this->_symetricAlgorithm = 'aes';
                $this->_symetricKeyLength = 256;
                $this->_symetricAlgorithmMode = 'ecb';
                break;
            case 'aes-256-cbc':
                $this->_symetricAlgorithm = 'aes';
                $this->_symetricKeyLength = 256;
                $this->_symetricAlgorithmMode = 'cbc';
                break;
            default:
                $this->_symetricAlgorithm = ' ';
                $this->_symetricKeyLength = 0;
                break;
        }
    }

    /**
     * Génère un IV nul pour l'algorythme symétrique.
     */
    private function _genSymetricAlgorithmNullIV()
    {
        $l = $this->_symetricKeyLength / 8;
        $r = '';
        for ($i = 0; $i < $l; $i++)
            $r = $r . '0';
        return $r;
    }

    /**
     * Chiffrement de données avec algorithme symétrique.
     * @param string $data
     * @param string $key
     * @param string $iv
     * @return string
     */
    public function crypt($data, $key, $hexIV = '')
    {
        // Vérifications.
        if (strlen($data) == 0) {
            return false;
        }
        if (strlen($key) == 0) {
            return false;
        }

        // Si IV null, en génère un à zéro.
        if ($hexIV == '') {
            $hexIV = $this->_genSymetricAlgorithmNullIV();
        }

        // Encode l'IV en binaire.
        $binIV = pack("H*", $hexIV);

        // Réalise le chiffrement.
        return openssl_encrypt($data, $this->_symetricAlgorithmName, $key, OPENSSL_RAW_DATA, $binIV);
    }

    /**
     * Déchiffrement de données avec algorithme symétrique.
     * @param string $data
     * @param string $key
     * @param string $iv
     * @return string
     */
    public function decrypt($data, $key, $hexIV = '')
    {
        // Vérifications.
        if (strlen($data) == 0) {
            return false;
        }
        if (strlen($key) == 0) {
            return false;
        }

        // Si IV null, en génère un à zéro.
        if ($hexIV == '') {
            $hexIV = $this->_genSymetricAlgorithmNullIV();
        }

        // Encode l'IV en binaire.
        $binIV = pack("H*", $hexIV);

        // Réalise le déchiffrement.
        return openssl_decrypt($data, $this->_symetricAlgorithmName, $key, OPENSSL_RAW_DATA, $binIV);
    }


    /*
	 * ------------------------------------------------------------------------------------------
	 * Gestion du chiffrement asymétrique.
	 */
    private $_asymetricAlgorithmList = array(), // Fonction de chiffrement asymétrique (càd avec clé publique/privée).
        $_asymetricAlgorithm,               // Fonction de chiffrement asymétrique (càd avec clé publique/privée).
        $_asymetricAlgorithmName,           // Fonction de chiffrement asymétrique (càd avec clé publique/privée).
        $_asymetricKeyLength;               // Taille d'une clé publique/privée.

    // Retourne l'algorithme de chiffrement asymétrique en cours d'utilisation.
    public function asymetricAlgorithm()
    {
        return $this->_asymetricAlgorithm;
    }

    public function asymetricAlgorithmName()
    {
        return $this->_asymetricAlgorithmName;
    }

    // Retourne la longueur de clé de l'algorithme de chiffrement asymétrique en cours d'utilisation.
    public function asymetricKeyLength()
    {
        return $this->_asymetricKeyLength;
    }

    // Vérifie le bon fonctionnement de l'algorithme de chiffrement asymétrique en cours d'utilisation.
    public function checkAsymetricFunction()
    {
        $check = false;
        // Essai avec un couple de clés public/privé de test. mdp=0000
        $private_pem = <<<EOD
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,687B57E822A2DA943BFE465B95E9C217

A0Cv5nNdSrFq5R5kGgWlNytpTOlJh5E4+PiZK5L5D2JMwjIogB7ASjf+RDCwWWeJ
pgGBnMDLXyHdC10x0vMSidp6oUHv/fT8hgEKPr+KaUKAhLIQTrh/MiTmmaOlXBED
i1cTv3ZPo4u9m593vJ79dSP4DKNVmVoS2b7iZlPAimHx2CE+raKAttYYZv9yhWti
7HyA/cJcHypsK3WtTzBEkhtkD73wcAn7dmWBVaitrPUzZDJLtiwW4I4TmfMnOvFB
bQRia5vJzGg97rBhi7pc/hPozdQaFDrAvsnB/pqea486iIvVH6u7rEOd0gFSei1H
/O4zjxW/1Nx97cJkqGvaJ4ZMgKIz2t/YXUgZUMLBdaav4D4cUx9s05c9mwop1Vk6
ZEWbQ42aefq9GmU0N2sqCUwdrvxzO6Trf7T554F+kibqkY2YGZrEDD0iLK4ZWWOc
ILu5MNEvDrdBMi4JBr/BhWSOkCDmm6/l9qaWdSQW7x29I3KGcbPdNcbtzoqT+Sqa
T7UHkzbgHcLCjRtyecyLIBdgwJzoS+uS98dlQI+KOuxJk7Iw/+73z8aM5tuPDdtf
V3BAxDAIT6spAjomWgGBtGaOKXVuJjmj177qhY97L79PmFYvPZPVVVKBpbQNcH8z
3sso2/aWy4qotavOM4wWNBa/dmJmXa6kJ/VjwScaUUrTXYnHTr8uIoXqlldDj1sE
A+KwfxWveZxC6IE9XzQQuyk7DgfkHdbwKQ5+IKzDrrmSTjyDY5u6xiEsvLd8oSw6
LfMSjTNzTsdGnojuLQAt4r8t+K3cV6TgF1T+rxt67iXe0xn340KJK8jt31XN//F5
ktUEvdKGM4VuWt9E51bPC5p3znwTUGfP49Aeh2g3vhIJc51FSvMUtjIBytaTwqht
V37UMmkR6LtMOzwdGaoasZ0IZFVu2KvWt31OL9lEtWFAtLGWZ4NfwOVy0yQHeLkV
EtOLBWpMaxkwlTd5XS5TlGoS+/M9JGpHh0LnNrf5VsfixXEyiITyci32HEv/u8pS
zrJ/9cSj8mhj/gT0Tr2yp59YC6+3AoVX/qn8ucZX/Nwtd+XPvGeJ20z7IoJXbtjQ
0nnTnpOKEhjE41+Vc7ZxTeLtZ1dtW9PnoWHznGXYjb+Rj8FXBuRBz9tnsmBbtHs8
vORC2bv1py1GgvVbMuavNx4Y0MzbEfvNlLcctvarcN4zr2CavSmpAgVsmrjDFBWY
YfUKzDiIn3+O5T/nOXXvIjN5dw5tS2KUeZ+TFVQezoYhc6fZM5pNVlnbwa0zkXWZ
DW8RWy+bmB5nJiMliARWxqSSkaI5RG3dAyT5LsCV0U9Aolfr//bqvHWk/49zT0gf
uOUf4HEEslKM/f9RBDkLLOYAJzmq1Be/kWc4MkhVOqBu8qQg841aPsuioJdC6Ib2
mMw+at7hw80kCB6xqSJaSvbaSS4isTSGKxjPFtqXWQc9E2cvStTcoIaiT33JG/TN
U9tOokWpyoUJtPZanhMyBF/A9GAzo7DFuuL/4bGZ5bmoyFfH+wAjQPKqBDTREmHO
sTqIWSkAHD8dEZgukAY7kUsWrYnAqxaKbyAuT4Ni6SUcU2PiF2agvJh7Pe2SZyLj
-----END RSA PRIVATE KEY-----
EOD;
        $public_pem = <<<EOD
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvUKNo2kJ5XYg7hh1X6rS
roMdy5d1CAhGzas2PzAwAc/8UdTiaOpQkhVYgyP/oM5ouROaTuALQ4RCY04O14op
wk56EQTPZfnbIIFZYyGZeH8w8S5Nabv2F9XK9eQJL0LgozBWBMAQpsuiqgJiq0Fe
XAUetu3McVlSd9Ro1F0xsjTTff6HIxNvCEwLM748rCXIDLxTxGYG5+YehigzH/at
jRAiRdZxSruYPyQcxWhZei5mSqLr31beZ2HmoNRiqOgx9FRqrJSLlCQSjv0Z9Ubu
17EVQB2iTsdjaNk7GqPdclBnXkaOg/VxIHsVeoUylukOPda+uTkvMiu9Ao9s/+A9
bwIDAQAB
-----END PUBLIC KEY-----
EOD;
        $private_pass = "0000";

        $data = 'Bienvenue dans le projet nebule.';
        $private_key = openssl_pkey_get_private($private_pem, $private_pass);
        $public_key = openssl_pkey_get_public($public_pem);
        $decrypted = '';
        $hashdata = hash($this->_hashAlgorithmName, $data);

        // Signe les données.
        $binary_signature = '';
        $binhash = pack('H*', $hashdata);
        openssl_private_encrypt($binhash, $binary_signature, $private_key, OPENSSL_PKCS1_PADDING);

        $hexsign = bin2hex($binary_signature);
        //$binsign = hex2bin($hexsign);
        $binsign = pack('H*', $hexsign);

        // Vérifie la signature avec la clé publique.
        $ok = openssl_public_decrypt($binsign, $decrypted, $public_key, OPENSSL_PKCS1_PADDING);
        $decrypted = (bin2hex($decrypted));
        if ($ok && $decrypted == $hashdata)
            $check = true;

        unset($data, $private_pass, $private_pem, $private_key, $public_pem, $public_key, $ok,
            $data, $hashdata, $binary_signature, $hexsign, $binsign, $decrypted);

        return $check;
    }

    public function setAsymetricAlgorithm($algo)
    {
        $algo = (string)$algo;
        if (sizeof($this->_asymetricAlgorithmList) == 0) return false; // Vérifie si la liste des algorithmes n'est pas vide.
        if (!in_array($algo, $this->_asymetricAlgorithmName)) return false;
        $this->_asymetricAlgorithmName = $algo;
        $this->_genAsymetricAlgorithmProperties();
        return true;
    }

    public function checkAsymetricAlgorithm($algo)
    {
        if ($algo == '') return false;
        // A faire...
    }

    private function _genAsymetricAlgorithmList()
    {
        // Génère la liste des algorithmes disponibles. A revoir...
        $this->_asymetricAlgorithmList = array('rsa1024', 'rsa2048', 'rsa4096', 'ecdsa');        // A revoir...
        $this->_asymetricAlgorithmName = $this->_nebuleInstance->getOption('cryptoAsymetricAlgorithm');
        $this->_genAsymetricAlgorithmProperties();
        /*
OPENSSL_KEYTYPE_RSA (entier)
OPENSSL_KEYTYPE_DSA (entier)
OPENSSL_KEYTYPE_DH (entier)
OPENSSL_KEYTYPE_EC (entier)
		 */
    }

    private function _genAsymetricAlgorithmProperties()
    {
        switch ($this->_asymetricAlgorithmName) {
            case 'rsa1024':
                $this->_asymetricAlgorithm = 'rsa';
                $this->_asymetricKeyLength = 1024;
                break;
            case 'rsa2048':
                $this->_asymetricAlgorithm = 'rsa';
                $this->_asymetricKeyLength = 2048;
                break;
            case 'rsa4096':
                $this->_asymetricAlgorithm = 'rsa';
                $this->_asymetricKeyLength = 4096;
                break;
            default:
                $this->_asymetricAlgorithm = ' ';
                $this->_asymetricKeyLength = 0;
                break;
        }
    }

    public function sign($hash, $privateKey, $privatePassword)
    {
        global $nebuleInstance;
        $signatureBin = '';
        // Extrait la clé privée déchiffrée.
        $privateKeyBin = openssl_pkey_get_private($privateKey, $privatePassword);
        // Encode la signature en binaire.
        $hashDataBin = pack('H*', $hash);
        // Signe les données.
        $ok = openssl_private_encrypt($hashDataBin, $signatureBin, $privateKeyBin, OPENSSL_PKCS1_PADDING);
        // Nettoyage des variables.
        $privatePassword = '';
        unset($privateKeyBin, $hash, $hashDataBin);
        // Si la fonction de chiffrement a bien fonctionnée.
        if ($ok !== false) {
            // Décode la signature en héxa.
            $signature = bin2hex($signatureBin);
            // Retourne la valeur en héxa de la signature.
            return $signature;
        }
        // Sinon retourne que ça s'est mal passé.
        $nebuleInstance->getMetrologyInstance()->addLog('ERROR crypto sign', Metrology::LOG_LEVEL_NORMAL); // Log
        return false;
    }

    public function verify($hash, $sign, $publicKey)
    {
        // Extrait la clé publique de l'entité signataire.
        $pubkeyid = openssl_pkey_get_public($publicKey);

        // Vérifie la présence et la cohérence de la clé publique.
        if ($pubkeyid === false) {
            return false;
        }

        // Encode la signature pour la vérification.
        $binsign = pack('H*', $sign);
        // Déchiffre la signature avec la clé publique.
        $okdec = openssl_public_decrypt($binsign, $decrypted, $pubkeyid, OPENSSL_PKCS1_PADDING);
        // Extrait la signature déchiffrée.
        $decrypted = substr(bin2hex($decrypted), -64, 64);                                        // @todo WARNING A faire pour le cas général.
        // Vérifie la signature.
        if ($okdec !== false && $decrypted == $hash) {
            return true;
        }
        //else
        return false;
    }

    public function cryptTo($data, $publicKey)
    {
        $code = '';
        // Extrait la clé privée déchiffrée.
        $pubkeyid = openssl_pkey_get_public($publicKey);
        // Vérifie la présence et la cohérence de la clé publique.
        if ($pubkeyid === false)
            return false;
        // Chiffre les données.
        $ok = openssl_public_encrypt($data, $code, $pubkeyid, OPENSSL_PKCS1_PADDING);
        // Nettoyage des variables.
        $data = null;
        $publicKey = null;
        unset($pubkeyid);
        // Si la fonction de chiffrement a bien fonctionnée.
        if ($ok !== false)
            return $code;
        // Sinon retourne que ça s'est mal passé.
        return false;
    }

    public function decryptTo($code, $privateKey, $privatePassword)
    {
        $data = '';
        // Extrait la clé privée déchiffrée.
        $privateKeyBin = openssl_pkey_get_private($privateKey, $privatePassword);
        // Signe les données.
        //$ok = openssl_public_decrypt($code, $data, $privateKeyBin, OPENSSL_PKCS1_PADDING);
        $ok = openssl_private_decrypt($code, $data, $privateKeyBin, OPENSSL_PKCS1_PADDING);
        // Nettoyage des variables.
        $code = null;
        $privatePassword = null;
        unset($privateKeyBin);
        // Si la fonction de déchiffrement a bien fonctionnée.
        if ($ok !== false)
            return $data;
        // Sinon retourne que ça s'est mal passé.
        return false;
    }


    // Génération d'une pkey pour une entité nebule.
    public function newPkey()
    {
        // Vérifie que l'algorithme est correcte.
        if ($this->_asymetricAlgorithm == '') return false;

        // Configuration de la génération.
        $config = array();
        switch ($this->_asymetricAlgorithm) {
            case 'rsa' :
                $config['private_key_type'] = OPENSSL_KEYTYPE_RSA;
                break;
            case 'dsa' :
                $config['private_key_type'] = OPENSSL_KEYTYPE_DSA;
                break;
            default    :
                return false;
                break;
        }
        $config['digest_alg'] = $this->_hashAlgorithmName;
        $config['private_key_bits'] = $this->_asymetricKeyLength;

        // Génération d'un bi-clé.
        $newPkey = openssl_pkey_new($config); // @todo Vérifier la bonne génération du bi-clé et refaire si besoin...
        unset($config);
        return $newPkey;
    }

    // Extraction de la clé publique.
    public function getPkeyPublic($pkey)
    {
        $fullPublicKey = openssl_pkey_get_details($pkey);
        return $fullPublicKey['key'];
    }

    // Extraction de la clé privée, de préférence protégée par mot de passe.
    public function getPkeyPrivate($pkey, $password = '')
    {
        if ($password == '') {
            openssl_pkey_export($pkey, $privkey, null);
        } else {
            openssl_pkey_export($pkey, $privkey, $password);
        }
        return $privkey;
    }

    // Extrait une clé privée.
    public function getPrivateKey($privateKey, $password)
    {
        return openssl_pkey_get_private($privateKey, $password);
    }
}


/**
 * L'interface SocialInterface.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
interface SocialInterface
{
    public function arraySocialFilter(array &$links, $socialClass = '');

    public function linkSocialScore(Link &$link, $socialClass = '');
}


/**
 * Classe de gestion du côté social des liens limités à l'entité en cours.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
class Social implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;
    private $_instanceSocialMySelf;
    private $_instanceSocialNotMySelf;
    private $_instanceSocialSelf;
    private $_instanceSocialNotself;
    private $_instanceSocialStrict;
    private $_instanceSocialAll;
    private $_instanceSocialNone;
    private $_instanceSocialOnList;
    private $_instanceSocialOffList;
    private $_instanceSocialReputation;
    private $_instanceSocialUnreputation;
    private $_instanceSocialDefault;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
        $this->_instanceSocialMySelf = new SocialMySelf();
        $this->_instanceSocialNotMySelf = new SocialNotMySelf();
        $this->_instanceSocialSelf = new SocialSelf();
        $this->_instanceSocialNotself = new SocialNotself();
        $this->_instanceSocialStrict = new SocialStrict();
        $this->_instanceSocialAll = new SocialAll();
        $this->_instanceSocialNone = new SocialNone();
        $this->_instanceSocialOnList = new SocialOnList();
        $this->_instanceSocialOffList = new SocialOffList();
        $this->_instanceSocialReputation = new SocialReputation();
        $this->_instanceSocialUnreputation = new SocialUnreputation();

        // Détermine le traitement social par défaut.
        switch ($this->_nebuleInstance->getOption('socialLibrary')) {
            case 'myself':
                $this->_instanceSocialDefault = $this->_instanceSocialMySelf;
                break;
            case 'notmyself':
                $this->_instanceSocialDefault = $this->_instanceSocialNotMySelf;
                break;
            case 'self':
                $this->_instanceSocialDefault = $this->_instanceSocialSelf;
                break;
            case 'notself':
                $this->_instanceSocialDefault = $this->_instanceSocialNotself;
                break;
            case 'strict':
                $this->_instanceSocialDefault = $this->_instanceSocialStrict;
                break;
            case 'all':
                $this->_instanceSocialDefault = $this->_instanceSocialAll;
                break;
            case 'none':
                $this->_instanceSocialDefault = $this->_instanceSocialNone;
                break;
            case 'onlist':
                $this->_instanceSocialDefault = $this->_instanceSocialOnList;
                break;
            case 'offlist':
                $this->_instanceSocialDefault = $this->_instanceSocialOffList;
                break;
            case 'reputation':
                $this->_instanceSocialDefault = $this->_instanceSocialOffList;
                break;
            case 'offlist':
                $this->_instanceSocialDefault = $this->_instanceSocialOffList;
                break;
            default:
                $this->_instanceSocialDefault = $this->_instanceSocialStrict;
                break;
        }
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
        $this->_instanceSocialMySelf = new SocialMySelf();
        $this->_instanceSocialNotMySelf = new SocialNotMySelf();
        $this->_instanceSocialSelf = new SocialSelf();
        $this->_instanceSocialNotself = new SocialNotself();
        $this->_instanceSocialStrict = new SocialStrict();
        $this->_instanceSocialAll = new SocialAll();
        $this->_instanceSocialNone = new SocialNone();
        $this->_instanceSocialOnList = new SocialOnList();
        $this->_instanceSocialOffList = new SocialOffList();
        $this->_instanceSocialReputation = new SocialReputation();
        $this->_instanceSocialUnreputation = new SocialUnreputation();

        // Détermine le traitement social par défaut.
        switch ($this->_nebuleInstance->getOption('socialLibrary')) {
            case 'myself':
                $this->_instanceSocialDefault = $this->_instanceSocialMySelf;
                break;
            case 'notmyself':
                $this->_instanceSocialDefault = $this->_instanceSocialNotMySelf;
                break;
            case 'self':
                $this->_instanceSocialDefault = $this->_instanceSocialSelf;
                break;
            case 'notself':
                $this->_instanceSocialDefault = $this->_instanceSocialNotself;
                break;
            case 'strict':
                $this->_instanceSocialDefault = $this->_instanceSocialStrict;
                break;
            case 'all':
                $this->_instanceSocialDefault = $this->_instanceSocialAll;
                break;
            case 'none':
                $this->_instanceSocialDefault = $this->_instanceSocialNone;
                break;
            case 'onlist':
                $this->_instanceSocialDefault = $this->_instanceSocialOnList;
                break;
            case 'offlist':
                $this->_instanceSocialDefault = $this->_instanceSocialOffList;
                break;
            case 'reputation':
                $this->_instanceSocialDefault = $this->_instanceSocialReputation;
                break;
            case 'unreputation':
                $this->_instanceSocialDefault = $this->_instanceSocialUnreputation;
                break;
            default:
                $this->_instanceSocialDefault = $this->_instanceSocialStrict;
                break;
        }
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        switch ($socialClass) {
            case 'myself':
                return $this->_instanceSocialMySelf->arraySocialFilter($links, '');
                break;
            case 'notmyself':
                return $this->_instanceSocialNotMySelf->arraySocialFilter($links, '');
                break;
            case 'self':
                return $this->_instanceSocialSelf->arraySocialFilter($links, '');
                break;
            case 'notself':
                return $this->_instanceSocialNotself->arraySocialFilter($links, '');
                break;
            case 'strict':
                return $this->_instanceSocialStrict->arraySocialFilter($links, '');
                break;
            case 'all':
                return $this->_instanceSocialAll->arraySocialFilter($links, '');
                break;
            case 'none':
                return $this->_instanceSocialNone->arraySocialFilter($links, '');
                break;
            case 'onlist':
                return $this->_instanceSocialOnList->arraySocialFilter($links, '');
                break;
            case 'offlist':
                return $this->_instanceSocialOffList->arraySocialFilter($links, '');
                break;
            case 'reputation':
                return $this->_instanceSocialReputation->arraySocialFilter($links, '');
                break;
            case 'unreputation':
                return $this->_instanceSocialUnreputation->arraySocialFilter($links, '');
                break;
            default:
                return $this->_instanceSocialDefault->arraySocialFilter($links, '');
                break;
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $result = 0;

        switch ($socialClass) {
            case 'myself':
                $result = $this->_instanceSocialMySelf->linkSocialScore($link, '');
                break;
            case 'notmyself':
                $result = $this->_instanceSocialNotMySelf->linkSocialScore($link, '');
                break;
            case 'self':
                $result = $this->_instanceSocialSelf->linkSocialScore($link, '');
                break;
            case 'notself':
                $result = $this->_instanceSocialNotself->linkSocialScore($link, '');
                break;
            case 'strict':
                $result = $this->_instanceSocialStrict->linkSocialScore($link, '');
                break;
            case 'all':
                $result = $this->_instanceSocialAll->linkSocialScore($link, '');
                break;
            case 'none':
                $result = $this->_instanceSocialNone->linkSocialScore($link, '');
                break;
            case 'onlist':
                $result = $this->_instanceSocialOnList->linkSocialScore($link, '');
                break;
            case 'offlist':
                $result = $this->_instanceSocialOffList->linkSocialScore($link, '');
                break;
            case 'reputation':
                $result = $this->_instanceSocialReputation->linkSocialScore($link, '');
                break;
            case 'unreputation':
                $result = $this->_instanceSocialUnreputation->linkSocialScore($link, '');
                break;
            default:
                $result = $this->_instanceSocialDefault->linkSocialScore($link, '');
                break;
        }

        return $result;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     * Nécessaire à certains filtrages sociaux, ignoré par d'autres.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$list, $socialClass = '')
    {
        $result = false;

        switch ($socialClass) {
            case 'myself':
                $result = $this->_instanceSocialMySelf->setList($list);
                break;
            case 'notmyself':
                $result = $this->_instanceSocialNotMySelf->setList($list);
                break;
            case 'self':
                $result = $this->_instanceSocialSelf->setList($list);
                break;
            case 'notself':
                $result = $this->_instanceSocialNotself->setList($list);
                break;
            case 'strict':
                $result = $this->_instanceSocialStrict->setList($list);
                break;
            case 'all':
                $result = $this->_instanceSocialAll->setList($list);
                break;
            case 'none':
                $result = $this->_instanceSocialNone->setList($list);
                break;
            case 'onlist':
                $result = $this->_instanceSocialOnList->setList($list);
                break;
            case 'offlist':
                $result = $this->_instanceSocialOffList->setList($list);
                break;
            case 'reputation':
                $result = $this->_instanceSocialReputation->setList($list);
                break;
            case 'unreputation':
                $result = $this->_instanceSocialUnreputation->setList($list);
                break;
            default:
                $result = $this->_instanceSocialDefault->setList($list);
                break;
        }

        return $result;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList($socialClass = '')
    {
        $result = false;

        switch ($socialClass) {
            case 'myself':
                $result = $this->_instanceSocialMySelf->unsetList();
                break;
            case 'notmyself':
                $result = $this->_instanceSocialNotMySelf->unsetList();
                break;
            case 'self':
                $result = $this->_instanceSocialSelf->unsetList();
                break;
            case 'notself':
                $result = $this->_instanceSocialNotself->unsetList();
                break;
            case 'strict':
                $result = $this->_instanceSocialStrict->unsetList();
                break;
            case 'all':
                $result = $this->_instanceSocialAll->unsetList();
                break;
            case 'none':
                $result = $this->_instanceSocialNone->unsetList();
                break;
            case 'onlist':
                $result = $this->_instanceSocialOnList->unsetList();
                break;
            case 'offlist':
                $result = $this->_instanceSocialOffList->unsetList();
                break;
            case 'reputation':
                $result = $this->_instanceSocialReputation->unsetList();
                break;
            case 'unreputation':
                $result = $this->_instanceSocialUnreputation->unsetList();
                break;
            default:
                $result = $this->_instanceSocialDefault->unsetList();
                break;
        }

        return $result;
    }

    /**
     * Retourne la liste des modes de calculs sociaux disponibles.
     *
     * @return array
     */
    public function getList()
    {
        return array('myself', 'notmyself', 'self', 'notself', 'strict', 'all', 'none', 'onlist', 'offlist', 'reputation', 'unreputation');
    }
}


/**
 * Classe de gestion du côté social des liens limités à l'entité en cours.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Si le signataire du lien est l'entité en cours, retourne un score de 1.
 * Sinon retourne un score de 0.
 */
class SocialMySelf implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) != 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=myself score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        // Si l'entité signataire du lien est une des entités courante, retourne la valeur sociale 1.
        if ($link->getHashSigner_disabled() == $this->_nebuleInstance->getCurrentEntity()) {
            $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=myself score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
            return 1;
        }

        // Sinon par défaut retourne la valeur sociale 0.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=myself score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 0;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens limités à tout sauf l'entité en cours.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Si le signataire du lien est l'entité en cours, retourne un score de 0.
 * Sinon retourne un score de 1.
 */
class SocialNotMyself implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) != 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=notmyself score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        // Si l'entité signataire du lien est une des entités courante, retourne la valeur sociale 1.
        if ($link->getHashSigner_disabled() != $this->_nebuleInstance->getCurrentEntity()) {
            $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=notmyself score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
            return 1;
        }

        // Sinon par défaut retourne la valeur sociale 0.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=notmyself score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 0;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens limités à l'entité en cours d'affichage.
 * Ce peut être une entité différente de l'entité déverrouillée.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Si le signataire du lien est l'entité en cours d'affichage, retourne un score de 1.
 * Sinon retourne un score de 0.
 */
class SocialSelf implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;
    private $_applicationInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) != 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        global $applicationInstance;

        // Charge l'instance de l'application si présente.
        $this->_applicationInstance = $applicationInstance;
        if (!is_a($applicationInstance, 'Applications')) {
            $this->_applicationInstance = $this->_nebuleInstance;
        }

        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=self score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        // Si l'entité signataire du lien est une des entités courante, retourne la valeur sociale 1.
        if ($link->getHashSigner_disabled() == $this->_applicationInstance->getCurrentEntity()) {
            $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=self score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
            return 1;
        }

        // Sinon par défaut retourne la valeur sociale 0.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=self score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 0;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens limités à tout sauf l'entité en cours d'affichage.
 * Ce peut être une entité différente de l'entité déverrouillée.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Si le signataire du lien est l'entité en cours d'affichage, retourne un score de 0.
 * Sinon retourne un score de 1.
 */
class SocialNotself implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;
    private $_applicationInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) != 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        global $applicationInstance;

        // Charge l'instance de l'application si présente.
        $this->_applicationInstance = $applicationInstance;
        if (!is_a($applicationInstance, 'Applications')) {
            $this->_applicationInstance = $this->_nebuleInstance;
        }

        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=notself score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        // Si l'entité signataire du lien est une des entités courante, retourne la valeur sociale 1.
        if ($link->getHashSigner_disabled() != $this->_applicationInstance->getCurrentEntity()) {
            $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=notself score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
            return 1;
        }

        // Sinon par défaut retourne la valeur sociale 0.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=notself score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 0;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe de gestion du côté social stricte des liens.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Si le signataire du lien est une des entités autorités locales, retourne un score de 1.
 * Sinon retourne un score de 0.
 */
class SocialStrict implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) != 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=strict score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        // Si l'entité signataire du lien est une des entités autorités, retourne la valeur sociale 1.
        foreach ($this->_nebuleInstance->getLocalAuthorities() as $autority) {
            if ($link->getHashSigner_disabled() == $autority) {
                $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=strict score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
                return 1;
            }
        }

        // Sinon par défaut retourne la valeur sociale 0.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=strict score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 0;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens, garde tout.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Retourne toujours un score de 1.
 */
class SocialAll implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) != 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=all score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=all score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);

        return 1;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens, supprime tout.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Retourne toujours un score de 0.
 */
class SocialNone implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        $links = array();
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=none score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=none score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);

        return 0;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens par rapport à une liste d'ID.
 * Ne sélectionne que les liens des entités de la liste.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * La liste doit être préalablement chargée.
 *
 * Si le signataire du lien est une des entités de la liste, retourne un score de 1.
 * Sinon retourne un score de 0.
 */
class SocialOnList implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) != 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=onlist score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        if (sizeof($this->_list) == 0) {
            return 0;
        }

        // Si l'entité signataire du lien est une des entités autorités, retourne la valeur sociale 1.
        foreach ($this->_list as $id) {
            if ($link->getHashSigner_disabled() == $id) {
                $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=onlist score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
                return 1;
            }
        }

        // Sinon par défaut retourne la valeur sociale 0.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=onlist score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 0;
    }

    /**
     * Liste pour le calcul/filtrage social.
     * @var array:string
     */
    private $_list = array();

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        if (!is_array($listID)) {
            return false;
        }

        foreach ($listID as $id) {
            if (is_string($id)
                && $id != ''
                && $id != '0'
                && ctype_xdigit($id)
            ) {
                $this->_list[$id] = $id;
            } else {
                $this->_list = array();
                return false;
            }
        }
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        $this->_list = array();
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens par rapport à une liste d'ID.
 * Ne sélectionne que les liens des entités qui ne sont pas dans la liste.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * La liste doit être préalablement chargée.
 *
 * Si le signataire du lien est une des entités de la liste, retourne un score de 0.
 * Sinon retourne un score de 1.
 */
class SocialOffList implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) != 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer.
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=offlist score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        if (sizeof($this->_list) == 0) {
            return 0;
        }

        // Si l'entité signataire du lien est une des entités autorités, retourne la valeur sociale 0.
        foreach ($this->_list as $id) {
            if ($link->getHashSigner_disabled() == $id) {
                $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=offlist score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
                return 0;
            }
        }

        // Sinon par défaut retourne la valeur sociale 1.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=offlist score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 1;
    }

    /**
     * Liste pour le calcul/filtrage social.
     * @var array:string
     */
    private $_list = array();

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        if (!is_array($listID)) {
            return false;
        }

        foreach ($listID as $id) {
            if (is_string($id)
                && $id != ''
                && $id != '0'
                && ctype_xdigit($id)
            ) {
                $this->_list[$id] = $id;
            } else {
                $this->_list = array();
                return false;
            }
        }
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        $this->_list = array();
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens par rapport à la réputation des entités.
 * Ne sélectionne que les liens des entités qui sont bien réputées.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Si le signataire du lien est une des entités de la liste, retourne un score de 1. @todo
 * Sinon retourne un score de 0.
 */
class SocialReputation implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) >= 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer. @todo
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=reputation score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        // Si l'entité signataire du lien est une des entités autorités, retourne la valeur sociale 1.
        foreach ($this->_list as $id) {
            if (false) {
                $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=reputation score 1 for ' . $link->getHashSigner(), Metrology::LOG_LEVEL_DEBUG);
                return 1;
            }
        }

        // Sinon par défaut retourne la valeur sociale 0.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=reputation score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 0;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe de gestion du côté social des liens par rapport à la réputation des entités.
 * Ne sélectionne que les liens des entités qui ne sont pas bien réputées.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 *
 * Si le signataire du lien est une des entités de la liste, retourne un score de 1. @todo
 * Sinon retourne un score de 0.
 */
class SocialUnreputation implements SocialInterface
{
    /** Instance nebule en cours. */
    private $_nebuleInstance;

    /**
     * Constructeur.
     */
    public function __construct()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    public function __sleep()
    {
        return array();
    }

    public function __wakeup()
    {
        global $nebuleInstance;
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Gère le classement social des liens.
     *
     * @param array &$links table des liens.
     * @return float
     */
    public function arraySocialFilter(array &$links, $socialClass = '')
    {
        foreach ($links as $i => $link) {
            if ($this->linkSocialScore($link) < 1) {
                unset($links[$i]);
            }
        }
    }

    /**
     * Calcul le score social d'un lien.
     *
     * @param Link &$link lien à calculer. @todo
     * @return float
     */
    public function linkSocialScore(Link &$link, $socialClass = '')
    {
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Ask link social=unreputation score for ' . $link->getSigneValue_disabled(), Metrology::LOG_LEVEL_DEBUG);

        // Si l'entité signataire du lien est une des entités autorités, retourne la valeur sociale 1.
        foreach ($this->_list as $id) {
            if (true) {
                $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=unreputation score 1 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
                return 1;
            }
        }

        // Sinon par défaut retourne la valeur sociale 0.
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Link social=unreputation score 0 for ' . $link->getHashSigner_disabled(), Metrology::LOG_LEVEL_DEBUG);
        return 0;
    }

    /**
     * Permet d'injecter une liste pour le calcul/filtrage social.
     *
     * La liste doit contenir des ID d'objet et non des objets.
     *
     * @param array:string $listID
     * @return boolean
     */
    public function setList(&$listID)
    {
        return true;
    }

    /**
     * Permet de vider la liste pour le calcul/filtrage social.
     *
     * @return boolean
     */
    public function unsetList()
    {
        return true;
    }
}


/**
 * Classe Displays
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
abstract class Displays
{
    /* ---------- ---------- ---------- ---------- ----------
	 * Constantes.
	 *
	 * Leur modification change profondément le comportement de l'application.
	 *
	 * Si déclarées 'const' ou 'static' elles ne sont pas remplacée dans les classes enfants
	 *   lorsque l'on appelle des fonctions de la classe parente non écrite dans la classe enfant.
	 */
    const DEFAULT_APPLICATION_LOGO = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAARoElEQVR42u2dbbCcZX2Hrz1JMBSUAoEECCiVkLAEEgKkSBAwgFgGwZFb6NBOSVJn0H5peXXqSwVrdQZF6Cd0RiQ4kiH415ZpOlUECpKABBLewkIAayFAAgRCGxBylJx+2KdDwHCS7Ov9PHtdMzt8IGf32f/ev+v+388riIiIiIiIiIiIiIhINalZgvKTUtoTmFy89gUmAXsDewC7F69dgV2AnYGdgLFb/P4jwO+BYeAN4HVgI/AqsAF4BXgRWAc8DzwLrImIV6y+ApDehHx/4LDiVQemAR8G9uzzpr0M/Bp4HGgAjwCPRMQafzUFIK2F/XDgOGB28TrkXf9kJMPfbmvb9BiwvHgtjYiH/XUVgLwz7GOBU4GTgZOKGT7noLcrhkeA24BbgVsi4neOAgUwaKE/ETgTOB04aMDL8RSwBLg5Iu5wdCiAKgb+j4BzgXOKmV7em1uBG4FFEfGG5VAAZQ39B4AFwHnAzAq19L1cMjwA/BC4NiI2WhoFUIbg/zXwOeAoQ99RGdwPfDcirrUsCiC30M8BLgQ+beh7IoOfAFdFxDLLogD6FfoacBFwCc2Tbgx972XwInAF8J2IGLEsCqAXwd8fuByY72yfVVdwHfBVT0BSAN0K/mzgm8Bcq5E1twN/HxHLLYUC6ETw5wJXAYc725eqK3gYuCAibrckCqCV4J8IXEPznHuDX14RPA583pOMFMD2Bn9msZ6cafArJYIHgfkR8aAlUQBbC/5EYCHwCYNf
aRH8DJgXES9YEhiyBJBS+mea17qfqhgrP9mdCqxLKV1tSQZ8oKeU/qJo98c5FAaSYWBBRNygAAYr+PvRvALNdb7LghrNaw4+GRHPuQSofvgvp3lLqxl2QXbAxX9nAs+mlC6zA6hu8A+meSOKyY57GYVngZMi4gk7gOqE/zJgNbCf41u2wX7A6kHpBmoVD/6ewDJgquNaWmA1cGyV7348VOHwnw2sBw52HEuLHAy8XIwlBVCi8N8ALMY9/NJ+hzwCLC7GlEuAzIM/geYhHXf0STdYA8yKiPV2APmF/3jgJdzRJ91jMvBSMdYUQEbh/wJwpy2/9GhJcGdK6VKXAHmE/ybgM45N6QM/joizFUB/gl8DHuKdT9IR6TUPAzPLek/CWknDvxvNY7R72/JLnxkBXgCmRsT/KoDuh38y8AQw3vBLRhJ4E5hStguKhkoW/jrwjOGXDCfS8cCalNIhCqA74T8SeLTMSxepvAQAGimlWQqgs+E/huajoTzMJ7lLYARYkVL6U/cBdC789xh+Kdk+gRpwTETcqwDaa/ud+aXMEjgqIlYogB0Pf71Y8xt+KbsE6hHxmALY/vBPprm3H8MvFZAAwAER8awC2Hb4P0DzxIr3GX6pkAQ2ARNzO1loKLPw12ie4Wf4pUrUijG9uhjjCuA9eACYaPilohKYWIxxBbCV2X8xzVt1G36psgRmpJRuzGWDxmQS/i8Af+v4kAFher1e/22j0bg7ByP1O/zH07yZh8igcXxE3DWwAiju4fcSHuuXweP/x/yEiHh5UPcBrDD8MsD7A0aA
lf3ciL4JoLjN8gGGXwZcAgeklH7Urw0Y06fwnwNc7u8vAsDh9Xr9sUaj8Wjl9wEUj+tab+sv0v/9Af1YAtxt+EW2uj9gWaWXAMUTV88y/CJblcCEer1Oo9G4s5cf2qvwT6F5M08RGZ0pEfFU1ZYAt/H2pZEi8t77A26v1BKgaP3PyKH1r9VcfViLrOtRA3br1VKg1oPwT6b5VNVsmDBhAuvXr3fEA6eddhrjx48f+DoMDw+zZMmS3DZrcrefMzC2B1/i38hsr/+JJ57I0qVLWbdu3cAP/HHjxjFu3Dj77pHsVqcjRXa6eovxru4DSCmdC8wks73+b731FieccAKTJk2yBZBsVyTAEUWGyikAYCEZ7/hTApJ7Y1JkqHwCSCldDYwj82P+SkAy7wLGpZSuKpUAUkoTKdENPpSAZM7fFZkqTQdwHSU75q8EJPOlwA9KIYCU0gzgzyjh6b5KQDJeCpxWZCv7DqB0s78SkEHtAjoqgOL+fkdQ8ot9lIBk2gXMKjKWbQfwPSpyvr8SkEy7gO9mKYCU0seAaVToUl8lIBl2AYeklE7MsQO4igpe7acEJMMu4OqsBJBSmk2Fn+qjBCSzLmBGkblsOoBvUvFr/ZWAZNYFfCMLAaSU9gfmMgC3+VICklEXcFJxqX3fO4DLBqnySkAy4vK+CqB41vmCQau6EpBMWNBXAQAXDmrllYDkQErpon4K4FIG+EafSkD6zAhwSV8EkFL6CLA3A36PfyUgfaQGTEwpHdOPDuBCvM23EpAcuoAL+yGAhE/4UQKSQxfwmZ4KIKU0
37orAcmHlNK8XnYAn7P9VwKS1TLg8z0RQEppV2C27b8SkKyWAbNTSrv0ogNYYL2VgGTJgl4IYJ7tvxKQLJcB87oqgJTSeCpwyy8lIBVdBswqMtq1DuBc66wEJGvO7aYA/tz2XwlI1suAs7spgFNs/5WAZL0MOLUrAujkjQiVgBKQ7rEjtw7fkQ7gDEurBKQUnNkNAXzSuioBKQWnd1QAKaWxwEHWVQlIKTg4pTSmkx3AKdZUCUip+HgnBXCy9VQCUirmdlIAJ1lPJSCl4uROCmCG9VQCUipmdkQAKaVDraUSkPKRUjqsEx3AcZZSCUgpmdMJARyD5/8rASkbI0V22xbAUXj+vxKQslEDju6EAKZbSyUgpaTelgBSSvtZQyUg5SWltG87HYCH/5SAlJsZ7QjAQ4BKQMrN9HYEUMcjAEpAysrItvYDbEsA0/AIgBKQslIDprYjgCnWUAlIqZnSjgD2tH5KQErNhJYEkFLa3dopASk/KaU/bqUDOMDSKQGpBB9sRQCTrZsSkEowuRUBeBagEpBqsG8rApho3ZSAVIKJrQhgb+umBKT0jIyW5dEE4CFAJSDlpzZalkcTgIcBlYBUg91bEcBu1k0JSCVo6TyA91s3JSCVYNdWBLCLdVMCUgl2aUUA462bEpBKsHMrAtjJuikBqQQ7tSKAcdZNCUglGNuKAIasW7UlsNdeezE05M88AAwZcvkD5syZw1133WUhNMNW2Wx5qs3IyAjr16/njjvusBjVZnMrAviddRsMXnjhBSVQbX7figCGrZsSkEow3IoA3rRu
SkAqwRutCOB166YEpBK83ooANlo3JSCV4LVWBPA/1k0JSCV4tRUBbLBuSkAJVIINrQjgZesmSqD0jIyW5dEE8KK1EyVQemqjZXk0AayzdqIEKsG6VgTwvHUTJVAJ1rYigGetmyiBSrCmFQE8Y91ECVSCZ3ZYABHhYUBRAhUgIlo6DwBgveUTJVBqXhrtf25LAE9aP1ECpeapdgSwmuaJBCJKoHyMAI+3I4AGzRMJRJRA+agVGW5ZAKusoSiBUrOqHQE8ZP1ECZSah1oWQER4NqAogRITEWvb6QBcBogSKC+Nbf2D7RHAfXgkQJRA2RgBlndCAL/CIwGiBMpGrchu2wJYZi1FCZSSZW0LICIetY6iBMpHRKxqWwAFD1pOUQKl4oHt+UfbK4BbracogVJxWycFcLv1FCUwuAK4xXqKEigVt3RMABHxFvCENRUlUApWR8TmTnYAAEusqyiBUrDdWd0RAdxsXUUJlIJ/7bgAIuKX1lWUQP5ExNJudAAAP8frAkQJ5MoI8LMd+YMdFcBivC5AlECu1IqMdk0Ai6yxKIGsWdQ1AUTEJmCFywBRAlm2//dHxHA3OwCAhS4DRAlk2f4v3NE/akUAP7DWogSy5LquCyAifgvc6zJAlEBW7f+vimx2vQMAuMZlgCiBrNr/a1r5w5YEEBHXW3NRAvkQET/smQAKfuwyQJRAFu3/Ta3+cTsCuNJlgCiBLNr/K3sugIi4F1hnFyBKoK+z/9qIWN5zARRcYRcgSqCvs/+32nmDtgQQEVc5DEUJ9I92MzjUgW241mEoSqAv
fL/dN+iEAL7qEBQl0Bcu67sAIuI54Be4M1CUQK8YAW4pstf3DgDgS7gzUJRAr6gBX+zEG3VEABFxH80nkdgFiBLo/uy/MiJWZCOAggvsAkQJ9GT2v6BTb9YxAUTEnUDDLkCUQFdn/0Ynb9A71OENPN8uQJRAV2f/8zv5hh0VQHE74pV2AaIEujL7r9iRW373owMAmG8XIEqgK7P/vE6/accFEBEPA/9uFyBKoKOz/5KIWJW9AAoW2AWIEujo7L+gG2/cFQFExIvAdxxuogQ6wpUR8VJpBFBI4CJgk0sBUQJttf6bIuLibn3AUJe/wDyXAqIE2mr9z+vmB3RVABFxI3C/XYDkLoExY8bkOPvfFxGLu/khY3vwRc4EnsupssPDw45865B7J1ArstP1D+k6KaWvAF/Loqq1GiMjNiTWI/tafCUivl4JARQSeBrY330CItts/Z+JiA/14sOGevjF5hp+ke2alOf26sN6tuej0WhsqNfrm4GP+RuLjNr639xL2/SUlFIDmGY3IPIHrf9jEXFoLz90qA9fdE4Rfvc8ibwd/lqRDSotgIjYACQ7AJF3dOJnRcSrvf7gvpz90Gg0HqvX638CzPC3F+H6iPhmv8zTN1JK/w0cYDcgA9z6Px0RB/ZrA4b6XIAjtyiEyKCFf8sMDJ4AIuJl4KO4U1AGL/w14KMR8Uo/N6TvV0A0Go019Xr9NeBUx4UMCDXg4m5f6FMKARQSuKder08FDnNsyACwqJvX+O+oibIhpbQSOMLxIRXmgYiYlVMrQmYSeA7YB48MSPXW/Wsj
Yr+cNmoow0JNA97EnYJSrfC/CUzNbcOyE0BEbAQOAjYrAalI+EeAD0fEawpg+yTwPFDHw4NS/vDXgGkRsTbHDRzKtXIR8QQwUwlIycM/MyKezHUjh3KuYEQ8BMxWAlLS8B9djOFsKcWe9pTS0cDyLQorUobw35/7xpYmTCmlmcADSkBKEP4jIuLBMmxwqYKUUpoKNIrtVgKSW/g3A4dGxOqybHTpQpRS2gf4NTBeCUhG4X8DmFIcwSoNQ2WrdHE4ZW9greNOMgn/88DEsoW/lB3Au7oBrx2QfpPVuf2V7wDe1Q3MAhZtYWKRXs36ADeUOfyQyeXA7dBoNH66xf0EPEIgvQh/DbgoIi4p+5epTFhSSscCS6v2vSTLmf+4iLi7Cl+oUkFJKe0BrAA+5FiVLvAb4Mji1vYogHxFsBA4zyWBdLDlXxgR86v25SobjpTSp4GfKAHpQPjPioifVvELVjoYKaXdgWXAIY5laYEGMKcfT+xRAJ0VwZeAr9sNyA7M+l+OiH+q+pcdmDCklA4E/hP4oGNcRuFpYG5E/NcgfNmBmw1TSl8G/tFuQAZ11h9oARQS2Be4GThKERh84D7gU2U8l18BtCeCc4DrgfeZhYFkE/BXEXHToBbAma8pgiuAS+wGBmrW/1ZEXDroxXCwvy2BCcC1wBmKoNLBvxn4bESstyQO8q2JYDqwkOZjmxVBdYK/AjgvIh61JApge0QwB/gecKgiKHXwHwXOj4hllkQBtCKC44GrgFmKoFTBXwlcEBG/tCQKoBMiOBL4BvBxq5E1Pwe+GBEr
LYUC6IYI9gG+Bnz2XTOO9G+2B/g+8A+5PoJLAVRTBhcAFwP7KoK+BH8tcEVEXG1JFEA/RXA0cBFwjl1BT2b7xcC3y/DkHQUweDL4S+BvgI8og46G/m7gmoj4kWVRAGUQwc7AAmA+zXMKlMGOh34FcB1wbUS8aWkUQFllsBNwbrFE+IQVGZX/AG4CFkXEsOVQAFUUwnHAp4DTgakDXo7VwBLgXzxZRwEMogyGgFOAucDJNE84okJLhnd/h5XArcDtwC8iYrOjQAHIO6UwneZOxGOB2UB9G6HKMejQvKfecpo78O6JiFX+ugpAWpPCJGAGMJ3m9QlTgGnAhD5v2nrgceBJmufdrwIeioh1/moKQHojh/cDBwL70zwpaRLNJyjvAexevHYFdqF585Odildti9l7uHhtAl4HNgKvAhuAV4AXgXU0n4S7BvhNRGy0+iIiIiIiIiIiIiIiIjnyf9eV8VcbpfPFAAAAAElFTkSuQmCC";
    const DEFAULT_APPLICATION_LOGO_DARK = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAE2tJREFUeNrtnX2wVdV5h59zUIJBYxEECxejiXx4hFxEoAQYg6gxzZho44oypBmR/pF0ptNGUTPTxql2Os2MxmD+SjITFTOBCeaNiY2dtCqxWC/yIV8KBzHWVL4DCLRoFEy5/WOvq6c3cu+5++xzzlp7/56ZOw6jePd+93qf9b5rr703CCGEEEIIIYQQQgghhBAin5QUgvhxzg0HOvzPaOA8YCRwDjDM/5wJDAXOAAYDp9Vc/27g98AJ4G3gLeAYcBQ4AhwGDgD7gb3AbmCXmR1W9CUA0Zykxsxq/zwWmOx/KsBE4OPA8DYf6hvAfwIvA1XgJeAlM9t1qnMREoDoO9k/AcwBZvifi3v9le4Ar90HHdN2YJ3/ec7MXpQUJAAlfM3gd86dBlwDXAVc6Wf4kBO9UTG8BKwEngaeNLN3JQQJoGhJPxe4DrgWuKjgoXkVeAJ43Mz+XTKQAPKY/B8GFgA3+ZlenJqngR8Dy83sbYVDAog16T8CLAJuBqbkqKRvZcuwCfgh8KCZHVNoJICgy3vnHMBfAF8FpinpM5XBC8D3zOxBtQkSQGgCmA3cBnxBSd8SGfwUWGJmXQqLBNCu2b4ELAbuINl0o6RvvQwOAPcC3zazblUFA6esENSf+J6xzrmHgJPAfcC5kmnbJq5zgW8BJ/01GdvrWgkJILPEn+GcWwnsBG5RFRVcBXsLsNNfoxkSgQSQVeLPc85tAdYCVygywXMFsNZf
s3kSgQSQNvHnOue2k+xam6zZPrqqYDKw0l/DuRKBBFBv4k9xzm0CngEmKPGjF8EE4Bl/TadIBBLAqRJ/lHPulySbTzqV+LkTQSewyV/jURKBBnitBL4D/DW6lVcEeq7xd8zsaxJAQWd9fy//S8DDwOnKi0JyAlhkZsuKuoegqAIYQ/IE2hTN+qoGfNv3OTPbozWAnPf6zrl7SF5ppT5f9Fz7KcBu59zdRVsbKBVIAONJbul1aNyLPtgNXGlmr6gCyM+sfzewAxij8S36YQywoyjVQCnnAhgOdPH+/XwhBsIOYFae335czmHS9/zzRuAQMF7jWKRkPPCGH0u5rAbKeUt+f3tvGbACrfCLxivkbmCFc25ZzUtf1AIEKoARJLd0tNAnmsEuYKqZHVIFEF7yXw4cRAt9onl0AAf9WJMAAur3vw6sUskvWtQSrHLO3ZmHdYFSzMnve7JHgS9qbIo28BMzuzHmbcSlWJPfH/sW/v+XdIRoNS/it5THKIFSpMl/Nsk92pEq+UWb6QZ+S7LX5H9ik0ApwuTvAF4Bhij5RUASeAcYB+yJSQKxLQJWSF7KqeQXoU2kQ0huE14c04FHIwDn3GXAtlhbF1EICQBUnXNTJYBsk38myaehdJtPhC6BbmCDc+5PtAaQXfI/r+QXka0JlICZZrZWAmis7NfML2KWwDQz2yABDCzxIVnw26bkFzmQQAXYHuLdgVKgyd9BstqPkl/kQAIA5wO7Q5NAKcDk/wjJxooPKflFjiRwnOR7BEFtFioHlvwlkh1+Sn6RJ0p+TO8ASiE9
QFQOJfm9FTd5Syr5RR4lMArYFNKLRYJJNOfcCuBGjRNRAFaY2fwQDmRQIMn/deBvNC5EQZhUqVR+V61WVxe+AvBvV1mlMSEKyOVm9h+FFIDvgUaQvMZL9/pF0egZ8yOAN9p1Z6DcruT3J7xByS8KSs9zAxvbuSjYzgpgGbBA40AIlpnZn7fjFw9qU/LfBNyj6y4EAJ+oVCrbq9XqtlxXAL7MGU7yxR6V/kK0eT2gpWsA/sRWK/mF+MD1gK5WLwa2tAXwX1y9QckvxAdKYESlUqFara5q5S9tVek/juRlnkKIvhkHvNqKaqBlM7FzbifJY76a/YXoez1gt5mdn5sWwJf+nw8k+bX+oFiEHI8ScHarWoFSkxMfP+vvCuxCrwZmabwDMBHYrzBwDvBaYMfUQZO/M9B02znnNgGdgc00Q4GfA1dr3DPazPYVPQjOuZ7b0yFVI5vNrKmvGC83OagLSL6bFlqZeYaZfRp4SvkvAqUEXOpzKC4B1OxrXsr770QLzfhIAiKCNYmlvXIqfAH4hxseAE4n0EWmngcwJAEReBVwunNuSbPWATIXgHMO59woInjBhyQgIuFrzrlRzagCys1IKuDhUEt/SUBE2go81IwqIFMB+Nm/E/hTIrq/LAmICFqBzzrnOrOuAspZJ1JMs78kIIpeBWQmAD/7Xw5cSqS7yyQBEXgVMNU5d3mWVUA5y+QBvh/j7C8JiIiqgO9lWQVkIgA/+19Bsq00+r3lkoAIuAq42Dk3N6sqoJxVwgBLYp/9JQERSRXwQFZVQMMC8LP/DMLb7y8J
iLxWAZ3OuRlZVAHlLJIE+GaeZn9JQERQBfxTFlVAQwLws/9YYB45fq5cEhABVgFXOuc6Gq0Cyo0mBnB3ESIuCYgAuafRKqDRCqAELCpKtCUBERiL2loBALcVLeKSgAiMxe0UwJ3kdPFPEhAR0A3c0XIB+MW/TwIjKehLJSUBEQAlYJRzbmbaVqCcdvD78r+7yNGXBEQgVcBtaRcDG2kBHHqltCQgQqgCvtiyFsCX/7co7pKACAfn3MI0bUA5zWAHvlr08l8SEIG1AX+Zpg1IUwGcCcxQ+S8JiKDagBnOuaGtWANYpHhLAiJIFrVCAAtV/ksCIsg2YGFTBeCcG0LEr/ySBETO24CpPkezF4BfYVygOEsCImgWDORuQHkggxmYr/JfEhBBtwE3DuRuwEDXAK5W+S8JiKDbgGsybwH85p+5iq8kIMJnIK8OL9c7eIHPK7SSgIiC6+ptAwbSAnxOcZUERBRcm3ULcBpwkeIqCYgoGO+cG5SJAHwvcbViKgmIqPh0PesA5XoGKnCV4ikJiKiYV886QL1rAFcqnpKAiIq6Ju16BdCpeEoCIiqmZLUGcIliKQmI+HDOTW5IAH4RYY5CKQmIKJnd30Jgub8BCcxE+/8lAREb3cDM/hYC61kDmIb2/0sCIjZKwPSG1wCASYqlJCCipNLoGsAYxVASEPHinBvdSAWg23+SgIibzkYEoFuAkoCIm0mNCKCC7gBIAiJWuvtbB+hPABPRHQBJQMRKCZjQiADGKYaSgIiacY0IYLjiJwmIqBmRSgDOuWGKnSQg4sc590dp
KoDzFTpJQOSCj6YRQIfiJgmIXNCRRgDaBSgJiHwwOo0ARilukoDIBaPSCGCk4iYJiOjp7iuX+xKAbgFKAiJ+Sn3lcl8C0G1ASUDkg2FpBHC24iYJiFyQah/AWYqbJCBywZlpBDBUcZMERC4YmkYAQxQ3SUDkgjPSCGCw4iYJiFwwOI0ATlfcJAGRC05LI4Cy4pZ7CXQB79bzFVkRNWUlufgDCQB/Bvyi5s9CZniPkwpPviXgS8OZzrmVkkCuOZlGAO8qboVhniSQa36fRgAnFDdJQOSCE2kE8I7iJgmIXPB2GgG8pbhJAiIXvJVGAMcUN0lAEsgFb6YRwH8rbpKAJJALjqYRwBHFTRKQBHLBkTQCeENxE5JA9HT3lct9CeCAYickgegp9ZXLfQlgv2InJIFcsD+NAPYqbkISyAX70ghgt+ImJIFcsCuNAHYqbkISyAU7BywAM9NtQCEJ5AAzS7UPAOCQwickgag52Ne/7E8Av1b8hCQQNa82IoAdJBsJhJAE4qMbeLkRAVRJNhIIIQnER8nncGoBbFUMhSQQNVsbEcAWxU9IAlGzJbUAzEy7AYUkEDFmtq+RCkBtgJAE4qXa339QjwDWozsBQhKIjW5gXUMC8BdtDboTICSB2CgBa/qLeX9rAJB8PkoISSA+unwOp28BzGyb4igkgfgws37X7+r9NuBmhVNIAlGxqZ7/qF4BPK14CkkgKlZmIgB/kX6leApJIC4B1BPbetYAAJ5UPIUkEBVP9rcAWHcLYGb/C7yimApJIAp2mNnJLNcAAJ5QXIUkEAV1
52pdAvAX5nHFVUgCUfDzeuNYbwuAmT2ruApJIHzM7Ll6+v+BtgAA/4aeCxCSQKh0A/86kL9QtwD8BVmBngsQkkColIAVA4lb3QLwJcVyxVhIAkGzvN7yf8AtgJkdBzaoDRCSQJDl/wtmdqIpLUANS9UGCEkgyPJ/6UD/UhoBPKRYC0kgSB5uugDM7HfAWrUBQhIIqvxf43OzuQLwF+C7agOEJBBU+f/dNHFJUwFgZo8o5kISCAcz++FAVv8bWQPo4SdqA4QkEET5/2jav5xKAD7w96sNEJJAEOX//WnjkEoAvg1YC+xXFSAkgbbO/vvMbF2a8r/RFgDgXlUBQhJo6+x/XyP/g0YFsERjUEgCbWVJ2wTgy44HNQaFJNAWfpC29M9EAD7Yf6/xJySBtnB3o+facAVgZnuAp9BioJAEWkU3yUs/97S1AqipAv4OLQYKSaBVlIC/zeL8GhaArwLWk3yJRFWAkASaP/tvNLMNjc7+mQigpgq4VVWAkARaMvvfmtU5ZSIAXwWsAqqqAoQk0NTZv2pmz2Yx+2cmgJoq4CuqAoQk0NTZ/ytZnkdmAvBVwHPARlUBQhJoyuy/YSCv/G6pAGqqgFtUBQhJoCmz/8Ksjz1TAfgq4EXgX1QFCEkg09n/CTPbmuXsn7kAaqqARaoChCSQ6ey/qBnHm7kAfBVwAPi2xpqQBDLhfjM7mPXs3xQB9FQBZrYYOK5WQEgCDZX+x83s9mYdY1MEUGOqhWoFRAwSCLj0v7lXToUvgBoR/Bh4QVWACF0CwDsBzv7rzWxFsw3TNHzZ
MhrYE1hwxwNHNPYZBWxVGABYA8wM7JhGk7zyK04B1IjgLuAfAjKr2hLFI/RY3GVm/9iKHoMWSeB1YKwGmxD9SminmV3Qil9WblHyA8xT8gtR16Q8r1V3JlqakIG1AkKESEtK/7YIwEugCkxUNSDEH5T+283sklaXG61MfoBhwGG0+CREbfKXfG4cbeW+hLYkoHPuBsB03YV4jxvM7LFW/9JB7TjTarW6vVKpfAzo1HUXgkfM7Jvt+MXldvxS/6zAzcDraJegKHbp/19mtrBdzyO0rQf3JzwcONjuYxGiTckPMAI43K7nEdqedM652cBzaFFQFCv5S8AcM+tq54EManckqtXqrkql8iZwjcaFKAgl4PZmP+gThQC8BJ6vVCoTgMkaG6IALDez20M4kHIIB+EXBReQfF1IiDyzycy+FMpLSILpuWsCsgf4Y60HiBz2/fuAMdC8F3xEK4AaCZwF/BYYIgmIHCX/O8BI4M2Q3kBUDilKPjDHgIuAk2iPgMhH8ncDHw8t+YMTQI0E9gIVXwFIAiLm5C+RPPy2L8R3DwZdYjvnOoHNaI+AiDf5p5jZllAPshxyBH3gZqgSEJEm//SQkz/4CqCmEpgOrFMlICJL/hdCP9hoksk5N4Vkn4AkIEJP/kvNbHMMBxxVIjnnJgBVf9ySgAgt+U8Cl5jZjlgOuhxZkHcAHST3VLUmIEJK/reB8/0YRQJoAv42yj6SDRX7NO5EIMm/l+QjK3sD/sxYLiqAHgm8aWZj0LMDov1sNrMOAtzkk0sB9EjAP0A0FVheY2IhWjXr
Aywzs6l+LEZ5IoNivQLVarVHAo/VvE9AdwhEK5K/BCw2sztiTn7ylCzOuVkkbxZCEhBNnvnnmNnqPJxQrhLFOXcOsAG4QGNVNIHfAJeZWW6+LF3O2QU6bGYXAo9oXUBkPOsvNbOPkbPPyueuVO7pyZxzXwB+qnUBkUG/f4OZPRZ7v18IAfSSwTCgC7hYY1mkoArMNrOjeT3Bcs4v4BEzqwDfUEsgBljyf8N/qPNonk+2MKWxc+5C4Bngoxrjog9eB+aZ2WtFONlygS7sb8zsAuAuVQOij1n/AuC1opx4IRfHnHOjgceBaWiRsOiJXwLWA9eb2d6iBaBc0Au/18ymA/OBE8qDwnICuMnMZpA80FM4NPMlFcG9wB2qBgo1699nZncWPRhlJb/DD4RzgV9ofSD3ff4/A+ea2Z2hfJ1HAmgjNRs7DpnZdSTfJ9woEeQu8TcCk8zseuBQr2svAUgE7w2GrWY2DZhDshFEIog78askD+9MA7Yp8SWAekXQZWaTgE/x/otHJIJ4En8T8Cl/DbuU+BJAWhE8a2aXkdwyfEqRCZ4nSZ7Yuwx4VokvAWQlgg1mdg0wGvjBB8w4on2zPf6ajDazz/h+X4lfB7rlNUBqnwhzzt0K3O6loFuIrU38EsmLYe81swd6XxshAbRSCtOBxcBNvQaoyD7pAVYA34rhyztqAYrBejObb2Yl4MvAGrUImZf4zwNfNrOSmc0HlPwSQHDrBAA/MrNZwIeBv+L9PQWSwcCTfqOP4RlmNhv40SliLtQCBN0iDAYW+BbhM4pIn/wSeBRY
bmZ6TkMCyI0EahcP5wDXA9cCEwoemh3AE8DPzKyrd6yEBJB3GZSBq4F5wFXA1F7lcOzXqPc5bASeBn4FPGVmJ5X0EoCEUDP4nXOTgE8Cs4AZQKWfpAox0SHZhrsOWA08b2ZbT3XOQgIQfUvhPKATmARcAowDJgIj2nyoh4CXgV+T7LXfCmwxs/1KdglAtEYWZwEXAmNJNiWdR/IF5XOAYf7nTGAo8CFgsP8p1czeJ/zPceAt4BjJCzGPAIeBA8B+khdn7CJ5xdoxRV8IIYQQQgghhBBCCCGEECJE/g/who0GrHrV5gAAAABJRU5ErkJggg==";
    const DEFAULT_APPLICATION_LOGO_LIGHT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAEz5JREFUeNrtnX2wVdV5h59zqgaDJkVQLFyMNvIhYkFESoAxiBrTjqk29hWLyYj0j6QznTZ+ZqaNE9PptDMag/kr6Uz8nMCIb01jYyetSqxWVFRAFFGMNZXvKIItWhVTbv/Y6+Lpjdx7zj77nLPW3r9n5o4yguz97vU+633XXntvEEIIIYQQQgghhBBCCCFEOakpBOnj7qOBvvAzDjgeOA44BhgVfo4CRgJHAkcAhzVc/37gV8B+4F3gHWAf8BawF9gDvA7sAnYA24CtZrZH0ZcARGeSGjNr/PUE4LTwMxWYAnwaGN3jQ30T+A/gJWAT8DzwvJltPdS5CAlADJ3svwPMB2aHn1MG/ZH+CK/dRx3Ti8BT4ecxM3tOUpAAlPANg9/dDwPOB84FzgkzfMyJ3q4YngdWAQ8BD5jZBxKCBFC1pF8AXAhcAJxc8dC8AtwP3Gdm/yYZSABlTP6PA4uBRWGmF4fmIeBuYIWZvatwSACpJv0ngKXA5cCMEpX03WwZ1gN3Abea2T6FRgKIurx3d4A/Ab4KzFLSFyqDZ4Dvm9mtahMkgNgEMA+4Cviikr4rMrgXWGZmqxUWCaBXs30NuBq4lmzTjZK++zJ4HbgR+I6Z9asqaJ26QtB84gcmuPttwAHgJuBYybRnE9exwLeBA+GaTBh0rYQEUFjiz3b3VcAW4ApVUdFVsFcAW8I1mi0RSABFJf5Cd98ArAHOVmSi52xgTbhmCyUC
CSBv4i9w9xfJdq2dptk+uargNGBVuIYLJAIJoNnEn+Hu64GHgclK/ORFMBl4OFzTGRKBBHCoxB/r7j8l23wyXYlfOhFMB9aHazxWItAAb5TAd4E/R7fyqsDANf6umX1NAqjorB/u5V8G3A4crryoJPuBpWa2vKp7CKoqgPFkT6DN0KyvaiC0fV8ws+1aAyh5r+/u3yJ7pZX6fDFw7WcA29z9hqqtDdQqJIBJZLf0+jTuxRBsA84xs5dVAZRn1r8B2AyM1/gWwzAe2FyVaqBWcgGMBlbz4f18IVphMzC3zG8/rpcw6Qf+eQmwG5ikcSxyMgl4M4ylUlYD9bIlf7i9txxYiVb4RfsVcj+w0t2XN7z0RS1ApAIYQ3ZLRwt9ohNsBWaa2W5VAPEl/1nAG2ihT3SOPuCNMNYkgIj6/a8Dj6jkF11qCR5x9+vKsC5QSzn5Q092D6D3QImeDEMzuyTlbcS1VJM/HPsG/v+XdIToNs8RtpSnKIFaosn/SbJ7tMep5Bc9ph/4Jdlek/9OTQK1BJO/D3gZGKHkFxFJ4D1gIrA9JQmktgg4leylnEp+EdtEOoLsNuEpKR14MgJw9zOAF1JtXUQlJACwyd1nSgDFJv8csk9D6TafiF0C/cBad/9drQEUl/xPKPlFYmsCNWCOma2RANor+zXzi5QlMMvM1koArSU+ZAt+Lyj5RQkkMBV4Mca7A7VIk7+PbLUfJb8ogQQATgC2xSaBWoTJ/wmyjRUfU/KLEkngfbLvEUS1WageWfLXyHb4KflFmaiFMb0ZqMX0AFE9luQP
VlwfLKnkF2WUwFhgfUwvFokm0dx9JXCJxomoACvN7FJVAB8m/9eV/KJCLHL3a1UBcPBNPo9oTIgKcpaZ/XslBRB6oDFkr/HSvX5RNQbG/BjgzV7dGaj3KvnDCa9V8ouKMvDcwLpeLgr2sgJYDizWOBCC5Wb2pcoIwN0XAXfrugtxkEVmdk+pBRDKnNFkX+xR6S9Ej9cDuroGEE7scSW/EB+5HrC624uBXRVA+OLqJCW/EB8pgcnu/s3StQCh9J9I9jJPIcTQTARe6UY10LWZ2N23kD3mq9lfiKHXA7aZ2QmlaQFC6T8hkuTv1xhTLCKORw2Y0K1WoNbhxCfM+lsju9CPA3M13gGYAuxSGDgGeDWyY+qjw98Z6PiM7O7rgemRlf4jgR8D52ncM87MdlY9CO4+cHs6pmrkWTPr6CvG6x0O6mKy76bF1vcfaWafAx5U/otIqQGnhxxKSwAN+5rviLXPDM8jSAIi9jWJOwblVPwCCA833AIcTqSr/gMPYEgCIvIq4HB3X9apdYDCBeDuuPtY4C9ij64kIBLha+4+thNVQL0TSQXcTiK3mCQBkUgrcFsnqoBCBRBm/+nA75HQhh9JQCTQCvy+u08vugqoF51IKc3+koCoehVQmADC7H8WcDqJbveVBETkVcBMdz+ryCqgXmTyAH9P4ttLJQEReRXw/SKrgEIEEGb/s8m2lSb/sI8kICKuAk5x9wVFVQH1ohIGWEaJHi6RBETEVcAtRVUBbQsgzP6ziW+/vyQgyloFTHf32UVUAfUikgT4O0r6aKkkICKtAv62
iCqgLQGE2X8CsJASv+hDEhARVgHnuHtfu1VAvd3EAG6oQsQlAREh32q3Cmi3AqgBS6sSbUlARMbSnlYAwFVVi7gkICLj6l4K4Doq+F45SUBEQj9wbdcFEBb/PgMcR0Xf8isJiAioAWPdfU7eVqCed/CH8r/Sb5WVBEQkVcBVeRcD22kB/gi9418SEDFUAblvBbQsgFD+X6G4SwIiHtx9SZ42oJ5nsANfRR+VkARETG3An+ZpA/JUAEcBs1X+SwIiqjZgtruP7MYawFLFWxIQUbK0GwJYovJfEhBRtgFLOioAdx9Bwq/8kgREyduAmSFHixdAWGFcrDhLAiJqFrdyN6DeymAGLlX5LwmIqNuAS1q5G9DqGsB5Kv8lARF1G3B+4S1A2PyzQPGVBET8tPLq8Hqzgxf4A4VWEhBJcGGzbUArLcAXFFdJQCTBBUW3AIcBJyuukoBIgknu/huFCCD0EucpppKASIrPNbMOUG9moALnKp6SgEiKhc2sAzS7BnCO4ikJiKRoatJuVgDTFU9JQCTFjKLWAE5VLCUBkR7uflpbAgiLCPMVSklAJMm84RYC68MNSGAO2v8vCYjU6AfmDLcQ2MwawCy0/18SEKlRA85sew0AmKZYSgIiSaa2uwYwXjGUBES6uPu4dioA3f6TBETaTG9HALoFKAmItJnWjgCmojsAkoBIlf7h1gGGE8AUdAdAEhCpUgMmtyOAiYqhJCCSZmI7Ahit+EkCImnG5BKAu49S7CQBkT7u/pt5KoATFDpJQJSCT+URQJ/iJgmIUtCXRwDaBSgJ
iHIwLo8AxipukoAoBWPzCOA4xU0SEMnTP1QuDyUA3QKUBET61IbK5aEEoNuAkoAoB6PyCOCTipskIEpBrn0ARytukoAoBUflEcBIxU0SEKVgZB4BjFDcJAFRCo7MI4AjFDdJQJSCI/II4HDFTRIQpeCwPAKoK26ll8Bq4INmviIrkqauJBe/JgHgD4GfNPxayAwHOaDwlFsCoTSc4+6rJIFScyCPAD5Q3CrDQkmg1PwqjwD2K26SgCgF+/MI4D3FTRIQpeDdPAJ4R3GTBEQpeCePAPYpbpKAJFAK3s4jgP9S3CQBSaAUvJVHAHsVN0lAEigFe/MI4E3FTUgCydM/VC4PJYDXFTshCSRPbahcHkoAuxQ7IQmUgl15BLBDcROSQCnYmUcA2xQ3IQmUgq15BLBFcROSQCnY0rIAzEy3AYUkUALMLNc+AIDdCp+QBJLmjaH+43AC+LniJySBpHmlHQFsJttIIIQkkB79wEvtCGAT2UYCISSB9KiFHM4tgI2KoZAEkmZjOwLYoPgJSSBpNuQWgJlpN6CQBBLGzHa2UwGoDRCSQLpsGu43NCOAp9GdACEJpEY/8FRbAggX7Ul0J0BIAqlRA54cLubDrQFA9vkoISSB9Fgdcjh/C2BmLyiOQhJIDzMbdv2u2W8DPqtwCkkgKdY385uaFcBDiqeQBJJiVSECCBfpZ4qnkATSEkAzsW1mDQDgAcVTSAJJ8cBwC4BNtwBm9r/Ay4qpkASSYLOZHShyDQDgfsVVSAJJ0HSuNiWAcGHuU1yFJJAEP242js22AJjZo4qr
kATix8wea6b/b7UFAPhX9FyAkARipR/4l1b+QNMCCBdkJXouQEgCsVIDVrYSt6YFEEqKFYqxkASiZkWz5X/LLYCZvQ+sVRsgJIEoy/9nzGx/R1qABu5QGyAkgSjL/zta/UN5BHCbYi0kgSi5veMCMLP/AdaoDRCSQFTl/5MhNzsrgHABvqc2QEgCUZX/38sTlzwVAGZ2p2IuJIF4MLO7Wln9b2cN4GAxoDZASAJRlP/35P3DuQQQAn+z2gAhCURR/t+cNw65BBDagDXALlUBQhLo6ey/08yeylP+t9sCANyoKkBIAj2d/W9q53/QrgCWaQwKSaCnLOuZAELZcavGoJAEesIP8pb+hQggBPubGn9CEugJN7R7rm1XAGa2HXgQLQYKSaBb9JO99HN7TyuAhirgr9BioJAEukUN+Msizq9tAYQq4GmyL5GoChCSQOdn/3Vmtrbd2b8QATRUAVeqChCSQFdm/yuLOqdCBBCqgEeATaoChCTQ0dl/k5k9WsTsX5gAGqqAr6gKEJJAR2f/rxR5HoUJIFQBjwHrVAUISaAjs//aVl753VUBNFQBV6gKEJJAR2b/JUUfe6ECCFXAc8A/qwoQkkChs//9ZraxyNm/cAE0VAFLVQUISaDQ2X9pJ463cAGEKuB14Dsaa0ISKISbzeyNomf/jghgoAows6uB99UKCEmgrdL/fTO7plPH2BEBNJhqiVoBkYIEIi79Lx+UU/ELoEEEdwPPqAoQsUsAeC/C2f9pM1vZacN0jFC2jAO2RxbcScBejX3GAhsVBgCeBOZEdkzj
yF75laYAGkRwPfDXEZlVbYniEXssrjezv+lGj0GXJPAaMEGDTYhhJbTFzE7sxl9W71LyAyxU8gvR1KS8sFt3JrqakJG1AkLESFdK/54IIEhgEzBF1YAQv1b6v2hmp3a73Ohm8gOMAvagxSchGpO/FnLjrW7uS+hJArr7xcA/6LoLcZCLzexH3f5L6704UzO7F7hL11wIAO7sRfL3TADhWYHLgdfQLkFR7dL/P81sSa+eR+hZDx5OeDTwRq+PRYgeJT/AGGBPr55H6HnSufs84DG0KCiqlfw1YL6Zre7lgdR7HYkQgGuU/KJC1IBrep38UZXd7r4C+GONDVEBVpjZZTEcSD2S5MfMFpN9XUiIMrPezC6L5SUkMVUAA/+6HfgttQSihH3/TmB8aH0lgENI4Gjgl8AISUCUKPnfA44D3o7pDUT1mKIUArMPOBk4gPYIiHIkfz/w6diSPzoBNEhgBzA1VACSgEg5+WtkD7/tjPHdg1GX2O4+HXgW7REQ6Sb/DDPbEOtB1mOOYAjcbFUCItHkPzPm5I++AmioBM4EnlIlIBJL/mdiP9hkksndZ5DtE5AEROzJf7qZPZvCASeVSO4+GdgUjlsSELEl/wHgVDPbnMpB1xML8magj+yeqtYEREzJ/y5wQhijSAAdINxG2Um2oWKnxp2IJPl3kH1kZUfEnxkrRQUwIIG3zWw8enZA9J5nzayPCDf5lFIAAxIIDxDNBFY0mFiIbs36AMvNbGYYi0meSD3VK9Aggcv48H0CkoDoRvLXgKvN7EspJz+UaCXd3eeSvVmo
VOclopz555vZ42U4oVIlirsfA6wFTtRYFR3gF8AZZlaaL0vXS3aB9pjZScCdWhcQBc/6d5jZb1Oyz8qXrlQe6Mnc/YvAvWjnoGi/37/YzH6Uer9fCQEMksEoYDVwisayyMEmYJ6ZvVXWE6yX/ALuNbOpwDfUEogWS/5vhA91vlXmk61MaezuJwEPA5/SGBdD8Bqw0MxercLJ1it0YX9hZicC16saEEPM+icCr1blxCu5OObu44D7gFlokbDqiV8DngYuMrMdVQtAvaIXfoeZnQlcCuxXHlSW/cAiM5tN9kBP5dDMl1UENwLXqhqo1Kx/k5ldV/Vg1JX8ThgIxwI/0fpA6fv8fwKONbPrYvk6jwTQQxo2duw2swuB04B1EkHpEn8dMM3MLgJ2D7r2EoBEcHAwbDSzWcB8so0gEkHaib+J7OGdWcALSnwJoFkRrDazacBn+fDFIxJBOom/HvhsuIarlfgSQF4RPGpmZ5DdMnxQkYmeB8ie2DsDeFSJLwEUJYK1ZnY+MA74wUfMOKJ3sz3hmowzs8+Hfl+J3wS65dUijU+EufuVZG8jGoduIXY78WtkL4a90cxuGXxthATQTSmcCVwNLBo0QEXxSQ+wEvh2Cl/eUQtQDZ42s0vNrAZ8GXhSLULhJf4TwJfNrGZmlwJKfgkgunUCgB+a2Vzg48Cf8eGeAsmg9aRfF2J4pJnNA354iJgLtQBRtwhHAItDi/B5RWRIfgrcA6wwMz2nIQGURgKNi4fzgYuAC4DJFQ/NZuB+4B/NbPXgWAkJoOwyqAPnAQuBc4GZ
g8rh1K/R4HNYBzwE/Ax40MwOKOklAAmhYfC7+zTgM8BcYDYwdZikijHRIduG+xTwOPCEmW081DkLCUAMLYXjgenANOBUYCIwBRjT40PdDbwE/Jxsr/1GYIOZ7VKySwCiO7I4GjgJmEC2Kel4si8oHwOMCj9HASOBjwFHhJ9aw+y9P/y8D7wD7CN7IeZeYA/wOrCL7MUZW8lesbZP0RdCCCGEEEIIIYQQQgghhIiR/wMLunxvKj8tigAAAABJRU5ErkJggg==";
    const DEFAULT_APPLICATION_LOGO_LINK = 'a=0';
    const DEFAULT_BOOTSTRAP_LOGO = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAQAAAAAYLlVAAADkElEQVRo3u2ZT0hUQRzHP9sGgoEh0T8kL8/Ag+tBsUNdCpmKjA7VQdzKwg6pdIoOnkQKPHgUtUOGSrt0qIUORTGIXepgZAc9eJCFMgmUEj0IQotdlJ03b1779u2IK/k7vTfvN/P7zm9+8/v3YI/+d4oEZxUHaaaBCZJyw4cjQgvn+MwLuWIZgKijg9tEgTl6SJggiAhxuqkCMowwKKesARDPiSuvRgiK+C1KyBu2AOj7XWSaKJUcphRYY4nvZIhxxM0mI9sFICAFAbBvp2/BbgAg2sIuHmRmNOcigzwKvb0rztH0mwKMUJSQ4pLhwxTjTDLLAqtAGRVUc4pG6gy8b7kq10MBECW846w2uMYAY3LGZ0YNt+ikVBv+wEV/CP8C8Maz+z565XKOIyuni4e6FmRT3gDEIO2a2u/LTwGN7zT92nEMyY68jFC0aaaXpEl+C2p76XnnGVXElKEG50f6a04NaD4/S09ke4hLOMQ94wdXjIi4It4X44SkjIf0AwlajB/qs5FSdUTmU5qiNbQfaMUckjsMGhAH+WW0iDNBTc/HHD8ahjMc2kpZshpoNorvK0Q8yE/0GU2/2XsEDQbGNXoLjja9rBlGG7wAJpjzsA3kcjsBdLDMgGdwjgkvgCQ9HghjViLumEd8D0mzH7jGS9X+Zb2dmC++KH5xkQdqRunOB1KMK2/j1rIOdaVpd0LrAiA3XDdh0hoAdaWoO5/WM6JK5XnWGoBZHwkGAIeV5wVrABZ8JBgAqMnEqjUAqz4SijErVr1WmTUpZT4SDACWlOcKawAqfCQYAHxXnqutAaj2kaADEBEyyuspawDUlTIi4gNARIi78rhGawDUlWLEVQhRrb4/obAed16lFy1EghpXgnuAWn4702m
PBlq09gLALSv711epojubK2YBxD3ioVOUF7z/cjo9g1Wc8wJ4bZhdSlfB++/ylGoAn4svKZUrjBjX6Bf7Q4vfT7/xw0i2jaf6gUEjcx2joRUwaizYXZIUpad/OiepNbDHnGO52gw+pdkdn9JsIGd1LNp4qhWnrfJPXsof1cqyu3I4j+o4/dU56qoUYlx2ZtLzgU0vxXmtPH+82xoURdCi2fEmlU+rJj/ybc0EBmC4EcHJx/LzBLDXrN5eChto3lOi/bBY58L2AUho7bvr8pXBUtzFPSSsHYG8QT3DmxnzHDdJGdlS3NxscWQYpj7IH6Mi+G23R3v0FwbfFx3mQ2ZaAAAAAElFTkSuQmCC';
    const DEFAULT_BOOTSTRAP_LOGO_LINK = 'a=0';

    // Les commandes.
    /**
     * La commande de sélection du mode.
     *
     * @var string
     */
    const DEFAULT_DISPLAY_COMMAND_MODE = 'mod';

    /**
     * La commande de sélection de la vue.
     *
     * @var string
     */
    const DEFAULT_DISPLAY_COMMAND_VIEW = 'view';
    const DEFAULT_NEXT_COMMAND = 'next';
    const DEFAULT_INLINE_COMMAND = 'i';
    const DEFAULT_INLINE_CONTENT_COMMAND = 'incontent';
    const DEFAULT_DISPLAY_MODE = 'none';
    const DEFAULT_DISPLAY_VIEW = 'none';

    // Les icônes.
    // Icône transparente.
    const DEFAULT_ICON_ALPHA_COLOR = '87b260416aa0f50736d3ca51bcb6aae3eff373bf471d5662883b8b6797e73e85';
    // Icônes des liens.
    const DEFAULT_ICON_LC = 'e60a32f1430b2dc6660dcd7da13fed39885451c3069e6db0daba3708f69b8b6e';
    const DEFAULT_ICON_LD = '232fd0ece47c1ff450927d0153886e9eec64fcf9e16ed396825c33564954f409';
    const DEFAULT_ICON_LE = '700ce9b827d9170303c01541eeba364b2616fabeaf6a9998868753c8feffe3dd';
    const DEFAULT_ICON_LF = '06cac4acb887cff2c7ba6653f865d800276a4e9d493a3be4e1b05d107f5ecbaf';
    const DEFAULT_ICON_LK = '6d1d397afbc0d2f6866acd1a30ac88abce6a6c4c2d495179504c2dcb09d707c1';
    const DEFAULT_ICON_LL = '42e46987d36e7ae291fafc889d6ff2718db4ab277bf433491606a4c63dbc32d9';
    const DEFAULT_ICON_LLL = 'acda8f3efd9ded574efa9913e75d548968fd5790afe3bdeaedcb4c07776a4161';
    const DEFAULT_ICON_LO = '26d3b259b94862aecac064628ec02a38e30e9da9b262a7307453046e242cc9ee';
    const DEFAULT_ICON_LS = 'f6ae2aefb4249267c51ecf9e02c9aefd7f9312e1d22f793d35972d55ee1fb85a';
    const DEFAULT_ICON_LU = '7e9726b5aec1b2ab45c70f882f56ea0687c27d0739022e907c50feb87dfaf37d';
    const DEFAULT_ICON_LX = '72e8483f1e76c9c5ddc61fe014f0eb8a97a20fec5d3f1004085157cff6776f81';
    // Icônes de signalisation.
    const DEFAULT_ICON_IOK = '5931cd5d9d77d3f923cd69d306dfbb869723d1b132f0a64916e78b1bb6adb5e2';
    const DEFAULT_ICON_IWARN = 'bca818062c4548d7957b949707c5160a3606c83027c1e855fa6d189768b60a47';
    const DEFAULT_ICON_IERR = '25a0ea1b1d88d7a659ff0fa3d1b70d0cf7ae788023f897da845b1ce8d1cc7e00';
    const DEFAULT_ICON_IINFO = '77c14d86041ded85f77b1cc3395c55ffe8f9c5eb1bda9dc6dfc650eeecb86980';
    const DEFAULT_ICON_IMLOG = 'd7f68db0a1d0977fb8e521fd038b18cd601946aa0e26071ff8c02c160549633b';
    const DEFAULT_ICON_IMODIFY = '8481a8f5b0172db714caa5ea98a924ff40672e66e563b9b628bbf4c5044cfdad';
    const DEFAULT_ICON_IDOWNLOAD = '3cd50162b66b62d582110858a6167794d7afc7f83a918aa4f2339f00b66ac620';
    const DEFAULT_ICON_HELP = '1543e2549dc52d2972a5b444a4d935360a97c125b72c6946ae9dc980077b8b7d';
    const DEFAULT_ICON_FLUSH = '3fd49fd8e5e86d65f3c6983d12a585467a6304e0e8b137609a8592937aab0dd7';
    // Icônes des synchronisations.
    const DEFAULT_ICON_SYNOBJ = '5fc6d664c592591eedea906e493a94ba916ce0a4e2eaed9f0a53d664f5c98eae';
    const DEFAULT_ICON_SYNLNK = '94c3308da0169f91c875fbd802334ec42883b978248e82bebf3e52f3cc80b4cf';
    const DEFAULT_ICON_SYNENT = '468f2e420371343c58dcdb49c4db9f00b81cce029a5ee1de627b9486994ee199';
    // Icônes des ajouts.
    const DEFAULT_ICON_ADD = 'da27aba584a1058642780169fea2fa9e072d22d1df515a84f5310608b1f31266';
    const DEFAULT_ICON_ADDOBJ = '37be5ba2a53e9835dbb0ff67a0ece1cc349c311660e4779680ee2daa4ac45636';
    const DEFAULT_ICON_ADDLNK = '4be77eff5da4ca093f43af7c71371431b30195aee0587d92e4c012923efc7b8a';
    const DEFAULT_ICON_ADDENT = 'cba3712128bbdd5243af372884eb647595103bb4c1f1b4d2e2bf62f0eba3d6e6';
    // Icônes des groupes.
    const DEFAULT_ICON_GRPENT = 'e0dcd8716dbca0ef984dec7bee459bb64c4c03bbc659d23c09c4681358e15b2c';
    const DEFAULT_ICON_GRPOBJ = '0390b7edb0dc9d36b9674c8eb045a75a7380844325be7e3b9557c031785bc6a2';
    const DEFAULT_ICON_GRPENTADD = '672bc011bd1a59857603bbe68ad63511b2d47030b7d1d2987e796d796f2928ab';
    const DEFAULT_ICON_GRPOBJADD = '819babe3072d50f126a90c982722568a7ce2ddd2b294235f40679f9d220e8a0a';
    // Icônes des conversations.
    const DEFAULT_ICON_CVT = '836e7786bbfc0f360d9c85908920b6dcaee34d46ca8e9c1de3a8462d95388b49';
    const DEFAULT_ICON_CVTENT = 'fdc7745129235ee0952a3276a862c0f36c070005f677889543ce8120c79c5e76';
    const DEFAULT_ICON_CVTOBJ = '77a2eaeedd706b8d62c6e7f39f4f42d4dcf3d78d2145bcd0e6d9d7b4d6852e8f';
    const DEFAULT_ICON_CVTENTADD = '9a7ff374f5de2b18975f2965339fb5b25915d1e64a5034354ca1607deaade057';
    const DEFAULT_ICON_CVTOBJADD = 'ff3fb6c1cfee8d9199e298afcf9e283c5db1b91696dc2677e110a026991aeea6';
    // Icônes des entités.
    const DEFAULT_ICON_USER = '94d672f309fcf437f0fa305337bdc89fbb01e13cff8d6668557e4afdacaea1e0';
    const DEFAULT_ICON_ENT = '94d5243e2b48bb89e91f2906bdd7f9006b1632203e831ff09615ad2ccaf20a60';
    const DEFAULT_ICON_OBJECT = '26d3b259b94862aecac064628ec02a38e30e9da9b262a7307453046e242cc9ee';
    const DEFAULT_ICON_ENTITY_LOCK = 'de62640d07ac4cb2f50169fa361e062ed3595be1e973c55eb3ef623ed5661947';
    const DEFAULT_ICON_KEY = '1c6db1c9b3b52a9b68d19c936d08697b42595bec2f0adf16e8d9223df3a4e7c5';
    // Icônes des listes.
    const DEFAULT_ICON_LSTOBJ = 'cc2a24b13d8e03a5de238a79a8adda1a9744507b8870d59448a23b8c8eeb5588';
    const DEFAULT_ICON_LSTLNK = '06cac4acb887cff2c7ba6653f865d800276a4e9d493a3be4e1b05d107f5ecbaf';
    const DEFAULT_ICON_LSTENT = '3edf52669e7284e4cefbdbb00a8b015460271765e97a0d6ce6496b11fe530ce1';
    // Icônes diverses.
    const DEFAULT_ICON_WORLD = '3638230cde600865159d5b5f7993d8a3310deb35aa1f6f8f57429b16472e03d6';
    const DEFAULT_ICON_TIME = '108033240730a0b19e96c82d85802f53c348e446441525696744f7102070b0ed';
    const DEFAULT_ICON_APPLICATION = '47e168b254f2dfd0a4414a0b96f853eed3df0315aecb8c9e8e505fa5d0df0e9c';


    // Références des icônes des liens.
    /**
     * Référence pour l'icône c.
     * ref link : _f_6e6562756c652f6c69656e2f6c630000000000000000000000000000000000000000_e60a32f1430b2dc6660dcd7da13fed39885451c3069e6db0daba3708f69b8b6e_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LC = '6e6562756c652f6c69656e2f6c630000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône d.
     * ref link : _f_6e6562756c652f6c69656e2f6c640000000000000000000000000000000000000000_232fd0ece47c1ff450927d0153886e9eec64fcf9e16ed396825c33564954f409_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LD = '6e6562756c652f6c69656e2f6c640000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône e.
     * ref link : _f_6e6562756c652f6c69656e2f6c650000000000000000000000000000000000000000_700ce9b827d9170303c01541eeba364b2616fabeaf6a9998868753c8feffe3dd_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LE = '6e6562756c652f6c69656e2f6c650000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône f.
     * ref link : _f_6e6562756c652f6c69656e2f6c660000000000000000000000000000000000000000_06cac4acb887cff2c7ba6653f865d800276a4e9d493a3be4e1b05d107f5ecbaf_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LF = '6e6562756c652f6c69656e2f6c660000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône k.
     * ref link : _f_6e6562756c652f6c69656e2f6c6b0000000000000000000000000000000000000000_6d1d397afbc0d2f6866acd1a30ac88abce6a6c4c2d495179504c2dcb09d707c1_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LK = '6e6562756c652f6c69656e2f6c6b0000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône l.
     * ref link : _f_6e6562756c652f6c69656e2f6c6c0000000000000000000000000000000000000000_42e46987d36e7ae291fafc889d6ff2718db4ab277bf433491606a4c63dbc32d9_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LL = '6e6562756c652f6c69656e2f6c6c0000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône o.
     * ref link : _f_6e6562756c652f6c69656e2f6c6f0000000000000000000000000000000000000000_26d3b259b94862aecac064628ec02a38e30e9da9b262a7307453046e242cc9ee_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LO = '6e6562756c652f6c69656e2f6c6f0000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône s.
     * ref link : _f_6e6562756c652f6c69656e2f6c730000000000000000000000000000000000000000_f6ae2aefb4249267c51ecf9e02c9aefd7f9312e1d22f793d35972d55ee1fb85a_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LS = '6e6562756c652f6c69656e2f6c730000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône u.
     * ref link : _f_6e6562756c652f6c69656e2f6c750000000000000000000000000000000000000000_7e9726b5aec1b2ab45c70f882f56ea0687c27d0739022e907c50feb87dfaf37d_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LU = '6e6562756c652f6c69656e2f6c750000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône x.
     * ref link : _f_6e6562756c652f6c69656e2f6c780000000000000000000000000000000000000000_72e8483f1e76c9c5ddc61fe014f0eb8a97a20fec5d3f1004085157cff6776f81_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_LINK_LX = '6e6562756c652f6c69656e2f6c780000000000000000000000000000000000000000';


    // Références des icônes des type d'objets.
    /**
     * Référence pour l'icône d'un objet.
     * ref link : _f_6e6562756c652f6f626a657400000000000000000000000000000000000000000000_26d3b259b94862aecac064628ec02a38e30e9da9b262a7307453046e242cc9ee_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_OBJECT = '6e6562756c652f6f626a657400000000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône d'une entité.
     * ref link : _f_6e6562756c652f6f626a65742f656e74697465000000000000000000000000000000_94d672f309fcf437f0fa305337bdc89fbb01e13cff8d6668557e4afdacaea1e0_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_ENTITY = '6e6562756c652f6f626a65742f656e74697465000000000000000000000000000000';

    /**
     * Référence pour l'icône d'un groupe.
     * ref link : _f_6e6562756c652f6f626a65742f67726f757065000000000000000000000000000000_0390b7edb0dc9d36b9674c8eb045a75a7380844325be7e3b9557c031785bc6a2_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_GROUP = '6e6562756c652f6f626a65742f67726f757065000000000000000000000000000000';

    /**
     * Référence pour l'icône d'une conversation.
     * ref link : _f_6e6562756c652f6f626a65742f636f6e766572736174696f6e000000000000000000_836e7786bbfc0f360d9c85908920b6dcaee34d46ca8e9c1de3a8462d95388b49_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_CONVERSATION = '6e6562756c652f6f626a65742f636f6e766572736174696f6e000000000000000000';


    /**
     * Référence pour l'icône d'une conversation.
     * ref link : _f_69636f6e20696e666f726d6174696f6e000000000000000000000000000000000000_77c14d86041ded85f77b1cc3395c55ffe8f9c5eb1bda9dc6dfc650eeecb86980_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_INFORMATION = '69636f6e20696e666f726d6174696f6e000000000000000000000000000000000000';

    /**
     * Référence pour l'icône d'une conversation.
     * ref link : _f_69636f6e206f6b000000000000000000000000000000000000000000000000000000_5931cd5d9d77d3f923cd69d306dfbb869723d1b132f0a64916e78b1bb6adb5e2_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_OK = '69636f6e206f6b000000000000000000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône d'une conversation.
     * ref link : _f_69636f6e207761726e696e6700000000000000000000000000000000000000000000_bca818062c4548d7957b949707c5160a3606c83027c1e855fa6d189768b60a47_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_WARNING = '69636f6e207761726e696e6700000000000000000000000000000000000000000000';

    /**
     * Référence pour l'icône d'une conversation.
     * ref link : _f_69636f6e206572726f72000000000000000000000000000000000000000000000000_25a0ea1b1d88d7a659ff0fa3d1b70d0cf7ae788023f897da845b1ce8d1cc7e00_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_ERROR = '69636f6e206572726f72000000000000000000000000000000000000000000000000';


    // Références des icônes des émotions.
    /**
     * Référence pour l'icône de l'émotion joie.
     * ref link : _f_6f6a6569656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000000000_6e433d723e5e46d3ba7403220c522f1eb96ec54b4edcd09af6ba37c2fc9b18d7_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_JOIE0 = '6f6a6569656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000000000';

    /**
     * Référence pour l'icône de l'émotion confiance.
     * ref link : _f_6f63666e6169636e65656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000_9eceb029ea8795cf493bf79312b8bb940d4c5bd9ea6c7de8c401d53cc2c0672f_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_CONFIANCE0 = '6f63666e6169636e65656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000';

    /**
     * Référence pour l'icône de l'émotion peur.
     * ref link : _f_65707275656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000000000_d21566c3107f5f10d3cc12a4f42029d34159976083b1df9bc8204399a70ef87e_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_PEUR0 = '65707275656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000000000';

    /**
     * Référence pour l'icône de l'émotion surprise.
     * ref link : _f_7573707269726573656e7562656c6f2f6a627465652f6f6d69746e6f0a2f00000000_794e5af096cda83c2fd9ccbf52a52103d55fd81ebcc36719ebf8ebd5659c35a6_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_SURPRISE0 = '7573707269726573656e7562656c6f2f6a627465652f6f6d69746e6f0a2f00000000';

    /**
     * Référence pour l'icône de l'émotion tristesse.
     * ref link : _f_727473696574737365656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000_3a8a6832bef55c2441d310f569f98f806ae9c7e0d468945849f754204dd33205_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_TRISTESSE0 = '727473696574737365656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000';

    /**
     * Référence pour l'icône de l'émotion dégoût.
     * ref link : _f_65646f677475656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000000000_43aea1f04796d518fe35d2d970670df0833e74b35f6423726cbedcd904636925_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_DEGOUT0 = '65646f677475656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000000000';

    /**
     * Référence pour l'icône de l'émotion colère.
     * ref link : _f_6f63656c6572656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000000000_1c2a08af667e4d2187758b4c5a8ab9bf0b7a03bca72b2b162f05a4ee07cacef1_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_COLERE0 = '6f63656c6572656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000000000';

    /**
     * Référence pour l'icône de l'émotion intérêt.
     * ref link : _f_6e696574657274656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000_26fc1b54530a72c103a00b6d4aa8443ebd892d5ebfb34ef7e7f64294d6ae310e_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_INTERET0 = '6e696574657274656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000';

    /**
     * Référence pour l'icône de l'émotion joie activée.
     * ref link : _f_6f6a6569656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000000001_9c93b9fe47817c6cbecceb4cf20140db7c73bcaf0842b3e780b819658d737432_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_JOIE1 = '6f6a6569656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000000001';

    /**
     * Référence pour l'icône de l'émotion confiance activée.
     * ref link : _f_6f63666e6169636e65656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000001_c74e9142292f7c26a4afc13a791ad745919691476c86a4824f30a1f92c89a37c_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_CONFIANCE1 = '6f63666e6169636e65656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000001';

    /**
     * Référence pour l'icône de l'émotion peur activée.
     * ref link : _f_65707275656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000000001_feee2486efb2b81ba9c371f7c2c4ed0add300d4b7de602cc8deb3f5940c7fc45_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_PEUR1 = '65707275656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000000000001';

    /**
     * Référence pour l'icône de l'émotion surprise activée.
     * ref link : _f_7573707269726573656e7562656c6f2f6a627465652f6f6d69746e6f0a2f00000001_f72a1920797a95d814a792e4b09c295e8863ed88b788a8a0a0e18ebc1c10b099_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_SURPRISE1 = '7573707269726573656e7562656c6f2f6a627465652f6f6d69746e6f0a2f00000001';

    /**
     * Référence pour l'icône de l'émotion tristesse activée.
     * ref link : _f_727473696574737365656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000001_54238c7d3feac2fc6a8fceaefbc2b5be402840d4aeb3a68f665d248a7b0d00d4_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_TRISTESSE1 = '727473696574737365656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000001';

    /**
     * Référence pour l'icône de l'émotion dégoût activée.
     * ref link : _f_65646f677475656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000000001_b8424a4eb643c38ae8aebe7efcc6245c1b5a8d3035ed9c18107484b5bbdbfad2_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_DEGOUT1 = '65646f677475656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000000001';

    /**
     * Référence pour l'icône de l'émotion colère activée.
     * ref link : _f_6f63656c6572656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000000001_f4a0be239d4080d711edebb724624044c4da1f3f656714337ebc20514f600dc1_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_COLERE1 = '6f63656c6572656e7562656c6f2f6a627465652f6f6d69746e6f0a2f000000000001';

    /**
     * Référence pour l'icône de l'émotion intérêt activée.
     * ref link : _f_6e696574657274656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000001_b68f319917545cc58cf49f916276ec5025b471c51dacb632600bdb24c312960b_1ca96e517fc6ccca45080244c594dd777dc5d3bde0f872f961c28a4e9749ba82
     *
     * @var string
     */
    const REFERENCE_ICON_EMOTION_INTERET1 = '6e696574657274656e7562656c6f2f6a627465652f6f6d69746e6f0a2f0000000001';


    /**
     * Liste des objets nécessaires au bon fonctionnement de l'application.
     * Vide par défaut, est remplacé par l'application.
     *
     * @var array:string
     */
    protected $_neededObjectsList = array();

    /**
     * Liste des objets nécessaires au bon fonctionnement.
     * Ici, ce sont tous les objets communs aux applications.
     *
     * @var array
     */
    protected $_commonNeededObjectsList = array(
        self::DEFAULT_ICON_ALPHA_COLOR,
        self::DEFAULT_ICON_LC,
        self::DEFAULT_ICON_LD,
        self::DEFAULT_ICON_LE,
        self::DEFAULT_ICON_LF,
        self::DEFAULT_ICON_LK,
        self::DEFAULT_ICON_LL,
        self::DEFAULT_ICON_LLL,
        self::DEFAULT_ICON_LO,
        self::DEFAULT_ICON_LS,
        self::DEFAULT_ICON_LU,
        self::DEFAULT_ICON_LX,
        self::DEFAULT_ICON_IOK,
        self::DEFAULT_ICON_IWARN,
        self::DEFAULT_ICON_IERR,
        self::DEFAULT_ICON_IINFO,
    );


    /* ---------- ---------- ---------- ---------- ----------
	 * Variables.
	 *
	 * Les valeurs par défaut sont indicatives. Ne pas les replacer.
	 * Les variables sont systématiquement recalculées.
	 */
    /**
     * Instance nebule.
     *
     * @var nebule
     */
    protected $_nebuleInstance;

    /**
     * Instance sylabe.
     *
     * @var sylabe
     */
    protected $_applicationInstance;

    /**
     * Instance de metrologie.
     *
     * @var Metrology
     */
    protected $_metrologyInstance;

    /**
     * Instance des I/O (entrées/sorties).
     *
     * @var IO
     */
    protected $_ioInstance;

    /**
     * Instance de traduction.
     *
     * @var Traductions
     */
    protected $_traductionInstance;

    /**
     * Etat de verrouillage de l'entité en cours.
     *
     * @var boolean
     */
    protected $_unlocked = false;

    /**
     * Instance des actions.
     *
     * @var Actions
     */
    protected $_actionInstance;

    /**
     * La base du lien hypertexte pour les objets.
     *
     * @var string
     */
    protected $_htlinkObjectPrefix = '';

    /**
     * La base du lien hypertexte pour les groupes.
     *
     * @var string
     */
    protected $_htlinkGroupPrefix = '';

    /**
     * La base du lien hypertexte pour les conversations.
     *
     * @var string
     */
    protected $_htlinkConversationPrefix = '';

    /**
     * La base du lien hypertexte pour les entités.
     *
     * @var string
     */
    protected $_htlinkEntityPrefix = '';

    /**
     * La base du lien hypertexte pour les monnaies.
     *
     * @var string
     */
    protected $_htlinkCurrencyPrefix = '';

    /**
     * La base du lien hypertexte pour les sacs de jetons.
     *
     * @var string
     */
    protected $_htlinkTokenPoolPrefix = '';

    /**
     * La base du lien hypertexte pour les jetons.
     *
     * @var string
     */
    protected $_htlinkTokenPrefix = '';

    /**
     * La base du lien hypertexte pour les transactions.
     *
     * @var string
     */
    protected $_htlinkTransactionPrefix = '';

    /**
     * La base du lien hypertexte pour les portefeuilles.
     *
     * @var string
     */
    protected $_htlinkWalletPrefix = '';

    protected $_currentDisplayLanguage;

    protected $_currentDisplayLanguageInstance;

    protected $_displayLanguageList = array();

    protected $_displayLanguageInstanceList = array();


    /**
     * Constructeur.
     *
     * @param Applications $applicationInstance
     * @return void
     */
    public function __construct(Applications $applicationInstance)
    {
        $this->_applicationInstance = $applicationInstance;
    }

    /**
     * Initialisation des variables et instances interdépendantes.
     *
     * @return void
     */
    public function initialisation()
    {
        global $applicationName;

        $this->_nebuleInstance = $this->_applicationInstance->getNebuleInstance();
        $this->_ioInstance = $this->_nebuleInstance->getIO();
        $this->_metrologyInstance = $this->_nebuleInstance->getMetrologyInstance();
        $this->_metrologyInstance->addLog('Load displays', Metrology::LOG_LEVEL_NORMAL); // Log
        $this->_traductionInstance = $this->_applicationInstance->getTraductionInstance();
        $this->_actionInstance = $this->_applicationInstance->getActionInstance();
        $this->_unlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();

        $this->setHtlinkObjectPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkGroupPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkConversationPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkEntityPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkCurrencyPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkTokenPoolPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkTokenPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkTransactionPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkWalletPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');

        $this->_findCurrentDisplayMode();
        $this->_findCurrentDisplayView();
        $this->_findInlineContentID();

        // Aucun affichage, aucune traduction, aucune action avant le retour de cette fonction.
        // Les instances interdépendantes doivent être synchronisées.
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return 'Display';
    }

    /**
     * Fonction de mise en sommeil.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return array();
    }

    /**
     * Fonction de réveil.
     *
     * Récupère l'instance de la librairie nebule et de l'application.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $applicationInstance;

        $this->_applicationInstance = $applicationInstance;
    }

    /**
     * Initialisation des variables et instances interdépendantes.
     * @return void
     * @todo à optimiser avec __wakeup et __sleep.
     *
     */
    public function initialisation2()
    {
        global $applicationName;

        $this->_nebuleInstance = $this->_applicationInstance->getNebuleInstance();
        $this->_ioInstance = $this->_nebuleInstance->getIO();
        $this->_metrologyInstance = $this->_nebuleInstance->getMetrologyInstance();
        $this->_metrologyInstance->addLog('Load displays', Metrology::LOG_LEVEL_NORMAL); // Log
        $this->_traductionInstance = $this->_applicationInstance->getTraductionInstance();
        $this->_actionInstance = $this->_applicationInstance->getActionInstance();
        $this->_unlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();

        $this->setHtlinkObjectPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkGroupPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkConversationPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkEntityPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkCurrencyPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkTokenPoolPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkTokenPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkTransactionPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');
        $this->setHtlinkWalletPrefix('?'
            . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $applicationName
            . '&' . self::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . nebule::COMMAND_SELECT_OBJECT
            . '&' . nebule::COMMAND_SELECT_OBJECT . '=');

        $this->_findCurrentDisplayMode();
        $this->_findCurrentDisplayView();
        $this->_findInlineContentID();

        // Aucun affichage, aucune traduction, aucune action avant le retour de cette fonction.
        // Les instances interdépendantes doivent être synchronisées.
    }

    /**
     * Retourne la liste des objets nécessaires au bon fonctionnement de l'application.
     *
     * Vide par défaut, est remplacé par l'application.
     *
     * @return array:string
     */
    public function getNeededObjectsList()
    {
        return $this->_neededObjectsList;
    }


    /**
     * Variable du mode d'affichage en cours.
     *
     * @var string
     */
    protected $_currentDisplayMode = '';

    /**
     * Liste des modes disponibles.
     *
     * @var array of string
     */
    protected $_listDisplayModes = array();

    /**
     * Variable de l'instance du mode en cours.
     *
     * @var Modules
     */
    protected $_currentModuleInstance = null;

    /**
     * Cherche le mode d'affichage en cours.
     *
     * La recherche du mode se fait en lisant le mode demandé dans l'URL,
     *   puis en le comparant aux modes listés ou aux modes supportés par les modules présents.
     *
     * Seul le mode concerné sera traité et affiché.
     *
     * Si la liste des modes est vide et si les modules ne sont pas activés, on quitte.
     * Si les modules sont activés mais que la liste des modules est vide, on quitte.
     *
     * @return void
     */
    protected function _findCurrentDisplayMode()
    {
        global $applicationName;

        // Vérifie que la liste des modes ne soit pas vide ou que l'on utilise les modules.
        if (sizeof($this->_listDisplayModes) == 0
            && !$this->_applicationInstance->getUseModules()
        ) {
            return;
        }
        // Vérifie la liste des modules si activé.
        if ($this->_applicationInstance->getUseModules()
            && sizeof($this->_applicationInstance->getModulesListInstances()) == 0
        ) {
            return;
        }

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        $arg_mod = filter_input(INPUT_GET, self::DEFAULT_DISPLAY_COMMAND_MODE, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW);

        $list_mods_names = array();

        // Si activé, extrait les modes.
        if ($this->_applicationInstance->getUseModules()) {
            $list_mods = $this->_applicationInstance->getModulesListInstances();
            // Extrait les noms de commandes des modes.
            $list_mods_names = array(0 => Display::DEFAULT_DISPLAY_MODE);
            $module = null;
            foreach ($list_mods as $module) {
                if ($module->getCommandName() != ''
                    && $module->getType() == 'application'
                ) {
                    $commandName = $module->getCommandName();
                    $list_mods_names[$commandName] = $commandName;
                }
            }
            unset($module, $commandName);
        } else {
            foreach ($this->_listDisplayModes as $mode) {
                $list_mods_names[$mode] = $mode;
            }
        }

        // Recherche un mode connu.
        $ok_mod = false;
        foreach ($list_mods_names as $name) {
            if ($arg_mod == $name) {
                $ok_mod = true;
            }
        }
        if ($ok_mod) // Si le mode est connu.
        {
            // Ecrit le mode dans la variable.
            $this->_currentDisplayMode = $arg_mod;
            // Ecrit le mode dans la session.
            $this->_nebuleInstance->setSessionStore($applicationName . 'DisplayMode', $arg_mod);
        } else {
            $cache = $this->_nebuleInstance->getSessionStore('sylabeDisplayMode');
            // Si il existe une variable de session pour le mode d'affichage, la lit.
            if ($cache !== false
                && $cache != ''
            ) {
                $this->_currentDisplayMode = $cache;
            } else // Sinon active le mode par defaut.
            {
                $this->_currentDisplayMode = Display::DEFAULT_DISPLAY_MODE;
                $this->_nebuleInstance->setSessionStore($applicationName . 'DisplayMode', Display::DEFAULT_DISPLAY_MODE);
            }
            unset($cache);
        }
        $this->_metrologyInstance->addLog('Current mode : ' . $this->_currentDisplayMode, Metrology::LOG_LEVEL_DEBUG); // Log

        // Récupère l'instance du module en cours.
        if ($this->_applicationInstance->getUseModules()) {
            // Par défaut on récupère la constante.
            $moduleName = Display::DEFAULT_DISPLAY_MODE;

            foreach ($list_mods as $module) {
                if ($module->getCommandName() == $this->_currentDisplayMode
                    && $module->getType() == 'application'
                ) {
                    $moduleName = $module->getClassName();
                }
            }
            $this->_currentModuleInstance = $this->_applicationInstance->getModulesListInstances()[$moduleName];
        }

        unset($arg_mod, $list_mods, $list_mods_names, $ok_mod, $name, $moduleName);
    }

    /**
     * Retourne le mode d'affichage en cours.
     *
     * @return string
     */
    public function getCurrentDisplayMode()
    {
        return $this->_currentDisplayMode;
    }


    /**
     * Variable de la vue en cours.
     * @var string
     */
    protected $_currentDisplayView = '';

    /**
     * Liste des vues disponibles.
     *
     * @var array of string
     */
    protected $_listDisplayViews = array();

    /**
     * Recherche la vue en cours.
     *
     * La recherche de la vue se fait en lisant la vue demandée dans l'URL,
     *   puis en la comparant aux vues supportées par le modes en cours
     *   ou par la liste des vues si le mode n'est pas géré.
     *
     * Les vues des autres modes ne sont pas prises en comptes.
     * Seul le mode concerné sera traité et affiché.
     *
     * Si la liste des vues est vide et si les modules ne sont pas activés, on quitte.
     * Si les modules sont activés mais que la liste des modules est vide, on quitte.
     *
     * @return void
     */
    protected function _findCurrentDisplayView()
    {
        global $applicationName;

        // Vérifie que la liste des vues ne soit pas vide ou que l'on utilise les modules.
        if (sizeof($this->_listDisplayViews) == 0
            && !$this->_applicationInstance->getUseModules()
        ) {
            return;
        }
        // Vérifie la liste des modules si activé.
        if ($this->_applicationInstance->getUseModules()
            && sizeof($this->_applicationInstance->getModulesListInstances()) == 0
        ) {
            return;
        }

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        $arg_view = filter_input(INPUT_GET, Display::DEFAULT_DISPLAY_COMMAND_VIEW, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW);

        $list_views_names = array();

        // Si activé, extrait les modes.
        if ($this->_applicationInstance->getUseModules()) {
            // Lit les vues déclarées.
            $list_views_names = $this->_currentModuleInstance->getRegisteredViews();
            // Si demande la vue par défaut.
            if ($arg_view == 'default') {
                $arg_view = $this->_currentModuleInstance->getDefaultView();
            }
        } else {
            foreach ($this->_listDisplayViews as $view) {
                $list_views_names[$view] = $view;
            }
        }

        // Recherche une vue connue.
        $ok_view = false;
        foreach ($list_views_names as $name) {
            if ($arg_view == $name) {
                $ok_view = true;
            }
        }
        if ($arg_view == 'menu') {
            $ok_view = true;
        }

        if ($ok_view) // Si la vue est connue.
        {
            // Ecrit la vue dans la variable.
            $this->_currentDisplayView = $arg_view;
            // Ecrit la vue dans la session.
            $this->_nebuleInstance->setSessionStore($applicationName . 'DisplayView', $arg_view);
        } else {
            $cache = $this->_nebuleInstance->getSessionStore($applicationName . 'DisplayView');
            // Si il existe une variable de session pour la vue, la lit.
            if ($cache !== false
                && $cache != ''
            ) {
                $this->_currentDisplayView = $cache;
            } else // Sinon active la vue par defaut.
            {
                // Si activé, extrait les modes.
                if ($this->_applicationInstance->getUseModules()) {
                    $this->_currentDisplayView = $this->_currentModuleInstance->getDefaultView();
                } else {
                    $this->_currentDisplayView = self::DEFAULT_DISPLAY_VIEW;
                }
                // Ecrit dans le cache.
                $this->_nebuleInstance->setSessionStore($applicationName . 'DisplayView', $this->_currentDisplayView);
            }
            unset($cache);
        }
        $this->_metrologyInstance->addLog('Current view : ' . $this->_currentDisplayView, Metrology::LOG_LEVEL_DEBUG); // Log

        unset($arg_view, $list_views_names, $ok_view);
    }

    /**
     * Retourne la vue en cours.
     *
     * @return string
     */
    public function getCurrentDisplayView()
    {
        return $this->_currentDisplayView;
    }


    /**
     * Recherche l'ID de contenu online à afficher.
     */
    protected function _findInlineContentID()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // extrait l'ID de contenu.
        $arg_id = trim(filter_input(INPUT_GET, self::DEFAULT_INLINE_CONTENT_COMMAND, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW)); // Lit et nettoye le contenu de la variable GET.
        if ($arg_id != '') {
            $this->_inlineContentID = $arg_id; // Ecrit l'objet dans la variable.
        }
        unset($arg_id);

        // Log
        $this->_metrologyInstance->addLog('Find sub display : ' . $this->_inlineContentID, Metrology::LOG_LEVEL_DEBUG);
    }

    protected $_inlineContentID = '';

    protected $_inlineContentIndex = array();

    protected $_inlineContentOptions = array();

    /**
     * Retourne l'ID html à traiter.
     *
     * @return string
     */
    public function getInlineContentID()
    {
        return $this->_inlineContentID;
    }

    /**
     * Enregistre un ID de contenu html à remplacer.
     *
     * La variable options permet de passer des paramètres supplémentaires.
     *
     * @param string $id
     * @param string $options
     * @return boolean
     */
    public function registerInlineContentID($id, $options = '')
    {
        if ($id == ''
            || $id == '0'
        ) {
            return false;
        }

        $this->_inlineContentIndex[$id] = $id;
        $this->_inlineContentOptions[$id] = $options;

        // Log
        $this->_metrologyInstance->addLog('Register sub display : ' . $id, Metrology::LOG_LEVEL_DEBUG);
        ?>

        <div class="inlinecontent" id="<?php echo $id; ?>">
            <p class="inlinecontentwait"><?php $this->echoTraduction('::progress'); ?></p>
        </div>
        <?php
        return true;
    }

    /**
     * Affiche le nécesaire pour le contenu html à remplacer.
     *
     * @return boolean
     */
    protected function _displayInlineContentID()
    {
        if (sizeof($this->_inlineContentIndex) == 0) {
            return true;
        }

        echo "<script language=\"javascript\" type=\"text/javascript\">\n<!--\n";
        $url = '?' . self::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $this->_currentDisplayMode
            . '&' . Display::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . $this->_currentDisplayView;
        foreach ($this->_inlineContentIndex as $id) {
            $option = '';
            if (isset($this->_inlineContentOptions[$id])
                && $this->_inlineContentOptions[$id] != ''
            ) {
                $option = '&' . $this->_inlineContentOptions[$id];
            }
            echo "setTimeout(replaceInlineContentFromURL('" . $id . "', '" . $url
                . '&' . self::DEFAULT_INLINE_COMMAND . '&' . self::DEFAULT_INLINE_CONTENT_COMMAND . '=' . $id
                . $option . "'), 20);\n";
        }
        echo "//-->\n</script>\n";

        // Vide la liste
        $this->_inlineContentIndex = array();
        $this->_inlineContentOptions = array();

        return true;
    }


    /**
     * Affichage du style CSS commun.
     */
    public function commonCSS()
    {
        ?>

        <style type="text/css">
            /* CSS reset. http://meyerweb.com/eric/tools/css/reset/ v2.0 20110126. Public domain */
            * {
                margin: 0;
                padding: 0;
            }

            html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre,
            a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp,
            small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li,
            fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,
            article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup,
            menu, nav, output, ruby, section, summary, time, mark, audio, video {
                border: 0;
                font-size: 100%;
                font: inherit;
                vertical-align: baseline;
            }

            article, aside, details, figure, figcaption, footer, header, hgroup, menu, nav, section {
                display: block;
            }

            body {
                line-height: 1;
            }

            ol, ul {
                list-style: none;
            }

            blockquote, q {
                quotes: none;
            }

            blockquote:before, blockquote:after, q:before, q:after {
                content: '';
                content: none;
            }

            table {
                border-collapse: collapse;
                border-spacing: 0;
            }

            /* Balises communes. */
            html {
                height: 100%;
                width: 100%;
            }

            body {
                color: #ababab;
                font-family: monospace;
                background: #454545;
                height: 100%;
                width: 100%;
                min-height: 480px;
                min-width: 640px;
            }

            img, embed, canvas, video, audio, picture {
                max-width: 100%;
                height: auto;
            }

            img {
                border: 0;
                vertical-align: middle;
            }

            a:link, a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #ababab;
            }

            a:hover, a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #ffffff;
            }

            input {
                background: #ffffff;
                color: #000000;
                margin: 0;
                margin-top: 5px;
                border: 0;
                box-shadow: none;
                padding: 5px;
                background-origin: border-box;
            }

            input[type=submit] {
                font-weight: bold;
            }

            input[type=password], input[type=text], input[type=email] {
                padding: 6px;
            }

            /* Le bloc d'entête */
            .layout-header {
                position: fixed;
                top: 0;
                width: 100%;
                text-align: center;
            }

            .layout-header {
                height: 68px;
                background: #ababab;
                border-bottom-style: solid;
                border-bottom-color: #c8c8c8;
                border-bottom-width: 1px;
            }

            .header-left {
                height: 64px;
                width: 64px;
                margin: 2px;
                float: left;
            }

            .header-left img {
                height: 64px;
                width: 64px;
            }

            .header-right {
                height: 64px;
                width: 64px;
                margin: 2px;
                float: right;
            }

            .header-right img {
                height: 64px;
                width: 64px;
            }

            .header-center {
                height: 100%;
                display: inline-flex;
            }

            .header-center p {
                margin: auto 3px 3px 3px;
                overflow: hidden;
                white-space: nowrap;
                color: #454545;
                text-align: center;
            }

            /* Le bloc de bas de page */
            .layout-footer {
                position: fixed;
                bottom: 0;
                width: 100%;
                text-align: center;
            }

            .layout-footer {
                height: 68px;
                background: #ababab;
                border-top-style: solid;
                border-top-color: #c8c8c8;
                border-top-width: 1px;
            }

            .footer-center p {
                margin: 3px;
                overflow: hidden;
                white-space: nowrap;
                color: #454545;
                text-align: center;
            }

            .footer-center a:link, .footer-center a:visited {
                font-weight: normal;
                text-decoration: none;
                color: #454545;
            }

            .footer-center a:hover, .footer-center a:active {
                font-weight: normal;
                text-decoration: underline;
                color: #ffffff;
            }

            /* Le menu des applications, caché par défaut. */
            .layout-menu-applications {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.33);
                display: none;
                z-index: 100;
            }

            .menu-applications {
                position: fixed;
                top: 79px;
                left: 0;
                padding: 3px;
                padding-bottom: 2px;
                padding-right: 2px;
                width: 100%;
                color: #ffffff;
                background: rgba(0, 0, 0, 0.66);
            }

            .menu-applications img {
                height: 64px;
                width: 64px;
            }

            .menu-applications a:link, .menu-applications a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #ffffff;
            }

            .menu-applications a:hover, .menu-applications a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #ffffff;
            }

            .menu-applications-logo {
                margin: 5px;
            }

            .menu-applications-logo img {
                height: 64px;
                width: 64px;
            }

            .menu-applications-one {
                margin: 2px;
                margin-bottom: 3px;
                margin-right: 3px;
                padding: 5px;
                float: left;
                background: rgba(0, 0, 0, 0.7);
                width: 186px;
                min-height: 64px;
            }

            .menu-applications-icon {
                float: left;
                margin-right: 5px;
            }

            .menu-applications-title p {
                font-size: 1.1em;
                font-weight: bold;
            }

            .menu-applications-text p {
                font-size: 0.8em;
            }

            .menu-applications-sign {
                position: fixed;
                bottom: 10px;
                right: 7px;
                text-align: right;
                color: #ffffff;
            }

            .menu-applications-sign img {
                height: 32px;
                width: 32px;
            }

            .menu-applications-sign a:link, .menu-applications-sign a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #ffffff;
            }

            .menu-applications-sign a:hover, .menu-applications-sign a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #ffffff;
            }

            /* Le corps de la page qui contient le contenu. Permet le centrage vertical universel */
            .layout-main {
                width: 100%;
                height: 100%;
                display: flex;
            }

            /* Le centre de la page avec le contenu utile. Centrage vertical */
            .layout-content {
                margin: auto;
                padding: 84px 0 84px 0;
            }

            /* Les affichages de parties seules comme un message */
            .layoutAloneItem {
                width: 100%;
            }

            .aloneItemContent {
                margin: auto;
                text-align: center;
                font-size: 0;
                min-height: 34px;
                padding: 0 5px 5px 0;
                background: none;
            }

            .aloneTextItemContent {
                margin: auto;
                text-align: justify;
                font-size: 1rem;
                min-height: 34px;
                padding: 5px;
                background: rgba(255, 255, 255, 0.5);
                color: #000000;
            }

            .aloneTextItemContent a {
                color: #000000;
            }

            .content {
                margin: 0;
                text-align: left;
            }

            .error {
                background: #ffa0a0;
                background-origin: border-box;
                font-family: monospace;
                font-size: 1.2em;
                color: #ff0000;
                text-align: left;
            }

            .error p {
                padding: 5px;
            }

            .error img {
                height: 32px;
                width: 32px;
            }

            .error a:link, .error a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #ef0000;
            }

            .error a:hover, .error a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #ffffff;
            }

            .warning {
                background: #ffe080;
                background-origin: border-box;
                font-family: monospace;
                font-size: 1.2em;
                color: #ff8000;
                text-align: left;
            }

            .warning p {
                padding: 5px;
            }

            .warning img {
                height: 32px;
                width: 32px;
            }

            .warning a:link, .warning a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #ef7000;
            }

            .warning a:hover, .warning a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #ffffff;
            }

            .message {
                background: #103020;
                background-origin: border-box;
                font-family: monospace;
                font-size: 1.2em;
                color: #ffffff;
                text-align: left;
            }

            .message p {
                padding: 5px;
            }

            .message img {
                height: 32px;
                width: 32px;
            }

            .information {
                background: rgba(0, 0, 0, 0.6);
                background-origin: border-box;
                text-align: left;
            }

            .information p {
                padding: 5px;
                color: #ffffff;
            }

            .information img {
                height: 32px;
                width: 32px;
            }

            .textTitle {
                background: rgba(255, 255, 255, 0.6);
                background-origin: border-box;
                text-align: center;
                color: #000000;
                clear: both;
                padding: 5px;
                min-height: 65px;
            }

            .textTitle img {
                height: 64px;
                width: 64px;
            }

            .textTitle h1 {
                font-size: 1.5em;
                color: #000000;
                font-weight: bold;
                text-align: center;
                padding: 8px;
                background: rgba(255, 255, 255, 0);
            }

            .textTitle2 {
                background: rgba(255, 255, 255, 0.4);
                background-origin: border-box;
                text-align: center;
                color: #000000;
                clear: both;
                padding: 5px;
                min-height: 65px;
            }

            .textTitle2 img {
                height: 64px;
                width: 64px;
            }

            .textTitle2 h2 {
                font-size: 1.4em;
                color: #000000;
                font-weight: bold;
                text-align: center;
                padding: 5px;
                background: rgba(255, 255, 255, 0);
                font-family: monospace;
            }

            .text {
                padding: 10px;
                padding-top: 20px;
                padding-bottom: 40px;
                background: rgba(255, 255, 255, 0.5);
                background-origin: border-box;
                color: #000000;
            }

            .text p {
                margin-bottom: 20px;
                clear: both;
                text-align: justify;
            }

            .textSmall {
                padding: 5px;
                padding-bottom: 15px;
                background: rgba(255, 255, 255, 0.5);
                background-origin: border-box;
                color: #000000;
            }

            .textSmall p {
                margin: 0;
                clear: both;
                text-align: justify;
            }

            .textnobg {
                padding: 10px;
                padding-top: 20px;
                padding-bottom: 40px;
                color: #000000;
                clear: both;
            }

            .textnobg p {
                margin-bottom: 20px;
                text-align: justify;
            }

            .textcontentfull {
                padding: 5px;
                padding-top: 20px;
                padding-bottom: 40px;
                background: rgba(255, 255, 255, 0.5);
                background-origin: border-box;
                color: #000000;
            }

            .textcontentfull pre {
                background: rgba(255, 255, 255, 0.7);
                background-origin: border-box;
                margin: 0;
                padding: 5px;
                clear: both;
            }

            .textcontentfull img, .textcontentfull video, .textcontentfull audio, .textcontentfull picture {
                max-width: 100%;
                height: auto;
                margin: 0;
                padding: 0;
                clear: both;
            }

            .textcontenthalf {
                padding: 5px;
                background: rgba(255, 255, 255, 0.5);
                background-origin: border-box;
                color: #000000;
            }

            .textcontenthalf pre {
                background: rgba(255, 255, 255, 0.7);
                background-origin: border-box;
                margin: 0;
                padding: 5px;
                clear: both;
            }

            .textcontenthalf img, .textcontenthalf video, .textcontenthalf audio, .textcontenthalf picture {
                max-width: 50%;
                height: auto;
                margin: 0;
                padding: 0;
                clear: both;
            }

            .textcenter {
                padding: 20px;
                padding-bottom: 40px;
                background: rgba(255, 255, 255, 0.5);
                background-origin: border-box;
                text-align: center;
                color: #000000;
            }

            .textcenter p {
                margin-bottom: 20px;
                clear: both;
            }

            .sequence {
                height: 110px;
                clear: both;
            }

            .bootstrapErrorDiv {
                margin: 0px;
                padding: 5px;
                background: #454545;
            }

            .bootstrapErrorDiv p {
                color: #ababab;
            }

            /* Le pied de page pour le traitement des actions, avant l'affichage du centre de la page. */
            .flowaction {
                position: fixed;
                bottom: 0;
                width: 100%;
                margin: 0px;
                background: rgba(34, 34, 34, 0.8);
            }

            .flowaction p {
                color: #ffffff;
            }

            /* Les insersions en ligne. */
            .inlinecontent {
                width: 100%;
            }

            .inlinecontentwait {
                width: 206px;
                text-align: center;
                margin: 5px;
                padding: 5px;
                min-height: 24px;
                background: rgba(0, 0, 0, 0.5);
                color: #ffffff;
            }

            .inlinecontentnext {
                width: 206px;
                text-align: center;
                margin: 5px;
                padding: 5px;
                min-height: 24px;
                background: rgba(0, 0, 0, 0.5);
                color: #ffffff;
            }

            /* Les images */
            .iconegrossepuce {
                height: 64px;
                width: 64px;
            }

            .iconemoyenpuce {
                height: 32px;
                width: 32px;
            }

            .iconepuce {
                height: 16px;
                width: 16px;
            }

            .iconInlineDisplay {
                height: 16px;
                width: 16px;
            }

            /* L'insertion de boutons de fonctionnalités liées aux modules, dans le corps de la page. */
            .textAction {
                padding: 3px;
                min-height: 34px;
                background: rgba(255, 255, 255, 0.12);
                color: #000000;
            }

            .textAction a:link, .textAction a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #000000;
            }

            .textAction a:hover, .textAction a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #000000;
            }

            .oneAction {
                margin: 2px;
                padding: 5px;
                float: left;
                background: rgba(255, 255, 255, 0.7);
                width: 206px;
                min-height: 64px;
            }

            .oneActionItem {
                margin: 2px;
                padding: 5px;
                float: left;
                background: rgba(255, 255, 255, 0.4);
                width: 350px;
                min-height: 64px;
            }

            .oneActionItem-top {
                min-height: 64px;
            }

            .oneAction-icon {
                float: left;
                margin-right: 5px;
            }

            .oneAction-icon img {
                height: 64px;
                width: 64px;
            }

            .oneAction-modname p {
                font-size: 0.6em;
                font-style: italic;
            }

            .oneAction-entityname p {
                font-size: 0.8em;
                margin-bottom: 5px;
            }

            .oneAction-title p {
                font-size: 1.1em;
                font-weight: bold;
            }

            .oneAction-text p {
                font-size: 0.8em;
            }

            .oneAction-actions {
                clear: both;
            }

            .oneAction-actions p {
                background: rgba(255, 255, 255, 0.33);
                margin-top: 5px;
            }

            .oneAction-ok {
                clear: both;
            }

            .oneAction-ok p {
                background: #80ff80;
                margin-top: 5px;
            }

            .oneAction-warn {
                clear: both;
            }

            .oneAction-warn p {
                background: #ffe080;
                margin-top: 5px;
            }

            .oneAction-error {
                clear: both;
            }

            .oneAction-error p {
                background: #ffa0a0;
                margin-top: 5px;
            }

            .oneAction-close {
                height: 1px;
                clear: both;
            }

            #oneAction-bg-warn {
                background: #ffe080;
            }

            .inlineemotions {
                padding: 5px;
                background: rgba(255, 255, 255, 0.3);
                background-origin: border-box;
                text-align: center;
                font-size: 0.8em;
                color: #000000;
            }

            .inlineemotions img {
                height: 24px;
                width: 24px;
                margin-left: 5px;
            }

            /* Pour les bulles d'aide. */
            .infobulle {
                position: absolute;
                left: 0;
                visibility: hidden;
                padding: 5px;
                color: #ffffff;
                background: rgba(0, 0, 0, 0.8);
                width: 50%;
                text-align: justify;
            }

            /* Les champs forçés. */
            .forcedinput {
                background: #ffffff;
                color: #808080;
                margin: 0;
                border: 0;
                box-shadow: none;
                padding: 2px;
                padding-left: 5px;
                padding-right: 5px;
                font-size: 1rem;
            }
        </style>
        <?php
        $this->_getDisplayObjectsListCSS();
        $this->_getDisplayMessageCSS();
        $this->_getDisplayMenuListCSS();
        $this->_getDisplayTitleCSS();
        $this->_getDisplayInformationCSS();
        $this->_getDisplayLinkCSS();
        $this->_getDisplayObjectContentCSS();
        $this->_getDisplayObjectCSS();
    }

    /**
     * Affichage du style CSS de l'application.
     */
    public function displayCSS()
    {
        // Cette fonction doit être surchargée par l'application avec ses styles propres.
    }


    /**
     * Affichage des scripts JS communs.
     * Si l'option permitJavaScript est à false, cette partie est désactivée.
     *
     * @return void
     */
    public function commonScripts()
    {
        if (!$this->_nebuleInstance->getOption('permitJavaScript')) {
            return;
        }
        ?>

        <script language="javascript" type="text/javascript">
            <!--
            function replaceInlineContent(id, content) {
                document.getElementById(id).innerHTML = content;
            }

            function replaceInlineContentFromURL(id, url) {
                var req = false;
                // For Safari, Firefox, and other non-MS browsers
                if (window.XMLHttpRequest) {
                    try {
                        req = new XMLHttpRequest();
                    } catch (e) {
                        req = false;
                    }
                } else if (window.ActiveXObject) {
                    // For Internet Explorer on Windows
                    try {
                        req = new ActiveXObject("Msxml2.XMLHTTP");
                    } catch (e) {
                        try {
                            req = new ActiveXObject("Microsoft.XMLHTTP");
                        } catch (e) {
                            req = false;
                        }
                    }
                }
                var element = document.getElementById(id);
                if (!element) {
                    return;
                }
                if (req) {
                    // Synchronous request, wait till we have it all
                    req.open('GET', url, false);
                    req.send(null);
                    element.innerHTML = req.responseText;
                } else {
                    element.innerHTML = "ERROR: your browser does not support XMLHTTPRequest objects!";
                }
            }

            function replaceNextContentFromURL(id, url) {
                replaceInlineContent(id, '<p class="inlinecontentwait">...</p>');
                var req = false;
                // For Safari, Firefox, and other non-MS browsers
                if (window.XMLHttpRequest) {
                    try {
                        req = new XMLHttpRequest();
                    } catch (e) {
                        req = false;
                    }
                } else if (window.ActiveXObject) {
                    // For Internet Explorer on Windows
                    try {
                        req = new ActiveXObject("Msxml2.XMLHTTP");
                    } catch (e) {
                        try {
                            req = new ActiveXObject("Microsoft.XMLHTTP");
                        } catch (e) {
                            req = false;
                        }
                    }
                }
                var element = document.getElementById(id);
                if (!element) {
                    return;
                }
                if (req) {
                    // Synchronous request, wait till we have it all
                    req.open('GET', url, false);
                    req.send(null);
                    element.innerHTML = req.responseText;
                } else {
                    element.innerHTML = "ERROR: your browser does not support XMLHTTPRequest objects!";
                }
            }

            var i = false;
            var j = true;

            function GetId(id) {
                return document.getElementById(id);
            }

            function move(e) {
                if (i && j) {
                    if (navigator.appName != "Microsoft Internet Explorer") {
                        GetId("curseur").style.left = e.pageX - 720 + "px";
                        GetId("curseur").style.top = e.pageY + 10 + "px";
                    } else {
                        if (document.documentElement.clientWidth > 0) {
                            GetId("curseur").style.left = event.x + document.documentElement.scrollLeft - 720 + "px";
                            GetId("curseur").style.top = 10 + event.y + document.documentElement.scrollTop + "px";
                        } else {
                            GetId("curseur").style.left = event.x + document.body.scrollLeft - 710 + "px";
                            GetId("curseur").style.top = 10 + event.y + document.body.scrollTop + "px";
                        }
                    }
                    j = false;
                }
            }

            function montre(text) {
                if (i == false) {
                    GetId("curseur").style.visibility = "visible";
                    GetId("curseur").innerHTML = text;
                    i = true;
                }
            }

            function cache() {
                if (i == true) {
                    GetId("curseur").style.visibility = "hidden";
                    i = false;
                    j = true;
                }
            }

            document.onmouseover = move;

            ico_lock_off = new Image(64, 64);
            ico_lock_off.src = "/<?php    $objet = $this->_nebuleInstance->newObject(self::DEFAULT_ICON_ENTITY_LOCK);
                $newobj = $objet->findUpdate(true, false);
                echo nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $newobj; ?>";
            ico_lock_on = new Image(64, 64);
            ico_lock_on.src = "/<?php    $objet = $this->_nebuleInstance->newObject(self::DEFAULT_ICON_ENT);
                $newobj = $objet->findUpdate(true, false);
                echo nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $newobj; ?>";

            function hiLite(imgDocID, imgObjName, comment) {
                document.images[imgDocID].src = eval(imgObjName + ".src");
                window.status = comment;
                return true;
            }

            function display_menu(menuid) {
                var test = document.getElementById(menuid).style.display;
                if (test == "block") {
                    document.getElementById(menuid).style.display = "none";
                } else {
                    document.getElementById(menuid).style.display = "block";
                }
            }

            function display_show_block(menuid) {
                document.getElementById(menuid).style.display = "block";
            }

            function display_hide(menuid) {
                document.getElementById(menuid).style.display = "none";
            }

            //-->
        </script>
        <?php
    }

    /**
     * Affichage des scripts JS.
     */
    private function _displayScripts()
    {
        // Cette fonction doit être surchargée par l'application avec ses scripts JS propres.
    }


    /**
     * Affichage de la page par défaut.
     */
    public function display()
    {
        // Lit si la variable GET existe.
        if (filter_has_var(INPUT_GET, self::DEFAULT_INLINE_COMMAND)) {
            $this->_displayInline();
        } else {
            $this->_displayFull();
        }
    }

    /**
     * Affichage de la page complète.
     */
    private function _displayFull()
    {
        global $applicationVersion, $applicationLicence, $applicationWebsite, $applicationName, $applicationSurname, $applicationAuthor;
        ?>
        <!DOCTYPE html>
        <html>
        <head>
            <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
            <title><?php echo $applicationName; ?></title>
            <link rel="icon" type="image/png" href="favicon.png"/>
            <meta name="keywords" content="<?php echo $applicationSurname; ?>"/>
            <meta name="description" content="<?php echo $applicationName; ?>"/>
            <meta name="author" content="<?php echo $applicationAuthor . ' - ' . $applicationWebsite; ?>"/>
            <meta name="licence" content="<?php echo $applicationLicence; ?>"/>
            <?php $this->commonCSS(); ?>
            <style type="text/css">
                #logo img {
                    height: 256px;
                    width: 256px;
                }
            </style>
        </head>
        <body>
        <div class="layout-header">
            <div class="header-left">
                <a href="/?<?php echo Display::DEFAULT_BOOTSTRAP_LOGO_LINK; ?>">
                    <img title="App switch" alt="[]" src="<?php echo Display::DEFAULT_APPLICATION_LOGO; ?>"/>
                </a>
            </div>
            <div class="header-right">
                &nbsp;
            </div>
            <div class="header-center">
                <p>
                    <?php
                    $name = $this->_nebuleInstance->getInstanceEntityInstance()->getFullName();
                    if ($name != $this->_nebuleInstance->getInstanceEntity()) {
                        echo $name;
                    } else {
                        echo '/';
                    }
                    echo '<br />' . $this->_nebuleInstance->getInstanceEntity();
                    ?>
                </p>
            </div>
        </div>
        <div class="layout-footer">
            <div class="footer-center">
                <p>
                    <?php echo $applicationName; ?><br/>
                    <?php echo $applicationVersion; ?><br/>
                    (c) <?php echo $applicationLicence . ' ' . $applicationAuthor; ?> - <a
                            href="http://<?php echo $applicationWebsite; ?>" target="_blank"
                            style="text-decoration:none;"><?php echo $applicationWebsite; ?></a>
                </p>
            </div>
        </div>
        <div class="layout-main">
            <div class="layout-content">
                <img alt="nebule" id="logo" src="<?php echo static::DEFAULT_APPLICATION_LOGO_LIGHT; ?>"/>
            </div>
        </div>
        </body>
        </html>
        <?php
    }

    /**
     * Affichage de la partie de page en ligne.
     */
    private function _displayInline()
    {
        // Cette fonction doit être surchargée par l'application.
    }


    // Emulation des fonctions de traduction.
    public function getLanguageList()
    {
        return array('none');
    }

    public function getLanguageInstanceList()
    {
        return array(null);
    }

    public function getCurrentLanguage()
    {
        return array('none');
    }

    public function getCurrentLanguageInstance()
    {
        return null;
    }

    public function getDefaultLanguage()
    {
        return array('none');
    }

    public function getDefaultLanguageInstance()
    {
        return null;
    }

    public function getTraduction($text)
    {
        return $this->_traductionInstance->getTraduction($text);
    }

    public function setHtlinkObjectPrefix($htlink)
    {
        $this->_htlinkObjectPrefix = $htlink;
    }

    public function setHtlinkGroupPrefix($htlink)
    {
        $this->_htlinkGroupPrefix = $htlink;
    }

    public function setHtlinkConversationPrefix($htlink)
    {
        $this->_htlinkConversationPrefix = $htlink;
    }

    public function setHtlinkEntityPrefix($htlink)
    {
        $this->_htlinkEntityPrefix = $htlink;
    }

    public function setHtlinkCurrencyPrefix($htlink)
    {
        $this->_htlinkCurrencyPrefix = $htlink;
    }

    public function setHtlinkTokenPoolPrefix($htlink)
    {
        $this->_htlinkTokenPoolPrefix = $htlink;
    }

    public function setHtlinkTokenPrefix($htlink)
    {
        $this->_htlinkTokenPrefix = $htlink;
    }

    public function setHtlinkTransactionPrefix($htlink)
    {
        $this->_htlinkTransactionPrefix = $htlink;
    }

    public function setHtlinkWalletPrefix($htlink)
    {
        $this->_htlinkWalletPrefix = $htlink;
    }

    public function echoTraduction($text, $color = '', $arg1 = null, $arg2 = null, $arg3 = null, $arg4 = null, $arg5 = null, $arg6 = null, $arg7 = null, $arg8 = null, $arg9 = null)
    {
        if ($color != '') echo "<font color=\"$color\">";
        echo sprintf(($this->getTraduction($text)), $arg1, $arg2, $arg3, $arg4, $arg5, $arg6, $arg7, $arg8, $arg9);
        if ($color != '') echo '</font>';
    }










    /* --------------------------------------------------------------------------------
	 *  Affichage des messages.
	 * -------------------------------------------------------------------------------- */
    /**
     * Prépare à afficher un message pré-formaté en fonction du type de message.
     *
     * Les types possibles : information, ok, warning, error.
     * Par défaut, le type correspond à un message d'information.
     *
     * @param string $text
     * @param string $type [information|ok|warning|error]
     * @param string $arg1
     * @param string $arg2
     * @param string $arg3
     * @param string $arg4
     * @param string $arg5
     */
    public function convertLineMessage($text, $type = 'information', $arg1 = null, $arg2 = null, $arg3 = null, $arg4 = null, $arg5 = null)
    {
        $iconCssClass = 'iconemoyenpuce';

        // Préparation du type de message à afficher.
        if ($type == 'ok') {
            $messageCssClass = 'information';
            $messageText = '::::INFORMATION';
            $messageIcon = self::DEFAULT_ICON_IOK;
        } elseif ($type == 'warning') {
            $messageCssClass = 'warning';
            $messageText = '::::WARN';
            $messageIcon = self::DEFAULT_ICON_IWARN;
        } elseif ($type == 'error') {
            $messageCssClass = 'error';
            $messageText = '::::ERROR';
            $messageIcon = self::DEFAULT_ICON_IERR;
        } else {
            $messageCssClass = 'information';
            $messageText = '::::INFO';
            $messageIcon = self::DEFAULT_ICON_IINFO;
        }

        return '<div class="' . $messageCssClass . '"><p>'
            . $this->convertUpdateImage($messageIcon, $messageText, $iconCssClass)
            . '&nbsp;' . sprintf($this->_traductionInstance->getTraduction($text), $arg1, $arg2, $arg3, $arg4, $arg5)
            . "</p></div>\n";
    }

    /**
     * Affiche un message pré-formaté en fonction du type de message.
     *
     * Les types possibles : information, ok, warning, error.
     * Par défaut, le type correspond à un message d'information.
     *
     * @param string $text
     * @param string $type [information|ok|warning|error]
     * @param string $arg1
     * @param string $arg2
     * @param string $arg3
     * @param string $arg4
     * @param string $arg5
     */
    public function displayLineMessage($text, $type = 'information', $arg1 = null, $arg2 = null, $arg3 = null, $arg4 = null, $arg5 = null)
    {
        echo $this->convertLineMessage($text, $type, $arg1, $arg2, $arg3, $arg4, $arg5);
    }

    /**
     * Prépare à afficher un message d'information pré-formaté.
     *
     * @param string $text
     * @param string $arg1
     */
    public function convertMessageInformation($text, $arg1 = null)
    {
        return $this->convertLineMessage($text, 'information', $arg1);
    }

    /**
     * Affiche un message d'information pré-formaté.
     *
     * @param string $text
     * @param string $arg1
     */
    public function displayMessageInformation($text, $arg1 = null)
    {
        echo $this->convertLineMessage($text, 'information', $arg1);
    }

    /**
     * Prépare à afficher un message de validation pré-formaté.
     *
     * @param string $text
     * @param string $arg1
     */
    public function convertMessageOk($text, $arg1 = null)
    {
        return $this->convertLineMessage($text, 'ok', $arg1);
    }

    /**
     * Affiche un message de validation pré-formaté.
     *
     * @param string $text
     * @param string $arg1
     */
    public function displayMessageOk($text, $arg1 = null)
    {
        echo $this->convertLineMessage($text, 'ok', $arg1);
    }

    /**
     * Prépare à afficher un message d'avertissement pré-formaté.
     *
     * @param string $text
     * @param string $arg1
     */
    public function convertMessageWarning($text, $arg1 = null)
    {
        return $this->convertLineMessage($text, 'warning', $arg1);
    }

    /**
     * Affiche un message d'avertissement pré-formaté.
     *
     * @param string $text
     * @param string $arg1
     */
    public function displayMessageWarning($text, $arg1 = null)
    {
        echo $this->convertLineMessage($text, 'warning', $arg1);
    }

    /**
     * Prépare à afficher un message d'erreur pré-formaté.
     *
     * @param string $text
     * @param string $arg1
     */
    public function convertMessageError($text, $arg1 = null)
    {
        return $this->convertLineMessage($text, 'error', $arg1);
    }

    /**
     * Affiche un message d'erreur pré-formaté.
     *
     * @param string $text
     * @param string $arg1
     */
    public function displayMessageError($text, $arg1 = null)
    {
        echo $this->convertLineMessage($text, 'error', $arg1);
    }



    /* --------------------------------------------------------------------------------
	 *  Affichage des contenus.
	 * -------------------------------------------------------------------------------- */
    /**
     * Prépare à afficher le contenu d'un objet suivant sont type.
     *
     * @param string|Node $object
     * @param string $size [full|half|small]
     * @return string
     */
    public function convertObjectContentSized($object, $size = 'half', $permitWarnProtected = true)
    {
        $result = '';
        $unlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();
        if ($size != 'full'
            && $size != 'half'
            && $size != 'small'
        ) {
            $size = 'half';
        }
        // Vérifie que c'est un objet.
        if (!is_a($object, 'Node')
            && !is_a($object, 'Group')
            && !is_a($object, 'Entity')
            && !is_a($object, 'Conversation')
            && !is_a($object, 'Currency')
            && !is_a($object, 'TokenPool')
            && !is_a($object, 'Token')
            && !is_a($object, 'Transaction')
            && !is_a($object, 'Wallet')
        ) {
            $object = $this->_nebuleInstance->newObject($object);
        }

        // Détermine si c'est un groupe.
        $isGroup = $object->getIsGroup('all');

        // Détermine si c'est une conversation.
        $isConversation = $object->getIsConversation('all');

        // Détermine si c'est une entité.
        $type = $object->getType('all');
        $objHead = $object->readOneLineAsText(Entity::ENTITY_MAX_SIZE);
        $isEntity = ($type == nebule::REFERENCE_OBJECT_ENTITY
            && strpos($objHead, nebule::REFERENCE_ENTITY_HEADER) !== false
        );

        // Affiche l'objet suivant son type.
        if ($isEntity) {
            if ($object->checkPresent()) {
                if ($size = 'half' || $size = 'full') {
                    if (!is_a($object, 'Entity')) {
                        $object = $this->_nebuleInstance->newEntity($object->getID());
                    }

                    $result = '<div class="text">' . "\n\t<p>"
                        . sprintf($this->_traductionInstance->getTraduction('::UniqueID'),
                            $this->convertInlineObjectColorIcon($object) . ' ' . '<b>' . $object->getID() . "</b>\n")
                        . "\t</p>\n";

                    if ($size = 'full') {
                        // Liste des localisations.
                        $localisations = $object->getLocalisationsID();
                        if (sizeof($localisations) > 0) {
                            $result .= '<table border="0"><tr><td><td>' . $this->_traductionInstance->getTraduction('::EntityLocalisation') . " :</td><td>\n";
                            foreach ($localisations as $localisation) {
                                $locObject = $this->_nebuleInstance->newObject($localisation);
                                $result .= "\t " . $this->convertInlineObjectColorIcon($localisation) . ' '
                                    . $this->convertHypertextLink(
                                        $locObject->readOneLineAsText(),
                                        $locObject->readOneLineAsText()
                                    ) . "<br />\n";
                            }
                            $result .= "</td></tr></table>\n";
                            unset($localisations, $localisation, $locObject);
                        }
                    }
                    $result .= "</div>\n";
                }
            } else {
                $result = $result . $this->convertLineMessage(':::display:content:errorNotAvailable', 'error');
            }
        } elseif ($isGroup) {
            if (!is_a($object, 'Group')) {
                $object = $this->_nebuleInstance->newGroup($object->getID());
            }
            $isClosed = $object->getMarkClosed();

            $result = '<div class="text">' . "\n\t<p>"
                . sprintf($this->_traductionInstance->getTraduction('::UniqueID'),
                    $this->convertInlineObjectColorIcon($object) . ' ' . '<b>' . $object->getID() . "</b>\n");
            if ($isClosed) {
                $result .= "<br />\n" . $this->_traductionInstance->getTraduction('::GroupeFerme') . ".\n";
            } else {
                $result .= "<br />\n" . $this->_traductionInstance->getTraduction('::GroupeOuvert') . ".\n";
            }
            $result .= "\t</p>\n</div>\n";

            unset($isOpened, $isClosed);
        } elseif ($isConversation) {
            if (!is_a($object, 'Conversation')) {
                $object = $this->_nebuleInstance->newConversation($object->getID());
            }
            $isClosed = $object->getMarkClosed();

            $result = '<div class="text">' . "\n\t<p>"
                . sprintf($this->_traductionInstance->getTraduction('::UniqueID'),
                    $this->convertInlineObjectColorIcon($object) . ' ' . '<b>' . $object->getID() . "</b>\n");
            if ($isClosed) {
                $result .= "<br />\n" . $this->_traductionInstance->getTraduction('::ConversationFermee') . ".\n";
            } else {
                $result .= "<br />\n" . $this->_traductionInstance->getTraduction('::ConversationOuverte') . ".\n";
            }
            $result .= "\t</p>\n</div>\n";

            unset($isClosed);
        } else {
            // C'est un objet.
            $result = $this->convertAsObjectContentSized($object, $size, $permitWarnProtected);
        }

        return $result;
    }

    /**
     * Prépare à afficher le contenu d'un objet suivant sont type. Version full.
     *
     * @param string|Node $object
     * @return string
     */
    public function convertObjectContentFull($object, $permitWarnProtected = true)
    {
        return $this->convertObjectContentSized($object, 'full', $permitWarnProtected);
    }

    /**
     * Afficher le contenu d'un objet suivant sont type. Version full.
     *
     * @param string|Node $object
     * @return string
     */
    public function displayObjectContentFull($object, $permitWarnProtected = true)
    {
        echo $this->convertObjectContentSized($object, 'full', $permitWarnProtected);
    }

    /**
     * Prépare à afficher le contenu d'un objet suivant sont type. Version half.
     *
     * @param string|Node $object
     * @return string
     */
    public function convertObjectContentHalf($object, $permitWarnProtected = true)
    {
        return $this->convertObjectContentSized($object, 'half', $permitWarnProtected);
    }

    /**
     * Afficher le contenu d'un objet suivant sont type. Version half.
     *
     * @param string|Node $object
     * @return string
     */
    public function displayObjectContentHalf($object, $permitWarnProtected = true)
    {
        echo $this->convertObjectContentSized($object, 'half', $permitWarnProtected);
    }

    /**
     * Prépare à afficher le contenu d'un objet suivant sont type. Version small.
     *
     * @param string|Node $object
     * @return string
     */
    public function convertObjectContentSmall($object, $permitWarnProtected = true)
    {
        return $this->convertObjectContentSized($object, 'small', $permitWarnProtected);
    }

    /**
     * Afficher le contenu d'un objet suivant sont type. Version small.
     *
     * @param string|Node $object
     * @return string
     */
    public function displayObjectContentSmall($object, $permitWarnProtected = true)
    {
        echo $this->convertObjectContentSized($object, 'small', $permitWarnProtected);
    }


    /**
     * Prépare à afficher le contenu d'un objet comme objet pur.
     *
     * Affiche un objet sans tenir compte de son type nebule (Entity|Group|Conversation).
     * Mais affiche l'objet en fonction de son type mime déclaré.
     *
     * @param string|Node $object
     * @param string $size [full|half|small]
     * @return string
     */
    public function convertAsObjectContentSized($object, $size = 'half', $permitWarnProtected = true)
    {
        $result = '';
        $unlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();
        if ($size != 'full'
            && $size != 'half'
            && $size != 'small'
        ) {
            $size = 'half';
        }
        // Vérifie que c'est un objet.
        if (!is_a($object, 'Node')
            && !is_a($object, 'Group')
            && !is_a($object, 'Entity')
            && !is_a($object, 'Conversation')
            && !is_a($object, 'Currency')
            && !is_a($object, 'TokenPool')
            && !is_a($object, 'Token')
            && !is_a($object, 'Transaction')
            && !is_a($object, 'Wallet')
        ) {
            $object = $this->_nebuleInstance->newObject($object);
        }
        $id = $object->getID();

        // Vérifie si il est protégé
        $protected = $object->getMarkProtected();

        // Extrait les propriétés de l'objet.
        $name = $object->getFullName('all');
        $typemime = $object->getType('all');
        $danger = $object->getMarkDanger();
        $warning = $object->getMarkWarning();
        $ispresent = $object->checkPresent();
        $type = $this->_traductionInstance->getTraduction($typemime);

        // Affichage du contenu.
        if ($danger) {
            $result = $result . $this->convertLineMessage(
                    $this->_traductionInstance->getTraduction(':::display:content:errorBan')
                    . $this->_traductionInstance->getTraduction(':::display:content:errorNotAvailable'),
                    'error');
        } elseif ($protected
            && $id == $object->getProtectedID()
        ) {
            $result = $result . $this->convertLineMessage(
                    $this->_traductionInstance->getTraduction(':::display:content:warningObjectProctected'),
                    'warning');
            $unprotectedObject = $this->_nebuleInstance->newObject($object->getUnprotectedID());
            $unprotectedName = $unprotectedObject->getFullName('all');
            $unprotectedTypemime = $unprotectedObject->getType('all');
            $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($unprotectedObject);
            $result .= '<div class="textAction">' . "\n";
            $result .= ' <div class="oneActionItem" id="selfEntity">' . "\n";
            $result .= '  <div class="oneActionItem-top">' . "\n";
            $result .= '   <div class="oneAction-icon">' . $this->convertObjectColorIcon($unprotectedObject) . "</div>\n";
            $result .= '   <div class="oneAction-title"><p>' . $this->convertHypertextLink($unprotectedName, $htlink) . "</p></div>\n";
            $result .= '   <div class="oneAction-text"><p>' . $this->_traductionInstance->getTraduction($unprotectedTypemime) . "</p></div>\n";
            $result .= "  </div>\n";
            $result .= " </div>\n";
            $result .= ' <div class="oneAction-close"></div>' . "\n";
            $result .= "</div>\n";
            unset($unprotectedObject, $unprotectedName, $unprotectedTypemime, $htlink);
        } elseif ($ispresent) {
            if ($warning) {
                $result = $result . $this->convertLineMessage(
                        $this->_traductionInstance->getTraduction(':::display:content:warningTaggedWarning'),
                        'warning');
            }
            if ($protected
                && $unlocked
                && $permitWarnProtected
            ) {
                $result = $result . $this->convertLineMessage(
                        $this->_traductionInstance->getTraduction(':::display:content:warningObjectProctected'),
                        'warning');
            }
            $divOpen = "<div class=\"textcontent" . $size . "\">\n\t";
            $divClose = "\n</div>\n";
            switch ($typemime) {
                case nebule::REFERENCE_OBJECT_PNG :
                case nebule::REFERENCE_OBJECT_JPEG :
                    $content = $object->getContent(0);
                    if ($content != null) {
                        $result = $result . $divOpen . '<img src="?o=' . $id
                            . '" alt="Image ' . $id . '">' . $divClose;
                    } else {
                        if (!$this->_nebuleInstance->getOption('permitCheckObjectHash')) {
                            $result = $result . $this->convertLineMessage(':::display:content:warningTooBig', 'warning');
                        } else {
                            $result = $result . $this->convertLineMessage(':::display:content:errorNotDisplayable', 'error');
                        }
                    }
                    break;
                case nebule::REFERENCE_OBJECT_TEXT :
                    $content = htmlspecialchars($object->getContent(0));
                    if ($content != null) {
                        $result = $result . $divOpen . '<p>' . $content . '</p>' . $divClose;
                    } else {
                        if (!$this->_nebuleInstance->getOption('permitCheckObjectHash')) {
                            $result = $result . $this->convertLineMessage(':::display:content:warningTooBig', 'warning');
                        } else {
                            $result = $result . $this->convertLineMessage(':::display:content:errorNotDisplayable', 'error');
                        }
                    }
                    unset($content);
                    break;
                case nebule::REFERENCE_OBJECT_ENTITY :
                case nebule::REFERENCE_OBJECT_HTML :
                case nebule::REFERENCE_OBJECT_CSS :
                case nebule::REFERENCE_OBJECT_APP_PHP :
                case nebule::REFERENCE_OBJECT_PHP :
                    $content = htmlspecialchars($object->getContent(0));
                    if ($content != null) {
                        $result = $result . $divOpen . '<pre>' . $content . '</pre>' . $divClose;
                    } else {
                        if (!$this->_nebuleInstance->getOption('permitCheckObjectHash')) {
                            $result = $result . $this->convertLineMessage(':::display:content:warningTooBig', 'warning');
                        } else {
                            $result = $result . $this->convertLineMessage(':::display:content:errorNotDisplayable', 'error');
                        }
                    }
                    unset($content);
                    break;
                case nebule::REFERENCE_OBJECT_MP3 :
                    $content = $object->getContent(0);
                    if ($content != null) {
                        $result = $result . $divOpen . '<br /><audio controls><source src="?o=' . $id . '" type="audio/mp3" />' . $this->_traductionInstance->getTraduction(':::warn_NoAudioTagSupport') . '</audio><br />' . $divClose;
                    } else {
                        if (!$this->_nebuleInstance->getOption('permitCheckObjectHash')) {
                            $result = $result . $this->convertLineMessage(':::display:content:warningTooBig', 'warning');
                        } else {
                            $result = $result . $this->convertLineMessage(':::display:content:errorNotDisplayable', 'error');
                        }
                    }
                    break;
                case nebule::REFERENCE_OBJECT_OGG :
                    $content = $object->getContent(0);
                    if ($content != null) {
                        $result = $result . $divOpen . '<br /><audio controls><source src="?o=' . $id . '" type="audio/ogg" />' . $this->_traductionInstance->getTraduction(':::warn_NoAudioTagSupport') . '</audio><br />' . $divClose;
                    } else {
                        if (!$this->_nebuleInstance->getOption('permitCheckObjectHash')) {
                            $result = $result . $this->convertLineMessage(':::display:content:warningTooBig', 'warning');
                        } else {
                            $result = $result . $this->convertLineMessage(':::display:content:errorNotDisplayable', 'error');
                        }
                    }
                    break;
                case nebule::REFERENCE_OBJECT_CRYPT_RSA :
                    $result = $result . $this->convertLineMessage('Chiffré, non affichable.', 'warning');
                    break;
                default :
                    $result = $result . $this->convertLineMessage('Non affichable.', 'warning');
                    break;
            }
        } else {
            $result = $result . $this->convertLineMessage(':::display:content:errorNotAvailable', 'error');
        }

        return $result;
    }

    /**
     * Prépare à afficher le contenu d'un objet comme objet pur. Version full.
     *
     * @param string|Node $object
     * @return string
     */
    public function convertAsObjectContentFull($object, $permitWarnProtected = true)
    {
        return $this->convertAsObjectContentSized($object, 'full', $permitWarnProtected);
    }

    /**
     * Afficher le contenu d'un objet comme objet pur. Version full.
     *
     * @param string|Node $object
     * @return string
     */
    public function displayAsObjectContentFull($object, $permitWarnProtected = true)
    {
        echo $this->convertAsObjectContentSized($object, 'full', $permitWarnProtected);
    }

    /**
     * Prépare à afficher le contenu d'un objet comme objet pur. Version half.
     *
     * @param string|Node $object
     * @return string
     */
    public function convertAsObjectContentHalf($object, $permitWarnProtected = true)
    {
        return $this->convertAsObjectContentSized($object, 'half', $permitWarnProtected);
    }

    /**
     * Afficher le contenu d'un objet comme objet pur. Version half.
     *
     * @param string|Node $object
     * @return string
     */
    public function displayAsObjectContentHalf($object, $permitWarnProtected = true)
    {
        echo $this->convertAsObjectContentSized($object, 'half', $permitWarnProtected);
    }

    /**
     * Prépare à afficher le contenu d'un objet comme objet pur. Version small.
     *
     * @param string|Node $object
     * @return string
     */
    public function convertAsObjectContentSmall($object, $permitWarnProtected = true)
    {
        return $this->convertAsObjectContentSized($object, 'small', $permitWarnProtected);
    }

    /**
     * Afficher le contenu d'un objet comme objet pur. Version small.
     *
     * @param string|Node $object
     * @return string
     */
    public function displayAsObjectContentSmall($object, $permitWarnProtected = true)
    {
        echo $this->convertAsObjectContentSized($object, 'small', $permitWarnProtected);
    }

    /**
     * Prépare à afficher un objet comme image avec éventuellement un texte et un identifiant CSS.
     *
     * @param Node|Node $object
     * @param string $alt
     * @param string $class
     * @param string $id
     * @param string $args
     * @return string
     */
    public function convertImage($object, $alt = '', $class = '', $id = '', $args = '')
    {
        // Récupère une instance de l'objet.
        if (!is_a($object, 'Node')) {
            $object = $this->_nebuleInstance->newObject($object);
        }

        if ($object->getID() == '0') {
            return '';
        }

        /**
         * @var string $result
         */
        $result = '<img src="/' . nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $object->getID() . '"';

        if ($alt == '') {
            $alt = $object->getID();
        }
        $alt = $this->_traductionInstance->getTraduction($alt);
        $result .= ' alt="' . $alt . '" title="' . $alt . '"';

        if ($class != '') {
            $result .= ' class="' . $class . '"';
        }

        if ($id != '') {
            $result .= ' id="' . $id . '"';
        }

        if ($args != '') {
            $result .= ' ' . $args;
        }

        $result .= ' />';
        return $result;
    }

    /**
     * Prépare à afficher un objet comme image avec éventuellement un texte et un identifiant CSS.
     *
     * @param Node|Node $object
     * @return string
     */
    public function convertImageURL($object)
    {
        // Récupère une instance de l'objet.
        if (!is_a($object, 'Node')) {
            $object = $this->_nebuleInstance->newObject($object);
        }

        if ($object->getID() == '0') {
            return '';
        }

        $obj = $object->getID();
        return nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $obj;
    }

    /**
     * Affiche un objet comme image avec éventuellement un texte et un identifiant CSS.
     *
     * @param Node|Node $object
     * @param string $alt
     * @param string $class
     * @param string $id
     * @param string $args
     * @return string
     */
    public function displayImage($object, $alt = '', $class = '', $id = '', $args = '')
    {
        echo $this->convertImage($object, $alt, $class, $id, $args);
    }

    /**
     * Prépare à un objet comme image avec éventuellement un texte et un identifiant CSS.
     * Une recherche préalable est faite pour trouver la mise à jour la plus récente de l'objet.
     *
     * Si l'objet commence par data: c'est une image encodée en base64.
     * Retourne dans ce cas un affichage d'image.
     *
     * @param string|Node $object
     * @param string $alt
     * @param string $class
     * @param string $id
     * @param string $args
     * @return string
     */
    public function convertUpdateImage($object, $alt = '', $class = '', $id = '', $args = '')
    {
        // Retourne un résulat tout de suite si l'objet est une image encodée.
        if (substr($object, 0, 5) == 'data:') {
            // @todo alt class id args...
            return '<img src="' . $object . '" />';
        }

        // Récupère une instance de l'objet.
        if (!is_a($object, 'Node')) {
            $object = $this->_nebuleInstance->newObject($object);
        }

        if ($object->getID() == '0') {
            return '';
        }

        $newobj = $this->_getImageUpdate($object);

        if ($newobj == $object->getID()) {
            $newObjectInstance = $object;
        } else {
            $newObjectInstance = $this->_nebuleInstance->newObject($newobj);
        }

        return $this->convertImage($newObjectInstance, $alt, $class, $id, $args);
    }

    /**
     * Affiche un objet comme image avec éventuellement un texte et un identifiant CSS.
     * Une recherche préalable est faite pour trouver la mise à jour la plus récente de l'objet.
     *
     * @param string|Node $object
     * @param string $alt
     * @param string $id
     * @param string $args
     * @return string
     */
    public function displayUpdateImage($object, $alt = '', $class = '', $id = '', $args = '')
    {
        echo $this->convertUpdateImage($object, $alt, $class, $id, $args);
    }

    /**
     * Prépare à un objet comme image avec éventuellement un texte et un identifiant CSS.
     * L'objet est un objet virtuel qui permet juste d'adresser l'image attendu.
     * @param string|Node $object
     * @param string $alt
     * @param string $class
     * @param string $id
     * @param string $args
     * @return string
     * @todo
     *
     */
    public function convertReferenceImage($object, $alt = '', $class = '', $id = '', $args = '')
    {
        // Récupère une instance de l'objet.
        if (!is_a($object, 'Node')) {
            $object = $this->_nebuleInstance->newObject($object);
        }

        if ($object->getID() == '0') {
            return '';
        }

        $newobj = $this->_getImageByReference($object);

        if ($newobj == $object->getID()) {
            $newObjectInstance = $object;
        } else {
            $newObjectInstance = $this->_nebuleInstance->newObject($newobj);
        }

        return $this->convertImage($newObjectInstance, $alt, $class, $id, $args);
    }

    /**
     * Affiche un objet comme image avec éventuellement un texte et un identifiant CSS.
     * L'objet est un objet virtuel qui permet juste d'adresser l'image attendu.
     *
     * @param string|Node $object
     * @param string $alt
     * @param string $class
     * @param string $id
     * @param string $args
     * @return string
     */
    public function displayReferenceImage($object, $alt = '', $class = '', $id = '', $args = '')
    {
        echo $this->convertReferenceImage($object, $alt, $class, $id, $args);
    }



    /* --------------------------------------------------------------------------------
	 *  Fonctions internes.
	 * -------------------------------------------------------------------------------- */
    /**
     * Retourne le nom tronqué d'une entité.
     *
     * @param string $name
     * @param int $maxsize
     * @return string
     */
    public function truncateName($name, $maxsize)
    {
        return $this->_truncateName($name, $maxsize);
    }

    /**
     * Retourne le nom tronqué d'une entité.
     *
     * @param string $name
     * @param int $maxsize
     * @return string
     */
    private function _truncateName($name, $maxsize)
    {
        if ($maxsize == 0 || $maxsize > $this->_nebuleInstance->getOption('displayNameSize'))
            $maxsize = $this->_nebuleInstance->getOption('displayNameSize');
        if ($maxsize < 4)
            $maxsize = 4;
        if (strlen($name) > $maxsize)
            $name = substr($name, 0, ($maxsize - 3)) . '...';
        return $name;
    }

    /**
     * Prépare un lien par défaut pour un objet ou un groupe ou une conversation ou une entité si aucun lien hypertexte n'est donné.
     *
     * @param Node|Entity|Group|Conversation $object
     * @param string $htlink
     * @return string
     */
    public function prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink = '')
    {
        return $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
    }

    /**
     * Prépare un lien par défaut pour un objet ou un groupe ou une conversation ou une entité si aucun lien hypertexte n'est donné.
     *
     * @param Node|Entity|Group|Conversation $object
     * @param string $htlink
     * @return string
     */
    private function _prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink = '')
    {
        if ($htlink != '') {
            return $htlink;
        }
        if (is_a($object, 'Entity')) {
            return $this->_htlinkEntityPrefix . $object->getID();
        } elseif (is_a($object, 'Conversation')) {
            return $this->_htlinkConversationPrefix . $object->getID();
        } elseif (is_a($object, 'Group')) {
            return $this->_htlinkGroupPrefix . $object->getID();
        } elseif (is_a($object, 'Wallet')) {
            return $this->_htlinkWalletPrefix . $object->getID();
        } elseif (is_a($object, 'Transaction')) {
            return $this->_htlinkTransactionPrefix . $object->getID();
        } elseif (is_a($object, 'Token')) {
            return $this->_htlinkTokenPrefix . $object->getID();
        } elseif (is_a($object, 'TokenPool')) {
            return $this->_htlinkTokenPoolPrefix . $object->getID();
        } elseif (is_a($object, 'Currency')) {
            return $this->_htlinkCurrencyPrefix . $object->getID();
        }
        return $this->_htlinkObjectPrefix . $object->getID();
    }



    /* --------------------------------------------------------------------------------
	 *  Affichage des liens hypertextes.
	 * -------------------------------------------------------------------------------- */
    /**
     * ???
     * @param string $htlink
     * @return string
     * @todo
     *
     */
    public function convertHypertextShortLink($htlink)
    {
        if ($htlink == '') {
            return '';
        }
        return $htlink;
    }

    /**
     * Convertit un texte et un lien web en un lien préformaté HTML.
     *
     * @param string $text
     * @param string $htlink
     * @param string $color
     * @param string $class
     * @param string $id
     * @return string
     */
    public function convertHypertextLink($text, $htlink, $color = '', $class = '', $id = '')
    {
        if ($text == '') {
            return '';
        }

        if ($htlink == '') {
            return $text;
        }

        if ($color != '') {
            $color = ' style="background:' . $color . ';"';
        }

        if ($class != '') {
            $class = ' class="' . $class . '"';
        }

        if ($id != '') {
            $id = ' id="' . $id . '"';
        }

        $text = $this->_traductionInstance->getTraduction($text);
        return '<a href="' . $htlink . '"' . $color . $class . $id . '>' . $text . '</a>';
    }

    /**
     * Affiche un texte et un lien web en un lien préformaté HTML.
     *
     * @param string $text
     * @param string $htlink
     * @param string $color
     * @param string $class
     * @param string $id
     * @return string
     */
    public function displayHypertextLink($text, $htlink, $color = '', $class = '', $id = '')
    {
        echo $this->convertHypertextLink($text, $htlink, $color, $class, $id);
    }

    /**
     * Convertit une date standard en une date facile à lire.
     *
     * @param string $date
     * @return string
     */
    public function convertDate($date)
    {
        if (substr($date, 10, 1) == 'T') {
            $ret = substr($date, 8, 2) . '/' . substr($date, 5, 2) . '/' . substr($date, 0, 4) . ' ' . substr($date, 11, 2) . 'h' . substr($date, 14, 2) . "'<sub>" . substr($date, 17, 2) . "''</sub>";
        } elseif (substr($date, 4, 1) == '-') {
            $ret = substr($date, 8, 2) . '/' . substr($date, 5, 2) . '/' . substr($date, 0, 4);
        } else {
            $ret = substr($date, 6, 2) . '/' . substr($date, 4, 2) . '/' . substr($date, 0, 4) . ' ' . substr($date, 8, 2) . 'h' . substr($date, 10, 2) . "'<sub>" . substr($date, 12, 2) . "''</sub>";
        }
        return $ret;
    }

    /**
     * Affiche une date standard en une date facile à lire.
     *
     * @param string $date
     */
    public function displayDate($date)
    {
        echo $this->convertDate($date);
    }



    /* --------------------------------------------------------------------------------
	 *  Affichage des objets.
	 * -------------------------------------------------------------------------------- */
    /**
     * Tableau de cache des mises à jours d'icônes déjà recherchées.
     *
     * @var array
     */
    private $_cacheIconUpdate = array();

    /**
     * Recherche la mise à jour de l'objet d'une image.
     *
     * Fait une mise en cache du résultat.
     *
     * @param string|Node $object
     * @param boolean $useBuffer
     * @return string
     */
    private function _getImageUpdate($object, $useBuffer = true)
    {
        if (!$this->_nebuleInstance->getOption('permitSessionBuffer')) {
            $useBuffer = false;
        }

        // Récupère une instance de l'objet.
        if (!is_a($object, 'Node')) {
            $object = $this->_nebuleInstance->newObject($object);
        }

        if ($object->getID() == '0') {
            return '';
        }

        // Si présent dans le cache, utilise la valeur stockée.
        if ($useBuffer
            && isset($this->_cacheIconUpdate[$object->getID()])
        ) {
            return $this->_cacheIconUpdate[$object->getID()];
        }

        $update = $object->findUpdate(true, false);

        // Mémorise le résultat.
        if ($useBuffer) {
            $this->_cacheIconUpdate[$object->getID()] = $update;
        }

        return $update;
    }

    /**
     * Tableau de cache des icônes déjà recherchées par référence.
     *
     * @var array
     */
    private $_cacheIconByReference = array();

    /**
     * Recherche par référence une image.
     *
     * Fait une mise en cache du résultat.
     *
     * @param string|Node $reference
     * @param boolean $useBuffer
     * @return string
     */
    private function _getImageByReference($reference, $useBuffer = true)
    {
        if (!$this->_nebuleInstance->getOption('permitSessionBuffer')) {
            $useBuffer = false;
        }

        // Récupère une instance de l'objet.
        if (!is_a($reference, 'Node')) {
            $reference = $this->_nebuleInstance->newObject($reference);
        }

        if ($reference->getID() == '0') {
            return '';
        }

        // Si présent dans le cache, utilise la valeur stockée.
        if ($useBuffer
            && isset($this->_cacheIconByReference[$reference->getID()])
        ) {
            return $this->_cacheIconByReference[$reference->getID()];
        }

        // Sinon, lit l'id de l'objet référencé.
        $update = $reference->getReferencedObjectID(nebule::REFERENCE_NEBULE_OBJET_IMAGE_REFERENCE, 'myself');
        if ($update == $reference->getID()) {
            $update = $reference->getReferencedObjectID(nebule::REFERENCE_NEBULE_OBJET_IMAGE_REFERENCE, 'strict');
        }

        // Mémorise le résultat.
        if ($useBuffer) {
            $this->_cacheIconByReference[$reference->getID()] = $update;
        }

        return $update;
    }

    /**
     * Prépare l'image de l'icône sans lien hypertexte ni encapsulation html img.
     *
     * Cette fonction est dédiée aux icônes de l'interface dont les objets sont par défaut disponibles.
     * Mais les mises à jours de ces objets ne le sont pas forcément.
     *
     * @param string $icon
     * @return string
     */
    public function prepareIcon($icon)
    {
        $updateIcon = $this->_getImageUpdate($icon);
        if ($updateIcon == $icon) {
            return nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $icon;
        }
        return '?' . nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '=' . $updateIcon;
    }

    /**
     * Affiche l'image d'une icône sans lien hypertexte et avec encapsulation html img.
     *
     * @param string $icon
     * @param string $class
     * @return null
     */
    public function displayIcon($icon, $title = '', $class = '')
    {
        echo $this->convertIcon($icon, $title, $class);
    }

    /**
     * Prépare l'image d'une icône sans lien hypertexte et avec encapsulation html img.
     *
     * @param string $icon
     * @param string $class
     * @return string
     */
    public function convertIcon($icon, $title = '', $class = '')
    {
        $image = $this->prepareIcon($icon);
        if ($title != '') {
            $title = 'title="' . $title . '" ';
        }
        if ($class != '') {
            $class = 'class="' . $class . '" ';
        }
        return '<img ' . $title . 'alt="[]" src="' . $image . '" ' . $class . '/>';
    }

    /**
     * Prépare l'image de l'icône pour un objet sans lien hypertexte.
     *
     * @param Node/entity $object
     * @param string $icon
     * @param string $class
     * @return string
     */
    private function _prepareObjectIcon($object, $icon, $class = '')
    {
        $color = $object->getPrimaryColor();
        $title = $object->getFullName('all');
        $image = $this->prepareIcon($icon);
        if ($class != '') {
            $class = 'class="' . $class . '" ';
        }
        return '<img title="' . $title . '" style="background:#' . $color . ';" alt="[]" src="' . $image . '" ' . $class . '/>';
    }

    /**
     * Prépare l'image du carré de couleur de l'objet ou de l'entité sans lien hypertexte.
     *
     * @param Node/entity $object
     * @param string $class
     * @param string $title
     * @return string
     */
    private function _prepareObjectColor($object, $class = '', $title = '')
    {
        $color = $object->getPrimaryColor();
        if ($title == '') {
            $title = $object->getFullName('all');
        }
        if ($class != '') {
            $class = 'class="' . $class . '" ';
        }
        return '<img title="' . $title . '" style="background:#' . $color . ';" alt="[]" src="o/' . self::DEFAULT_ICON_ALPHA_COLOR . '" ' . $class . '/>';
    }

    /**
     * Prépare l'image de l'objet ou de l'entité sans lien hypertexte.
     *
     * @param Node/entity $object
     * @param string $class
     * @return string
     */
    private function _prepareObjectFace($object, $class = '')
    {
        $color = $object->getPrimaryColor();
        $title = $object->getFullName('all');
        if (is_a($object, 'Entity')) {
            $faceID = $object->getFaceID(64);
            if ($faceID != '0') {
                $image = '?o=' . $faceID;
            } else {
                $image = 'o/' . $this->_getImageUpdate(self::DEFAULT_ICON_USER);
            }
            unset($faceID);
        } elseif (is_a($object, 'Conversation')) {
            $image = 'o/' . $this->_getImageUpdate(self::DEFAULT_ICON_CVTOBJ);
        } elseif (is_a($object, 'Group')) {
            $image = 'o/' . $this->_getImageUpdate(self::DEFAULT_ICON_GRPOBJ);
        } else {
            $image = 'o/' . $this->_getImageUpdate(self::DEFAULT_ICON_LO);
        }
        if ($class != '') {
            $class = 'class="' . $class . '" ';
        }
        return '<img title="' . $title . '" style="background:#' . $color . ';" alt="[]" src="' . $image . '" ' . $class . '/>';
    }


    /**
     * Le CSS de la fonction getDisplayObject().
     *
     * @return null
     */
    private function _getDisplayObjectCSS()
    {
        ?>

        <style type="text/css">
            /* CSS de la fonction getDisplayObject(). */
            .layoutObject {
                margin: 5px 0 0 5px;
                border: 0;
                background: none;
                display: inline-block;
                vertical-align: top;
            }

            .objectDisplayTiny {
                font-size: 16px;
            }

            .objectDisplaySmall {
                font-size: 32px;
            }

            .objectDisplayMedium {
                font-size: 64px;
            }

            .objectDisplayLarge {
                font-size: 128px;
            }

            .objectDisplayFull {
                font-size: 256px;
            }

            .objectTitle a:link, .objectTitle a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #000000;
            }

            .objectTitle a:hover, .objectTitle a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #000000;
            }

            .objectTitleTiny {
                height: 16px;
                font-size: 16px;
                border: 0;
            }

            .objectTitleSmall {
                height: 32px;
                font-size: 32px;
                border: 0;
            }

            .objectTitleMedium {
                height: 64px;
                font-size: 64px;
                border: 0;
            }

            .objectTitleLarge {
                height: 128px;
                font-size: 128px;
                border: 0;
            }

            .objectTitleFull {
                height: 256px;
                font-size: 256px;
                border: 0;
            }

            .objectTitleText {
                background: rgba(255, 255, 255, 0.5);
            }

            .objectTitleTinyText {
                height: 16px;
                background: none;
            }

            .objectTitleSmallText {
                height: 30px;
                text-align: left;
                padding: 1px 0 1px 1px;
                color: #000000;
            }

            .objectTitleMediumText {
                height: 58px;
                text-align: left;
                padding: 3px 0 3px 3px;
                color: #000000;
            }

            .objectTitleLargeText {
                height: 122px;
                text-align: left;
                padding: 3px 0 3px 3px;
                color: #000000;
            }

            .objectTitleFullText {
                height: 246px;
                text-align: left;
                padding: 5px 0 5px 5px;
                color: #000000;
            }

            .objectTitleTinyRefs {
                visibility: hidden;
            }

            .objectTitleTinyRefs img {
                visibility: hidden;
            }

            .objectTitleSmallRefs {
                height: 12px;
                line-height: 12px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 9px;
            }

            .objectTitleSmallRefs img {
                height: 12px;
                width: 12px;
            }

            .objectTitleMediumRefs {
                height: 16px;
                line-height: 16px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 12px;
            }

            .objectTitleMediumRefs img {
                height: 16px;
                width: 16px;
            }

            .objectTitleLargeRefs {
                height: 16px;
                line-height: 16px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 12px;
            }

            .objectTitleLargeRefs img {
                height: 16px;
                width: 16px;
            }

            .objectTitleFullRefs {
                height: 32px;
                line-height: 32px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 20px;
            }

            .objectTitleFullRefs img {
                height: 32px;
                width: 32px;
            }

            .objectTitleTinyName {
                height: 1rem;
                line-height: 1rem;
                font-size: 1rem;
            }

            .objectTitleSmallName {
                height: 16px;
                line-height: 16px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 14px;
            }

            .objectTitleMediumName {
                height: 24px;
                line-height: 24px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 20px;
            }

            .objectTitleLargeName {
                height: 32px;
                line-height: 32px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 28px;
            }

            .objectTitleFullName {
                height: 64px;
                line-height: 64px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 40px;
            }

            .objectTitleID {
                height: 16px;
                font-size: 10px;
                overflow: hidden;
            }

            .objectTitleTinyFlags {
                visibility: hidden;
            }

            .objectTitleTinyFlags img {
                visibility: hidden;
            }

            .objectTitleSmallFlags {
                visibility: hidden;
            }

            .objectTitleSmallFlags img {
                visibility: hidden;
            }

            .objectTitleMediumFlags {
                height: 16px;
                font-size: 16px;
            }

            .objectTitleMediumFlags img {
                height: 16px;
                width: 16px;
                margin: 0 1px 0 0;
                float: left;
            }

            .objectTitleLargeFlags {
                height: 16px;
                font-size: 16px;
            }

            .objectTitleLargeFlags img {
                height: 16px;
                width: 16px;
                margin: 0 2px 0 0;
                float: left;
            }

            .objectTitleFullFlags {
                height: 32px;
                font-size: 32px;
            }

            .objectTitleFullFlags img {
                height: 32px;
                width: 32px;
                margin: 0 4px 0 0;
                float: left;
            }

            .objectTitleIcons img {
                height: 1em;
                width: 1em;
                float: left;
            }

            .objectTitleIconsInline img {
                height: 1em;
                width: 1em;
            }

            .objectTitleIconsApp {
                height: 1em;
                width: 1em;
                float: left;
            }

            .objectTitleIconsApp div {
                overflow: hidden;
                font-size: 12px;
                text-align: left;
                font-weight: none;
                margin: 3px;
                color: #ffffff;
            }

            .objectTitleIconsAppShortname {
                font-size: 18px;
            }

            .objectTitleIconsAppTitle {
                font-size: 11px;
            }

            .objectTitleText0 {
                margin-left: 0;
            }

            .objectTitleText1 {
                margin-left: 1em;
            }

            .objectTitleText2 {
                margin-left: 2em;
            }

            .objectTitleStatus {
                height: 1em;
                line-height: 1em;
                overflow: hidden;
                white-space: nowrap;
                font-weight: bold;
                text-align: right;
                padding-right: 2px;
            }

            .objectDisplayTinyShort {
            }

            .objectDisplaySmallShort {
                width: 8em;
            }

            .objectDisplayMediumShort {
                width: 6em;
            }

            .objectDisplayLargeShort {
                width: 5em;
            }

            .objectDisplayFullShort {
                width: 4em;
            }

            .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                width: 256px;
            }

            @media screen and (min-width: 320px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 310px;
                }
            }

            @media screen and (min-width: 480px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 470px;
                }
            }

            @media screen and (min-width: 600px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 590px;
                }
            }

            @media screen and (min-width: 768px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 758px;
                }
            }

            @media screen and (min-width: 1024px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 1014px;
                }
            }

            @media screen and (min-width: 1200px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 1190px;
                }
            }

            @media screen and (min-width: 1600px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 1590px;
                }
            }

            @media screen and (min-width: 1920px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 1910px;
                }
            }

            @media screen and (min-width: 2048px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 2038px;
                }
            }

            @media screen and (min-width: 2400px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 2390px;
                }
            }

            @media screen and (min-width: 3840px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 3830px;
                }
            }

            @media screen and (min-width: 4096px) {
                .objectDisplayTinyLong, .objectDisplaySmallLong, .objectDisplayMediumLong, .objectDisplayLargeLong, .objectDisplayFullLong {
                    width: 4086px;
                }
            }

            .objectContent {
                font-size: 0.8rem;
                border: 0;
                padding: 3px;
                margin: 0;
                color: #000000;
                overflow: auto;
            }

            .objectContentShort {
                width: 378px;
                max-height: 378px;
            }

            .objectContentText {
                background: rgba(255, 255, 255, 0.666);
                text-align: left;
            }

            .objectContentImage {
                background: rgba(255, 255, 255, 0.12);
                text-align: center;
            }

            .objectContentImage img {
                height: auto;
                max-width: 100%;
            }

            .objectFlagOn {
                background: #00ff20;
            }

            .objectTitleMenuContentLayout {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.33);
                z-index: 100;
                display: none;
                font-size: 0;
            }

            .objectTitleMenuContent {
                position: fixed;
                top: 10%;
                left: 10%;
                width: 80%;
                background: rgba(240, 240, 240, 0.5);
                padding: 16px;
            }

            .objectTitleMenuContent .objectTitleTinyLong, .objectTitleMenuContent .objectTitleSmallLong, .objectTitleMenuContent .objectTitleMediumLong, .objectTitleMenuContent .objectTitleLargeLong, .objectTitleMenuContent .objectTitleFullLong {
                width: 100%;
            }

            .objectTitleMenuContent .objectTitleText {
                background: rgba(255, 255, 255, 0.66);
            }

            .objectTitleMenuContentIcons {
                height: 64px;
                width: 128px;
            }

            .objectTitleMenuContentIcons img {
                height: 64px;
                width: 64px;
            }

            .objectMenuContent {
                background: rgba(255, 255, 255, 0.2);
                padding-top: 4px;
            }

            .objectMenuContentMsg {
                background-origin: border-box;
                font-size: 14px;
                text-align: left;
                margin-top: 1px;
                width: 100%;
                overflow: hidden;
                white-space: normal;
                min-height: 16px;
            }

            .objectMenuContentMsg img {
                height: 16px;
                width: 16px;
                margin: 0 2px 0 0;
                float: left;
            }

            .objectMenuContentMsgOK {
                background: #103020;
                color: #ffffff;
            }

            .objectMenuContentMsgWarn {
                background: #ffe080;
                color: #ff8000;
            }

            .objectMenuContentMsgError {
                background: #ffa0a0;
                color: #ff0000;
                font-family: monospace;
            }

            .objectMenuContentMsgInfo {
                background: rgba(0, 0, 0, 0.4);
                color: #ffffff;
            }

            .objectMenuContentMsgID {
                background: rgba(255, 255, 255, 0.4);
                color: #000000;
                font-family: monospace;
                font-size: 9px;
                overflow: hidden;
                white-space: nowrap;
                min-height: 4px;
            }

            .objectMenuContentMsgEmotions {
                background: rgba(255, 255, 255, 0.1);
                color: #000000;
                text-align: center;
                min-height: 24px;
            }

            .objectMenuContentMsgEmotions img {
                height: 24px;
                width: 24px;
                margin: 0 1px 0 3px;
                float: none;
            }

            .objectMenuContentMsgtargetObject {
                background: rgba(0, 0, 0, 0.4);
                font-size: 12px;
                color: #ffffff;
                white-space: nowrap;
            }

            .objectMenuContentMsgtargetObject img {
                height: 16px;
                width: 16px;
                margin: 0;
                float: none;
            }

            .objectMenuContentMsgtargetObject a:link, .objectMenuContentMsgtargetObject a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #ffffff;
            }

            .objectMenuContentMsgtargetObject a:hover, .objectMenuContentMsgtargetObject a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #ffffff;
            }

            .objectMenuContentActions {
                margin: 1px 0 0 0;
                min-height: 32px;
                padding-top: 5px;
                background: rgba(255, 255, 255, 0.2);
            }

            .objectMenuContentActionsTinyShort {
            }

            .objectMenuContentActionsSmallShort {
                width: 256px;
            }

            .objectMenuContentActionsMediumShort {
                width: 384px;
            }

            .objectMenuContentActionsLargeShort {
                width: 640px;
            }

            .objectMenuContentActionsFullShort {
                width: 1024px;
            }

            .objectMenuContentActionsTinyLong, .objectMenuContentActionsSmallLong, .objectMenuContentActionsMediumLong, .objectMenuContentActionsLargeLong, .objectMenuContentActionsFullLong {
                width: 100%;
            }

            .objectMenuContentAction {
                height: 64px;
                display: inline-block;
                margin-top: 5px;
                margin-left: 5px;
                text-align: left;
            }

            /* Correction à vérifier */
            .objectMenuContentActionNoJS {
                height: 32px;
                display: inline-block;
                margin-bottom: 1px;
                text-align: left;
            }

            .objectMenuContentActionTinyShort {
            }

            .objectMenuContentActionSmallShort {
                width: 256px;
            }

            .objectMenuContentActionMediumShort {
                width: 384px;
            }

            .objectMenuContentActionLargeShort {
                width: 210px;
                margin-right: 5px;
            }

            .objectMenuContentActionFullShort {
                width: 251px;
                margin-right: 5px;
            }

            .objectMenuContentActionTinyLong, .objectMenuContentActionSmallLong, .objectMenuContentActionMediumLong, .objectMenuContentActionLargeLong, .objectMenuContentActionFullLong {
                width: 251px;
            }

            .objectMenuContentActionSelf {
                background: rgba(255, 255, 255, 0.5);
                color: #000000;
            }

            .objectMenuContentActionSelf a:link, .objectMenuContentActionSelf a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #000000;
            }

            .objectMenuContentActionSelf a:hover, .objectMenuContentActionSelf a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #000000;
            }

            .objectMenuContentActionType {
                background: rgba(0, 0, 0, 0.66);
                color: #ffffff;
            }

            .objectMenuContentActionType a:link, .objectMenuContentActionType a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #ffffff;
            }

            .objectMenuContentActionType a:hover, .objectMenuContentActionType a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #ffffff;
            }

            .objectMenuContentAction-icon, .objectMenuContentAction-iconNoJS {
                float: left;
                margin-right: 5px;
            }

            .objectMenuContentAction-icon img {
                height: 64px;
                width: 64px;
            }

            .objectMenuContentAction-iconNoJS img {
                height: 32px;
                width: 32px;
            }

            .objectMenuContentAction-modname p {
                font-size: 0.7rem;
                font-style: italic;
                font-weight: normal;
                overflow: hidden;
                white-space: nowrap;
            }

            .objectMenuContentAction-title p {
                font-size: 1.1rem;
                font-weight: bold;
                overflow: hidden;
                white-space: nowrap;
            }

            .objectMenuContentAction-text p {
                font-size: 0.8rem;
                font-weight: normal;
                overflow: hidden;
                white-space: nowrap;
            }

            .objectMenuContentAction-close {
                height: 1px;
                clear: both;
            }
        </style>
        <?php
    }

    /**
     * Retourne la représentation html de l'objet en fonction des paramètres passés.
     *
     * Les paramètres d'activation de contenus :
     * - enableDisplayColor : Affiche le carré de couleur.
     *     Par défaut true : affiche le carré de couleur.
     *     enableDisplayIconApp doit être à false.
     *     Boolean
     * - enableDisplayIcon : Affiche le carré avec l'image attaché à l'objet ou l'icône de son type sur la couleur de l'objet en fond.
     *     Par défaut true : affiche le carré de l'image/icône.
     *     enableDisplayIconApp doit être à false.
     *     Boolean
     * - enableDisplayIconApp : Affiche le carré de couleur avec le nom long et court d'une application.
     *     Par défaut true : affiche le carré de couleur avec le nom.
     *     Boolean
     * - enableDisplayRefs : Affiche le(s) référence(s) de l'objet (signataire du lien).
     *     enableDisplayName doit être à true.
     *     Par défaut false : n'affiche pas la référence.
     *     Boolean
     * - enableDisplayName : Affiche le nom de l'objet.
     *     Par défaut true : affiche le nom.
     *     Boolean
     * - enableDisplayID : Affiche l'ID de l'objet.
     *     Par défaut false : n'affiche pas l'ID.
     *     Boolean
     * - enableDisplayFlags : Affiche les icônes d'état de l'objet (protection...).
     *     enableDisplayName doit être à true.
     *     Par défaut false : n'affiche pas les icônes d'état.
     *     Boolean
     * - enableDisplayFlagEmotions : Affiche les icônes des émotions de l'objet sans les compteurs.
     *     enableDisplayFlags et l'option displayEmotions doivent être à true.
     *     Par défaut false : n'affiche pas les icônes.
     *     Boolean
     * - enableDisplayFlagProtection : Affiche l'icône de protection de l'objet.
     *     enableDisplayFlags doit être à true.
     *     L'option permitProtectedObject doit être à true.
     *     Par défaut false : n'affiche pas l'icône.
     *     Boolean
     * - enableDisplayFlagObfuscate : Affiche l'icône de dissimulation de l'objet.
     *     enableDisplayFlags doit être à true.
     *     L'option permitObfuscatedLink doit être à true.
     *     Par défaut false : n'affiche pas l'icône.
     *     Boolean
     * - enableDisplayFlagUnlocked : Affiche l'icône de déverrouillage de l'entité.
     *     enableDisplayFlags doit être à true.
     *     Par défaut false : n'affiche pas l'icône.
     *     Boolean
     * - enableDisplayFlagActivated : Affiche l'icône d'activation de l'objet.
     *     enableDisplayFlags doit être à true.
     *     Par défaut false : n'affiche pas l'icône.
     *     Boolean
     * - enableDisplayFlagState : Affiche l'icône d'état de l'objet.
     *     enableDisplayFlags doit être à true.
     *     Par défaut false : n'affiche pas l'icône.
     *     Boolean
     * - enableDisplayStatus : Affiche le status de l'objet (indicatif).
     *     Par défaut false : n'affiche pas le status.
     *     Boolean
     * - enableDisplayContent : Affiche le contenu de l'objet si possible.
     *     Par défaut false : n'affiche pas le contenu.
     *     Boolean
     * - enableDisplayLink2Object : Affiche le lien HTML vers l'objet :
     *     Sur le nom de l'objet.
     *     Sur le carré de couleur et sur l'image/icône de l'objet, ou si le menu des actions est activé le menu remplace le lien HTML.
     *     Par défaut true : affiche le lien ou le menu.
     *     Boolean
     * - enableDisplayObjectActions : Affiche le menu des actions liées à l'objet.
     *     Sinon le lien de l'objet est utilisé à la place.
     *     enableDisplayLink2Object doit être à true.
     *     Par défaut true : affiche le menu.
     *     Boolean
     * - enableDisplayLink2Refs : Affiche le lien HTML vers le(s) référence(s) de l'objet.
     *     enableDisplayRefs doit être à true.
     *     Par défaut true : affiche le lien.
     *     Boolean
     * - enableDisplaySelfHook : Affiche les actions principales de l'objet utilisé.
     *     enableDisplayObjectActions doit être à true.
     *     Par défaut true : affiche les actions.
     *     Boolean
     * - enableDisplayTypeHook : Affiche les actions secondaires de l'objet par rapport à son type.
     *     enableDisplayObjectActions doit être à true.
     *     Par défaut true si enableDisplayJS : affiche les actions.
     *     Par défaut false si pas enableDisplayJS : n'affiche pas les actions.
     *     Boolean
     * - enableDisplayJS : Utilise le Java Script pour le menu des actions.
     *     Si false, le menu n'est pas caché et son contenu s'affiche sous la barre de titre de l'objet.
     *     Par défaut true : utilise le Java Script.
     *     Boolean
     *
     * Les paramètres de définition de contenus :
     * - social : Détermine le niveau social de tri des liens.
     *     Par défaut vide : utilise le niveau social par défaut.
     *     String
     * - objectType : Détermine le type d'objet pour le traitement.
     *     Par défaut null : le type est extrait en fonction du niveau social.
     *     String
     * - objectName : Détermine le nom de l'objet ou un texte de remplacement.
     *     enableDisplayName doit être à true.
     *     Par défaut null : le nom complet est extrait en fonction du niveau social.
     *     Si enableDisplayIconApp à true, le nom simple est extrait en fonction du niveau social.
     *     String
     * - objectAppShortName : Détermine le nom de l'objet ou un texte de remplacement.
     *     enableDisplayIconApp doit être à true.
     *     Par défaut null : le nom court (prénom) est extrait en fonction du niveau social.
     *     String
     * - objectIcon : Détermine l'image de l'objet.
     *     enableDisplayIcon doit être à true.
     *     Le fond est de la couleur de l'objet.
     *     Par défaut null : l'image est une icône représentant le type d'objet.
     *     String
     * - objectRefs : Détermine la liste des références de l'objet affiché, ou autres entités.
     *     Si c'est un text, affiche juste le texte après un filtre.
     *     Par défaut vide.
     *     Array of string|Object ou string
     * - link2Object : Détermine le lien HTML vers l'objet.
     *     Par défaut vide : le lien est préparé vers l'objet en fonction de son type.
     *     String
     * - flagProtection : Détermine l'icône de protection de l'objet.
     *     enableDisplayFlags et enableDisplayFlagProtection doivent être à true.
     *     Par défaut false : icône éteinte.
     *     Boolean
     * - flagProtectionIcon : Détermine l'icône de protection de l'objet.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagProtection doivent être à true.
     *     Par défaut vide : icône de lien de chiffrement LK.
     *     String
     * - flagProtectionText : Détermine l'icône de protection de l'objet.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagProtection doivent être à true.
     *     Par défaut vide : Texte standard traduit.
     *     String
     * - flagProtectionLink : Détermine le lien HTML de l'icône de protection de l'objet.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagProtection doivent être à true.
     *     Par défaut vide.
     *     String
     * - flagObfuscate : Détermine l'icône de dissimulation de l'objet.
     *     enableDisplayFlags et enableDisplayFlagObfuscate doivent être à true.
     *     Par défaut false : icône éteinte.
     *     Boolean
     * - flagObfuscateIcon : Détermine l'icône de dissimulation de l'objet.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagObfuscate doivent être à true.
     *     Par défaut vide : icône de lien de dissimulation LC.
     *     String
     * - flagObfuscateText : Détermine l'icône de dissimulation de l'objet.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagObfuscate doivent être à true.
     *     Par défaut vide : Texte standard traduit.
     *     String
     * - flagObfuscateLink : Détermine le lien HTML de l'icône de dissimulation de l'objet.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagProtection doivent être à true.
     *     Par défaut vide.
     *     String
     * - flagUnlocked : Détermine l'icône de déverrouillage de l'entité.
     *     enableDisplayFlags et enableDisplayFlagUnlocked doivent être à true.
     *     Par défaut dépend de l'état de l'entité.
     *     Si pas une entité, par défaut false : icône éteinte.
     *     Boolean
     * - flagUnlockedIcon : Détermine l'icône de déverrouillage de l'entité.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagUnlocked doivent être à true.
     *     Par défaut vide : icône de lien de chiffrement LK.
     *     String
     * - flagUnlockedText : Détermine l'icône de déverrouillage de l'entité.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagUnlocked doivent être à true.
     *     Par défaut vide : Texte standard traduit.
     *     String
     * - flagUnlockedLink : Détermine le lien HTML de l'icône de déverrouillage de l'entité.
     *     Permet de détourner le bouton de son usage primaire.
     *     enableDisplayFlags et enableDisplayFlagUnlocked doivent être à true.
     *     Par défaut vide.
     *     String
     * - flagActivated : Détermine l'icône d'activation de l'objet.
     *     enableDisplayFlags et enableDisplayFlagActivateded doivent être à true.
     *     Par défaut false : icône rouge en croix.
     *     Si à true, icône verte validée.
     *     Boolean
     * - flagActivatedDesc : Détermine le texte de description de l'activation de l'objet.
     *     enableDisplayFlags et enableDisplayFlagActivated doivent être à true.
     *     Par défaut vide : calcul la description de l'état de l'objet.
     *     Le texte de ces état est traduit.
     *     Par défaut est calculé par rapport à flagActivated :
     *       - false : ':::display:content:NotActived'
     *       - true  : ':::display:content:Actived'
     *     String
     * - flagState : Détermine l'icône de l'état de l'objet.
     *     enableDisplayFlags et enableDisplayFlagState doivent être à true.
     *     Par défaut vide : calcul l'état de l'objet.
     *     Les états possibles sont :
     *       - e : l'objet est taggé 'banni' ;
     *       - w : l'objet est taggé 'warning' ;
     *       - n : l'objet n'est pas présent ;
     *       - o : OK tout va bien.
     *     String
     * - flagStateDesc : Détermine le texte de description de l'état de l'objet.
     *     enableDisplayFlags et enableDisplayFlagState doivent être à true.
     *     Par défaut vide : calcul la description de l'état de l'objet.
     *     Le texte de ces état est traduit.
     *     Par défaut est calculé par rapport à flagState :
     *       - e : ':::display:content:errorBan'
     *       - w : ':::display:content:warningTaggedWarning'
     *       - n : ':::display:content:errorNotAvailable'
     *       - o : ':::display:content:OK'
     *     String
     * - flagMessage : Détermine un message à afficher au niveau des flags dépliés.
     *     enableDisplayFlags doit être à true.
     *     N'apparait pas comme icône simple.
     *     Par défaut vide : pas de message.
     *     String
     * - flagTargetObject : Détermine un objet 'cible' (ou pas) à afficher au niveau des flags dépliés.
     *     enableDisplayFlags doit être à true.
     *     N'apparait pas comme icône simple. L'objet est affiché sous forme tiny.
     *     Par défaut vide : pas d'objet.
     *     String (hex)
     * - status : Détermine le status de l'objet.
     *     Par défaut vide : pas de status.
     *     String
     * - displaySize : Détermine la taille de l'affichage de l'élément complet.
     *     Tailles disponibles :
     *     - tiny : très petite taille correspondant à un carré de base de 16 pixels de large.
     *         Certains éléments ne sont pas affichés.
     *     - small : petite taille correspondant à un carré de base de 32 pixels de large.
     *     - medium : taille moyenne correspondant à un carré de base de 64 pixels de large par défaut.
     *     - large : grande taille correspondant à un carré de base de 128 pixels de large par défaut.
     *     - full : très grande taille correspondant à un carré de base de 256 pixels de large par défaut.
     *     Par défaut medium : taille moyenne.
     *     String
     * - displayRatio : Détermine la forme de l'affichage par son ratio dans la mesure du possible si pas d'affichage du contenu de l'objet.
     *     Ratios disponibles :
     *     - square : forme carrée de 2x2 displaySize.
     *     - short : forme plate courte de 6x1 displaySize.
     *     - long : forme plate longue de toute largeure disponible.
     *     Par défaut short : forme plate courte.
     *     String
     * - selfHookList : Détermine la liste des point d'encrage à utiliser pour les actions sur l'objet utilisé.
     *     Par défaut vide : est préparé en fonction de selfHookName.
     *     Array
     * - selfHookName : Détermine le nom du point d'encrage à utiliser pour les actions sur l'objet utilisé.
     *     Par défaut vide : est préparé en fonction du type d'objet :
     *     - objet : selfMenuObject
     *     - entité : selfMenuEntity
     *     - groupe : selfMenuGroup
     *     - conversation : selfMenuConversation
     *     String
     * - typeHookName : Détermine le nom du point d'encrage à utiliser pour les actions sur l'objet par rapport à son type.
     *     Par défaut vide : est préparé en fonction du type d'objet :
     *     - objet : typeMenuObject
     *     - entité : typeMenuEntity
     *     - groupe : typeMenuGroup
     *     - conversation : typeMenuConversation
     *     String
     *
     * Exemple de table de paramètres avec les valeurs par défaut :
     *
     * $param = array(
     * 'enableDisplayColor' => true,
     * 'enableDisplayIcon' => true,
     * 'enableDisplayIconApp' => false,
     * 'enableDisplayRefs' => false,
     * 'enableDisplayName' => true,
     * 'enableDisplayID' => false,
     * 'enableDisplayFlags' => false,
     * 'enableDisplayFlagEmotions' => true,
     * 'enableDisplayFlagProtection' => false,
     * 'enableDisplayFlagObfuscate' => false,
     * 'enableDisplayFlagUnlocked' => false,
     * 'enableDisplayFlagActivated' => false,
     * 'enableDisplayFlagState' => false,
     * 'enableDisplayStatus' => false,
     * 'enableDisplayContent' => false,
     * 'enableDisplayLink2Object' => true,
     * 'enableDisplayObjectActions' => true,
     * 'enableDisplayLink2Refs' => true,
     * 'enableDisplaySelfHook' => true,
     * 'enableDisplayTypeHook' => true,
     * 'enableDisplayJS' => true,
     * 'social' => '',
     * 'objectType' => null,
     * 'objectName' => null,
     * 'objectAppShortName' => null,
     * 'objectIcon' => null,
     * 'objectRefs' => array(),
     * 'link2Object' => '',
     * 'flagProtection' => false,
     * 'flagProtectionIcon' => '',
     * 'flagProtectionText' => '',
     * 'flagProtectionLink' => '',
     * 'flagObfuscate' => false,
     * 'flagObfuscateIcon' => '',
     * 'flagObfuscateText' => '',
     * 'flagObfuscateLink' => '',
     * 'flagUnlocked' => false,
     * 'flagUnlockedIcon' => '',
     * 'flagUnlockedText' => '',
     * 'flagUnlockedLink' => '',
     * 'flagActivated' => false,
     * 'flagActivatedDesc' => '',
     * 'flagState' => '',
     * 'flagStateDesc' => '',
     * 'flagMessage' => '',
     * 'flagTargetObject' => '',
     * 'status' => '',
     * 'displaySize' => 'medium',
     * 'displayRatio' => 'short',
     * 'selfHookList' => array(),
     * 'selfHookName' => '',
     * 'typeHookName' => '',
     * );
     *
     * @param string|Node|entity $object
     * @param array $param
     * @return string
     */
    public function getDisplayObject($object, array $param)
    {
        $result = '';

        // Prépare l'objet.
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);

        // Prépare les paramètres d'activation de contenus.
        if (!isset($param['enableDisplayColor'])
            || $param['enableDisplayColor'] !== false
        ) {
            $param['enableDisplayColor'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayIcon'])
            || $param['enableDisplayIcon'] !== false
        ) {
            $param['enableDisplayIcon'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayIconApp'])
            || $param['enableDisplayIconApp'] !== true
        ) {
            $param['enableDisplayIconApp'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayRefs'])
            || $param['enableDisplayRefs'] !== true
        ) {
            $param['enableDisplayRefs'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayName'])
            || $param['enableDisplayName'] !== false
        ) {
            $param['enableDisplayName'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayID'])
            || $param['enableDisplayID'] !== true
        ) {
            $param['enableDisplayID'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlags'])
            || $param['enableDisplayFlags'] !== true
        ) {
            $param['enableDisplayFlags'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlagEmotions'])
            || $param['enableDisplayFlagEmotions'] !== true
        ) {
            $param['enableDisplayFlagEmotions'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlagProtection'])
            || $param['enableDisplayFlagProtection'] !== true
            || !$this->_nebuleInstance->getOption('permitProtectedObject')
        ) {
            $param['enableDisplayFlagProtection'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlagObfuscate'])
            || $param['enableDisplayFlagObfuscate'] !== true
            || !$this->_nebuleInstance->getOption('permitObfuscatedLink')
        ) {
            $param['enableDisplayFlagObfuscate'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlagUnlocked'])
            || $param['enableDisplayFlagUnlocked'] !== true
        ) {
            $param['enableDisplayFlagUnlocked'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlagActivated'])
            || $param['enableDisplayFlagActivated'] !== true
        ) {
            $param['enableDisplayFlagActivated'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlagState'])
            || $param['enableDisplayFlagState'] !== true
        ) {
            $param['enableDisplayFlagState'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayStatus'])
            || $param['enableDisplayStatus'] !== true
        ) {
            $param['enableDisplayStatus'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayContent'])
            || $param['enableDisplayContent'] !== true
        ) {
            $param['enableDisplayContent'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayObjectActions'])
            || $param['enableDisplayObjectActions'] !== false
        ) {
            $param['enableDisplayObjectActions'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayLink2Object'])
            || $param['enableDisplayLink2Object'] !== false
        ) {
            $param['enableDisplayLink2Object'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayLink2Refs'])
            || $param['enableDisplayLink2Refs'] !== false
        ) {
            $param['enableDisplayLink2Refs'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayJS'])
            || $param['enableDisplayJS'] !== false
        ) {
            $param['enableDisplayJS'] = true; // Par défaut à true.
        }
        if (!$this->_nebuleInstance->getOption('permitJavaScript')) {
            $param['enableDisplayJS'] = false; // A false si l'option globale est à false.
        }

        if (!isset($param['enableDisplaySelfHook'])
            || $param['enableDisplaySelfHook'] !== false
        ) {
            $param['enableDisplaySelfHook'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayTypeHook'])) {
            if ($param['enableDisplayJS']) {
                $param['enableDisplayTypeHook'] = true; // Par défaut à true si enableDisplayJS.
            } else {
                $param['enableDisplayTypeHook'] = false; // Par défaut à false si pas enableDisplayJS.
            }
        }
        if ($param['enableDisplayTypeHook'] !== false) {
            $param['enableDisplayTypeHook'] = true;
        }

        // Prépare les paramètres de définition de contenus.
        if (!isset($param['social'])
            || !is_string($param['social'])
            || $param['social'] == ''
        ) {
            $param['social'] = 'all'; // Par défaut vide.
        } else {
            $socialList = $this->_nebuleInstance->getSocial()->getList();
            $ok = false;
            foreach ($socialList as $s) {
                if ($param['social'] == $s) {
                    $ok = true;
                    break;
                }
            }
            unset($socialList);
            if (!$ok) {
                $param['social'] = 'all'; // Par défaut all.
            }
        }

        if (!isset($param['objectType'])
            || $param['objectType'] == null
        ) {
            $param['objectType'] = $object->getType($param['social']); // Par défaut extrait le type de l'objet.
        }

        /**
         * Le nom complet de l'objet à afficher.
         * Si c'est une application, c'est le nom simple qui est affiché.
         * @var string $contentDisplayName
         */
        $contentDisplayName = '';
        if (($param['enableDisplayName'])
            ||  ($param['enableDisplayIconApp'])
        ) {
            if (!isset($param['objectName'])
                || $param['objectName'] == null
            ) {
                if ($param['enableDisplayIconApp']) {
                    $param['objectName'] = $object->getName($param['social']); // Par défaut extrait le nom simple de l'objet (application).
                } else {
                    $param['objectName'] = $object->getFullName($param['social']); // Par défaut extrait le nom complet de l'objet.
                }
            }
            $contentDisplayName = trim(filter_var($param['objectName'], FILTER_SANITIZE_STRING));
        } else {
            $param['objectName'] = '';
        }

        /**
         * Le nom court d'une application.
         * @var string $contentDisplayAppShortName
         */
        $contentDisplayAppShortName = '';
        if ($param['enableDisplayIconApp']) {
            if (!isset($param['objectAppShortName'])
                || $param['objectAppShortName'] == null
            ) {
                $param['objectAppShortName'] = $object->getSurname($param['social']); // Par défaut extrait le surnom de l'objet (application).
            }
            $contentDisplayAppShortName = trim(filter_var($param['objectAppShortName'], FILTER_SANITIZE_STRING));
        } else {
            $param['objectAppShortName'] = '';
        }


        if (!isset($param['flagProtection'])
            || $param['flagProtection'] !== true
        ) {
            $param['flagProtection'] = false; // Par défaut à false.
        }
        if ($param['enableDisplayFlagProtection']) {
            if (!isset($param['flagProtectionIcon'])
                || $param['flagProtectionIcon'] == ''
                || !ctype_xdigit($param['flagProtectionIcon'])
                || !$this->_ioInstance->checkLinkPresent($param['flagProtectionIcon'])
            ) {
                $param['flagProtectionIcon'] = self::DEFAULT_ICON_LK;
            }
            if (isset($param['flagProtectionText'])) {
                $param['flagProtectionText'] = trim(filter_var($param['flagProtectionText'], FILTER_SANITIZE_STRING));
            }
            if (!isset($param['flagProtectionText'])
                || trim($param['flagProtectionText']) == ''
            ) {
                if ($param['flagProtection']) {
                    $param['flagProtectionText'] = ':::display:object:flag:protected';
                } else {
                    $param['flagProtectionText'] = ':::display:object:flag:unprotected';
                }
            }
            if (isset($param['flagProtectionLink'])) {
                $param['flagProtectionLink'] = trim(filter_var($param['flagProtectionLink'], FILTER_SANITIZE_URL));
            }
            if (!isset($param['flagProtectionLink'])
                || trim($param['flagProtectionLink']) == ''
            ) {
                $param['flagProtectionLink'] = null;
            }
        }

        if (!isset($param['flagObfuscate'])
            || $param['flagObfuscate'] !== true
        ) {
            $param['flagObfuscate'] = false; // Par défaut à false.
        }
        if ($param['enableDisplayFlagObfuscate']) {
            if (!isset($param['flagObfuscateIcon'])
                || $param['flagObfuscateIcon'] == ''
                || !ctype_xdigit($param['flagObfuscateIcon'])
                || !$this->_ioInstance->checkLinkPresent($param['flagObfuscateIcon'])
            ) {
                $param['flagObfuscateIcon'] = self::DEFAULT_ICON_LC;
            }
            if (isset($param['flagObfuscateText'])) {
                $param['flagObfuscateText'] = trim(filter_var($param['flagObfuscateText'], FILTER_SANITIZE_STRING));
            }
            if (!isset($param['flagObfuscateText'])
                || trim($param['flagObfuscateText']) == ''
            ) {
                if ($param['flagObfuscate']) {
                    $param['flagObfuscateText'] = ':::display:object:flag:obfuscated';
                } else {
                    $param['flagObfuscateText'] = ':::display:object:flag:unobfuscated';
                }
            }
            if (isset($param['flagObfuscateLink'])) {
                $param['flagObfuscateLink'] = trim(filter_var($param['flagObfuscateLink'], FILTER_SANITIZE_URL));
            }
            if (!isset($param['flagObfuscateLink'])
                || trim($param['flagObfuscateLink']) == ''
            ) {
                $param['flagObfuscateLink'] = null;
            }
        }

        if (!isset($param['flagUnlocked'])) {
            $param['flagUnlocked'] = false; // Par défaut à false.
            if (is_a($object, 'Entity')) {
                // Extrait l'état de verrouillage de l'objet entité.
                $param['flagUnlocked'] = $object->checkPrivateKeyPassword();
                // Vérifie si c'est l'entité courante.
                if ($object->getID() == $this->_nebuleInstance->getCurrentEntity()
                    && $this->_unlocked
                ) {
                    $param['flagUnlocked'] = true;
                }
            }
        }
        // Lisse la valeur binaire.
        if ($param['flagUnlocked'] !== true) {
            $param['flagUnlocked'] = false; // Par défaut à false.
        }
        if ($param['enableDisplayFlagUnlocked']) {
            if (!isset($param['flagUnlockedIcon'])
                || $param['flagUnlockedIcon'] == ''
                || !ctype_xdigit($param['flagUnlockedIcon'])
                || !$this->_ioInstance->checkLinkPresent($param['flagUnlockedIcon'])
            ) {
                $param['flagUnlockedIcon'] = self::DEFAULT_ICON_KEY;
            }
            if (isset($param['flagUnlockedText'])) {
                $param['flagUnlockedText'] = trim(filter_var($param['flagUnlockedText'], FILTER_SANITIZE_STRING));
            }
            if (!isset($param['flagUnlockedText'])
                || trim($param['flagUnlockedText']) == ''
            ) {
                if ($param['flagUnlocked']) {
                    $param['flagUnlockedText'] = ':::display:object:flag:locked';
                } else {
                    $param['flagUnlockedText'] = ':::display:object:flag:unlocked';
                }
            }
            if (isset($param['flagUnlockedLink'])) {
                $param['flagUnlockedLink'] = trim(filter_var($param['flagUnlockedLink'], FILTER_SANITIZE_URL));
            }
            if (!isset($param['flagUnlockedLink'])
                || trim($param['flagUnlockedLink']) == ''
            ) {
                $param['flagUnlockedLink'] = null;
            }
        }

        if (!isset($param['flagActivated'])
            || $param['flagActivated'] !== true
        ) {
            $param['flagActivated'] = false; // Par défaut à false.
        }

        if ($param['enableDisplayFlagActivated']) {
            if (!isset($param['flagActivatedDesc'])
                || strlen(trim($param['flagActivatedDesc'])) == 0
            ) {
                if ($param['flagActivated']) {
                    $param['flagActivatedDesc'] = ':::display:content:Activated';
                } else {
                    $param['flagActivatedDesc'] = ':::display:content:NotActivated';
                }
            } else {
                $param['flagActivatedDesc'] = trim($param['flagActivatedDesc']);
            }
        }

        $flagStateContentIcon = '';
        $flagStateContentDesc = '';
        if ($param['enableDisplayFlagState']) {
            if (!isset($param['flagState'])
                || strlen(trim($param['flagState'])) == 0
            ) {
                if ($object->getMarkDanger()) {
                    $param['flagState'] = 'e';
                } elseif ($object->getMarkWarning()) {
                    $param['flagState'] = 'w';
                } elseif ($object->checkPresent()) {
                    $param['flagState'] = 'o';
                } else {
                    $param['flagState'] = 'n';
                }
            }
            if ($param['flagState'] == 'e') {
                $flagStateContentIcon = self::DEFAULT_ICON_IERR;
                $flagStateContentDesc = ':::display:content:errorBan';
            } elseif ($param['flagState'] == 'w') {
                $flagStateContentIcon = self::DEFAULT_ICON_IWARN;
                $flagStateContentDesc = ':::display:content:warningTaggedWarning';
            } elseif ($param['flagState'] == 'o') {
                $flagStateContentIcon = self::DEFAULT_ICON_IOK;
                $flagStateContentDesc = ':::display:content:OK';
            } else {
                $param['flagState'] = 'n';
                $flagStateContentIcon = self::DEFAULT_ICON_IERR;
                $flagStateContentDesc = ':::display:content:errorNotAvailable';
            }
            if (isset($param['flagStateDesc'])
                && strlen(trim($param['flagStateDesc'])) != 0
            ) {
                $flagStateContentDesc = trim(filter_var($param['flagStateDesc'], FILTER_SANITIZE_STRING));
            }
        } else {
            $param['flagState'] = 'n';
            $param['flagStateDesc'] = '';
            $flagStateContentIcon = '';
            $flagStateContentDesc = '';
        }

        if (!isset($param['flagMessage'])
            || trim($param['flagMessage']) == ''
        ) {
            $param['flagMessage'] = null; // Par défaut vide.
        } else {
            $param['flagMessage'] = trim(filter_var($param['flagMessage'], FILTER_SANITIZE_STRING));
        }

        if (!isset($param['flagTargetObject'])
            || trim($param['flagTargetObject']) == ''
        ) {
            $param['flagTargetObject'] = null; // Par défaut vide.
        } else {
            $param['flagTargetObject'] = trim(filter_var($param['flagTargetObject'], FILTER_SANITIZE_STRING));
            if (!ctype_xdigit($param['flagTargetObject'])) {
                $param['flagTargetObject'] = null;
            }
        }

        $sizeCSS = 'Medium';
        if (!isset($param['displaySize'])) {
            $param['displaySize'] = 'medium';
            $sizeCSS = 'Medium';
        } else {
            switch ($param['displaySize']) {
                case 'tiny':
                    $sizeCSS = 'Tiny';
                    break;
                case 'small':
                    $sizeCSS = 'Small';
                    break;
                case 'large':
                    $sizeCSS = 'Large';
                    break;
                case 'full':
                    $sizeCSS = 'Full';
                    break;
                default:
                    $param['displaySize'] = 'medium';
                    $sizeCSS = 'Medium';
                    break;
            }
        }

        $ratioCSS = 'short';
        if (!isset($param['displayRatio'])) {
            $param['displayRatio'] = 'short';
            $ratioCSS = 'Short';
        } else {
            switch ($param['displayRatio']) {
                case 'square':
                    $ratioCSS = 'Square';
                    break;
                case 'long':
                    $ratioCSS = 'Long';
                    break;
                default:
                    $param['displayRatio'] = 'short';
                    $ratioCSS = 'Short';
                    break;
            }
        }

        if ($param['enableDisplaySelfHook']) {
            if (isset($param['selfHookName'])) {
                $param['selfHookName'] = trim(filter_var($param['selfHookName'], FILTER_SANITIZE_STRING));
            } else {
                $param['selfHookName'] = '';
            }
            if ($param['selfHookName'] == '') {
                if (is_a($object, 'Entity')) {
                    $param['selfHookName'] = 'selfMenuEntity';
                } elseif (is_a($object, 'Conversation')) {
                    $param['selfHookName'] = 'selfMenuConversation';
                } elseif (is_a($object, 'Group')) {
                    $param['selfHookName'] = 'selfMenuGroup';
                } elseif (is_a($object, 'Transaction')) {
                    $param['selfHookName'] = 'selfMenuTransaction';
                } elseif (is_a($object, 'Wallet')) {
                    $param['selfHookName'] = 'selfMenuWallet';
                } elseif (is_a($object, 'Token')) {
                    $param['selfHookName'] = 'selfMenuToken';
                } elseif (is_a($object, 'TokenPool')) {
                    $param['selfHookName'] = 'selfMenuTokenPool';
                } elseif (is_a($object, 'Currency')) {
                    $param['selfHookName'] = 'selfMenuCurrency';
                } else {
                    $param['selfHookName'] = 'selfMenuObject';
                }
            }
        } else {
            $param['selfHookName'] = '';
        }

        if ($param['enableDisplayTypeHook']) {
            if (isset($param['typeHookName'])) {
                $param['typeHookName'] = trim(filter_var($param['typeHookName'], FILTER_SANITIZE_STRING));
            } else {
                $param['typeHookName'] = '';
            }
            if ($param['typeHookName'] == '') {
                if (is_a($object, 'Entity')) {
                    $param['typeHookName'] = 'typeMenuEntity';
                } elseif (is_a($object, 'Conversation')) {
                    $param['typeHookName'] = 'typeMenuConversation';
                } elseif (is_a($object, 'Group')) {
                    $param['typeHookName'] = 'typeMenuGroup';
                } elseif (is_a($object, 'Transaction')) {
                    $param['typeHookName'] = 'typeMenuTransaction';
                } elseif (is_a($object, 'Wallet')) {
                    $param['typeHookName'] = 'typeMenuWallet';
                } elseif (is_a($object, 'Token')) {
                    $param['typeHookName'] = 'typeMenuToken';
                } elseif (is_a($object, 'TokenPool')) {
                    $param['typeHookName'] = 'typeMenuTokenPool';
                } elseif (is_a($object, 'Currency')) {
                    $param['typeHookName'] = 'typeMenuCurrency';
                } else {
                    $param['typeHookName'] = 'typeMenuObject';
                }
            }
        } else {
            $param['typeHookName'] = '';
        }

        if (!isset($param['selfHookList'])
            || !is_array($param['selfHookList'])
        ) {
            $param['selfHookList'] = array();
        }

        // Résoud les conflits.
        if ($param['displaySize'] == 'tiny') {
            $param['enableDisplayLink2Refs'] = false;
            $param['enableDisplayObjectActions'] = false;
            $param['enableDisplayRefs'] = false;
            $param['enableDisplayFlags'] = false;
            $param['enableDisplayStatus'] = false;
            $param['enableDisplayContent'] = false;
        }

        if ($param['displaySize'] == 'small') {
            $param['enableDisplayFlags'] = false;
            $param['enableDisplayStatus'] = false;
        }

        if ($param['enableDisplayContent']
            && $param['displayRatio'] == 'square'
        ) {
            $param['displayRatio'] = 'short';
            $ratioCSS = 'Short';
        }

        if ($param['enableDisplayIconApp']) {
            $param['enableDisplayColor'] = false;
            $param['enableDisplayIcon'] = false;
        }

        if (!$param['enableDisplayColor']
            && !$param['enableDisplayIcon']
            && !$param['enableDisplayIconApp']
        ) {
            $param['enableDisplayObjectActions'] = false;
        }

        if (!$param['enableDisplayName']) {
            $param['enableDisplayRefs'] = false;
            $param['enableDisplayFlags'] = false;
            $param['enableDisplayStatus'] = false;
        }

        if (!$this->_nebuleInstance->getOption('displayEmotions')) {
            $param['enableDisplayFlagEmotions'] = false;
        }

        if ($param['displaySize'] == 'tiny'
            || $param['displaySize'] == 'small'
            || ($param['displaySize'] == 'medium' && $param['enableDisplayFlags'])
            || !$param['enableDisplayName']
        ) {
            $param['enableDisplayID'] = false;
        }

        //if ( $param['displaySize'] == 'large' ) $param['enableDisplayID'] == true;

        // Prépare les contenus.
        $objectColor = $object->getPrimaryColor();
        $ObjectActionsID = '0';
        if ($param['enableDisplayObjectActions']
            && $param['enableDisplayJS']
        ) {
            $ObjectActionsID = bin2hex($this->_nebuleInstance->getCrypto()->getPseudoRandom(8));
        }
        $contentDisplayColor = '';
        if ($param['enableDisplayColor']) {
            $contentDisplayColor = '<img title="' . $contentDisplayName;
            $contentDisplayColor .= '" style="background:#' . $objectColor;
            $contentDisplayColor .= ';" alt="[C]" src="o/' . self::DEFAULT_ICON_ALPHA_COLOR . '" ';
            if ($param['enableDisplayObjectActions']
                && $param['enableDisplayJS']
            ) {
                $contentDisplayColor .= "onclick=\"display_menu('objectTitleMenu-" . $ObjectActionsID . "');\" ";
            }
            $contentDisplayColor .= '/>';
        }

        $contentDisplayIcon = '';
        if ($param['enableDisplayIcon']) {
            if (!isset($param['objectIcon'])
                || $param['objectIcon'] == null
            ) {
                $param['objectIcon'] = '';
            }
            $contentDisplayIcon = '<img title="' . $contentDisplayName;
            $contentDisplayIcon .= '" style="background:#' . $objectColor;
            $contentDisplayIcon .= ';" alt="[I]" src="' . $this->_getDisplayObjectIcon($object, $param['objectIcon']) . '" ';
            if ($param['enableDisplayObjectActions']
                && $param['enableDisplayJS']
            ) {
                $contentDisplayIcon .= "onclick=\"display_menu('objectTitleMenu-" . $ObjectActionsID . "');\" ";
            }
            $contentDisplayIcon .= '/>';
        }

        if ($param['enableDisplayIconApp']) {
            $contentDisplayIcon = '<div class="objectTitleIconsApp" style="background:#' . $objectColor . ';">';
            $contentDisplayIcon .= '<div><span class="objectTitleIconsAppShortname">' . $contentDisplayAppShortName . '</span><br /><span class="objectTitleIconsAppTitle">' . $contentDisplayName . '</span></div>';
            $contentDisplayIcon .= '</div>';
        }

        $titleLinkOpenImg = '';
        $titleLinkOpenName = '';
        $titleLinkCloseImg = '';
        $titleLinkCloseName = '';
        if ($param['enableDisplayLink2Object']) {
            if ($param['enableDisplayObjectActions']
                && $param['enableDisplayJS']
            ) {
                if (isset($param['link2Object'])
                    && $param['link2Object'] != null
                ) {
                    $titleLinkOpenName = '<a href="' . $param['link2Object'] . '">';
                } else {
                    $titleLinkOpenName = '<a href="' . $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object) . '">';
                }
                $titleLinkCloseName = '</a>';
            } else {
                if (isset($param['link2Object'])
                    && $param['link2Object'] != null
                ) {
                    $titleLinkOpenImg = '<a href="' . $param['link2Object'] . '">' . "\n";
                } else {
                    $titleLinkOpenImg = '<a href="' . $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object) . '">';
                }
                $titleLinkOpenName = $titleLinkOpenImg;
                $titleLinkCloseImg = '</a>';
                $titleLinkCloseName = $titleLinkCloseImg;
            }
        }

        $status = '';
        if ($param['enableDisplayStatus']
            && isset($param['status'])
        ) {
            $status = trim(filter_var($param['status'], FILTER_SANITIZE_STRING));
            if ($status == '') {
                $status = $this->getTraduction($param['objectType']);
            }
            if ($status == '') {
                $param['enableDisplayStatus'] = false;
            }
        }

        // Prépare le menu si besoin.
        $divTitleMenuOpen = '';
        $divTitleMenuClose = '';
        $divTitleMenuTitleOpen = '';
        $divTitleMenuTitleClose = '';
        $divTitleMenuIconsOpen = '';
        $divTitleMenuIconsClose = '';
        $divTitleMenuContentOpen = '';
        $divTitleMenuContentClose = '';
        $divTitleMenuActionsOpen = '';
        $divTitleMenuActionsClose = '';
        $menuContent = '';
        $menuActions = '';
        if ($param['enableDisplayLink2Object']
            && $param['enableDisplayObjectActions']
        ) {
            $menuContent = '   <div class="objectMenuContentMsg objectMenuContentMsgID">ID:';
            $menuContent .= $object->getID();
            $menuContent .= '</div>' . "\n";
            if ($param['enableDisplayFlags']) {
                if ($param['enableDisplayFlagState']) {
                    $menuContent .= '   <div class="objectMenuContentMsg objectMenuContentMsg';
                    if ($param['flagState'] == 'e') {
                        $menuContent .= 'Error';
                    } elseif ($param['flagState'] == 'w') {
                        $menuContent .= 'Warn';
                    } elseif ($param['flagState'] == 'n') {
                        $menuContent .= 'Error';
                    } else {
                        $menuContent .= 'OK';
                    }
                    $menuContent .= '">';
                    $menuContent .= $this->_getDisplayObjectFlag(
                        false,
                        $flagStateContentIcon,
                        $flagStateContentDesc,
                        '');
                    $menuContent .= $this->_traductionInstance->getTraduction($flagStateContentDesc);
                    $menuContent .= '</div>' . "\n";
                }
                if ($param['enableDisplayFlagProtection']) {
                    if ($param['flagProtectionLink'] != '') {
                        $menuContent .= '<a href="' . $param['flagProtectionLink'] . '">';
                    }
                    $menuContent .= '   <div class="objectMenuContentMsg objectMenuContentMsg';
                    if ($param['flagProtection']) {
                        $menuContent .= 'OK';
                    } else {
                        $menuContent .= 'Info';
                    }
                    $menuContent .= '">';
                    $menuContent .= $this->_getDisplayObjectFlag(
                        $param['flagProtection'],
                        $param['flagProtectionIcon'],
                        $param['flagProtectionText'],
                        $param['flagProtectionText']);
                    $menuContent .= $this->_traductionInstance->getTraduction($param['flagProtectionText']);
                    $menuContent .= '</div>' . "\n";
                    if ($param['flagProtectionLink'] != '') {
                        $menuContent .= '</a>';
                    }
                }
                if ($param['enableDisplayFlagObfuscate']) {
                    if ($param['flagObfuscateLink'] != '') {
                        $menuContent .= '<a href="' . $param['flagObfuscateLink'] . '">';
                    }
                    $menuContent .= '   <div class="objectMenuContentMsg objectMenuContentMsg';
                    if ($param['flagObfuscate']) {
                        $menuContent .= 'OK';
                    } else {
                        $menuContent .= 'Info';
                    }
                    $menuContent .= '">';
                    $menuContent .= $this->_getDisplayObjectFlag(
                        $param['flagObfuscate'],
                        $param['flagObfuscateIcon'],
                        $param['flagObfuscateText'],
                        $param['flagObfuscateText']);
                    $menuContent .= $this->_traductionInstance->getTraduction($param['flagObfuscateText']);
                    $menuContent .= '</div>' . "\n";
                    if ($param['flagObfuscateLink'] != '') {
                        $menuContent .= '</a>';
                    }
                }
                if ($param['enableDisplayFlagUnlocked']) {
                    if ($param['flagUnlockedLink'] != '') {
                        $menuContent .= '<a href="' . $param['flagUnlockedLink'] . '">';
                    }
                    $menuContent .= '   <div class="objectMenuContentMsg objectMenuContentMsg';
                    if ($param['flagUnlocked']) {
                        $menuContent .= 'OK';
                    } else {
                        $menuContent .= 'Info';
                    }
                    $menuContent .= '">';
                    $menuContent .= $this->_getDisplayObjectFlag(
                        $param['flagUnlocked'],
                        $param['flagUnlockedIcon'],
                        $param['flagUnlockedText'],
                        $param['flagUnlockedText']);
                    $menuContent .= $this->_traductionInstance->getTraduction($param['flagUnlockedText']);
                    $menuContent .= '</div>' . "\n";
                    if ($param['flagUnlockedLink'] != '') {
                        $menuContent .= '</a>';
                    }
                }
                if ($param['enableDisplayFlagActivated']) {
                    $menuContent .= '   <div class="objectMenuContentMsg objectMenuContentMsg';
                    if ($param['flagActivated']) {
                        $menuContent .= 'OK';
                    } else {
                        $menuContent .= 'Info';
                    }
                    $menuContent .= '">';
                    $menuContent .= $this->_getDisplayObjectFlag(
                        $param['flagActivated'],
                        self::DEFAULT_ICON_LL,
                        ':::display:object:flag:unactivated',
                        ':::display:object:flag:activated');
                    if ($param['flagActivated']) {
                        $menuContent .= $this->_traductionInstance->getTraduction(':::display:object:flag:activated');
                    } else {
                        $menuContent .= $this->_traductionInstance->getTraduction(':::display:object:flag:unactivated');
                    }
                    $menuContent .= '</div>' . "\n";
                }
                if ($param['flagMessage'] != null) {
                    $menuContent .= '   <div class="objectMenuContentMsg objectMenuContentMsgInfo">';
                    $menuContent .= $this->_getDisplayObjectFlag(
                        false,
                        self::DEFAULT_ICON_IINFO,
                        '',
                        '-');
                    $menuContent .= $param['flagMessage'];
                    $menuContent .= '</div>' . "\n";
                }
                if ($param['flagTargetObject'] != null) {
                    $menuContent .= '   <div class="objectMenuContentMsg objectMenuContentMsgtargetObject">';
                    $paramTiny = array(
                        'enableDisplayColor' => true,
                        'enableDisplayIcon' => true,
                        'enableDisplayRefs' => false,
                        'enableDisplayName' => true,
                        'enableDisplayID' => false,
                        'enableDisplayFlags' => false,
                        'enableDisplayJS' => false,
                        'displaySize' => 'tiny',
                        'displayRatio' => 'short',
                    );
                    // ATTENTION à une possible boucle infinie !
                    $menuContent .= $this->getDisplayObject($param['flagTargetObject'], $paramTiny);
                    unset($paramTiny);
                    $menuContent .= '</div>' . "\n";
                }
                // $param['flagTargetObject']
                if ($param['enableDisplayFlagEmotions']
                    && $param['enableDisplayJS']
                ) {
                    $menuContent .= '   <div class="objectMenuContentMsg objectMenuContentMsgEmotions">';
                    $menuContent .= $this->_getDisplayObjectFlagEmotions($object, true);
                    $menuContent .= '</div>' . "\n";
                }
            }

            if ($param['enableDisplayJS']) {
                $divTitleMenuOpen = '  <div class="objectTitleMenuContentLayout" id="objectTitleMenu-' . $ObjectActionsID . '" '
                    . "onclick=\"display_hide('objectTitleMenu-" . $ObjectActionsID . "');\" >\n";
                $divTitleMenuOpen .= '   <div class="objectTitleMenuContent">' . "\n";
                $divTitleMenuTitleOpen = '    <div class="objectTitleMedium objectTitleMediumLong">' . "\n";
                $divTitleMenuIconsOpen = '    <div class="objectTitleIcons">' . "\n";
                $titleMenuIcons = $contentDisplayColor . $contentDisplayIcon . "\n";
                $divTitleMenuIconsClose = '    </div>' . "\n";
                $divTitleMenuTitleClose = '    </div>' . "\n";
                $divTitleMenuContentOpen = '    <div class="objectMenuContent">' . "\n";
                $divTitleMenuContentClose = '    </div>' . "\n";
                $menuActions = $this->_getDisplayObjectHookList(
                    $param['selfHookName'],
                    $param['typeHookName'],
                    $object,
                    true,
                    $sizeCSS . 'Long',
                    $param['selfHookList']);
                if ($menuActions != '') {
                    $divTitleMenuActionsOpen = '<div class="objectMenuContentActions objectMenuContentActions' . $sizeCSS . 'Long">' . "\n";
                    $divTitleMenuActionsClose = ' <div class="objectMenuContentAction-close"></div>' . "\n</div>\n";
                }
                $divTitleMenuClose = '   </div></div>' . "\n";
            } else {
                $divMenuContentOpen = '  <div class="objectMenuContent objectDisplay' . $sizeCSS . ' objectDisplay' . $sizeCSS . $ratioCSS . '">' . "\n";
                $divMenuContentClose = '  </div>' . "\n";
                $menuActions = $this->_getDisplayObjectHookList(
                    $param['selfHookName'],
                    $param['typeHookName'],
                    $object,
                    false,
                    $sizeCSS . $ratioCSS,
                    $param['selfHookList']);
                if ($menuActions != '') {
                    $divTitleMenuActionsOpen = '<div class="objectMenuContentActions objectMenuContentActions' . $sizeCSS . $ratioCSS . '">' . "\n";
                    $divTitleMenuActionsClose = ' <div class="objectMenuContentAction-close"></div>' . "\n</div>\n";
                }
            }
        }

        // Assemble les contenus.
        $divDisplayOpen = '';
        $divDisplayClose = '';
        $divTitleOpen = '';
        $divTitleClose = '';
        $titleContent = '';
        $divTitleIconsOpen = '';
        $divTitleIconsClose = '';
        $titleIconsContent = '';
        $divTitleTextOpen = '';
        $divTitleTextClose = '';
        $titleTextContent = '';
        $divTitleRefsOpen = '';
        $divTitleRefsClose = '';
        $titleRefsContent = '';
        $divTitleNameOpen = '';
        $divTitleNameClose = '';
        $titleNameContent = '';
        $divTitleIdOpen = '';
        $divTitleIdClose = '';
        $titleIdContent = '';
        $divTitleFlagsOpen = '';
        $divTitleFlagsClose = '';
        $titleFlagsContent = '';
        $divTitleStatusOpen = '';
        $divTitleStatusClose = '';
        $titleStatusContent = '';
        $divObjectOpen = '';
        $divObjectClose = '';
        $objectContent = '';
        if ($param['displaySize'] == 'tiny') {
            $result = $titleLinkOpenName . '<span style="font-size:1em" class="objectTitleIconsInline">' . $contentDisplayColor . $contentDisplayIcon . '</span>' . $contentDisplayName . $titleLinkCloseName;
        } else {
            $divDisplayOpen = '<div class="layoutObject">' . "\n";
            $divDisplayClose = '</div>' . "\n";
            $divTitleOpen = ' <div class="objectTitle objectDisplay' . $sizeCSS . ' objectTitle' . $sizeCSS . ' objectDisplay' . $sizeCSS . $ratioCSS . '">' . "\n";
            $divTitleClose = ' </div>' . "\n";
            $divTitleIconsOpen = '  <div class="objectTitleIcons">';
            $divTitleIconsClose = '</div>' . "\n";
            if ($param['enableDisplayColor']
                || $param['enableDisplayIcon']
                || $param['enableDisplayIconApp']
            ) {
                $titleIconsContent = $contentDisplayColor . $contentDisplayIcon;
            }
            if ($param['enableDisplayName']) {
                $padding = 0;
                if ($param['enableDisplayColor']) {
                    $padding += 1;
                }
                if ($param['enableDisplayIcon']) {
                    $padding += 1;
                }
                if ($param['enableDisplayIconApp']) {
                    $padding += 1;
                }
                $divTitleTextOpen = '  <div class="objectTitleText objectTitle' . $sizeCSS . 'Text objectTitleText' . $padding . '">' . "\n";
                $divTitleTextClose = '  </div>' . "\n";
                $divTitleRefsOpen = '   <div class="objectTitleRefs objectTitle' . $sizeCSS . 'Refs">';
                $divTitleRefsClose = '</div>' . "\n";
                $divTitleNameOpen = '   <div class="objectTitleName objectTitle' . $sizeCSS . 'Name">';
                $divTitleNameClose = '</div>' . "\n";
                $divTitleFlagsOpen = '   <div class="objectTitleFlags objectTitle' . $sizeCSS . 'Flags">' . "\n";
                $divTitleFlagsClose = '   </div>' . "\n";
                $divTitleStatusOpen = '    <div class="objectTitleStatus">';
                $divTitleStatusClose = '</div>' . "\n";
                if ($param['enableDisplayRefs']) {
                    $titleRefsContent = $this->_getDisplayObjectRefs($param['objectRefs']);
                }
                if ($param['enableDisplayID']) {
                    $divTitleIdOpen = '    <div class="objectTitleID">';
                    $divTitleIdClose = '</div>' . "\n";
                    $titleIdContent = $object->getID();
                }
                $titleNameContent = $contentDisplayName;
                if ($param['enableDisplayFlags']) {
                    if ($param['enableDisplayFlagState']) {
                        $titleFlagsContent .= $this->_getDisplayObjectFlag(
                            false,
                            $flagStateContentIcon,
                            $flagStateContentDesc,
                            '');
                    }
                    if ($param['enableDisplayFlagProtection']) {
                        if ($param['flagProtectionLink'] != '') {
                            $titleFlagsContent .= '<a href="' . $param['flagProtectionLink'] . '">';
                        }
                        $titleFlagsContent .= $this->_getDisplayObjectFlag(
                            $param['flagProtection'],
                            $param['flagProtectionIcon'],
                            $param['flagProtectionText'],
                            $param['flagProtectionText']);
                        if ($param['flagProtectionLink'] != '') {
                            $titleFlagsContent .= '</a>';
                        }
                    }
                    if ($param['enableDisplayFlagObfuscate']) {
                        if ($param['flagObfuscateLink'] != '') {
                            $titleFlagsContent .= '<a href="' . $param['flagObfuscateLink'] . '">';
                        }
                        $titleFlagsContent .= $this->_getDisplayObjectFlag(
                            $param['flagObfuscate'],
                            $param['flagObfuscateIcon'],
                            $param['flagObfuscateText'],
                            $param['flagObfuscateText']);
                        if ($param['flagObfuscateLink'] != '') {
                            $titleFlagsContent .= '</a>';
                        }
                    }
                    if ($param['enableDisplayFlagUnlocked']) {
                        if ($param['flagUnlockedLink'] != '') {
                            $titleFlagsContent .= '<a href="' . $param['flagUnlockedLink'] . '">';
                        }
                        $titleFlagsContent .= $this->_getDisplayObjectFlag(
                            $param['flagUnlocked'],
                            $param['flagUnlockedIcon'],
                            $param['flagUnlockedText'],
                            $param['flagUnlockedText']);
                        if ($param['flagUnlockedLink'] != '') {
                            $titleFlagsContent .= '</a>';
                        }
                    }
                    if ($param['enableDisplayFlagActivated']) {
                        $titleFlagsContent .= $this->_getDisplayObjectFlag(
                            $param['flagActivated'],
                            self::DEFAULT_ICON_LL,
                            ':::display:object:flag:unactivated',
                            ':::display:object:flag:activated');
                    }
                    if ($param['enableDisplayFlagEmotions']) {
                        $titleFlagsContent .= $this->_getDisplayObjectFlagEmotions($object, false);
                    }
                }
                if ($param['enableDisplayStatus']) {
                    $titleStatusContent = $status;
                }
            }
            $titleContent = $titleLinkOpenImg . "\n" . $divTitleIconsOpen . $titleIconsContent . $divTitleIconsClose . $titleLinkCloseImg . "\n";
            $titleContent .= $divTitleTextOpen;
            $titleContent .= $divTitleRefsOpen . $titleRefsContent . $divTitleRefsClose;
            $titleContent .= $divTitleNameOpen . $titleLinkOpenName . $titleNameContent . $titleLinkCloseName . $divTitleNameClose;
            $titleContent .= $divTitleIdOpen . $titleIdContent . $divTitleIdClose;
            $titleContent .= $divTitleFlagsOpen . $titleFlagsContent;
            $titleContent .= $divTitleStatusOpen . $titleStatusContent . $divTitleStatusClose;
            $titleContent .= $divTitleFlagsClose;
            $titleContent .= $divTitleTextClose;
            if ($param['enableDisplayJS']
                && $param['enableDisplayObjectActions']
            ) {
                $titleContent .= $divTitleMenuOpen;
                $titleContent .= $divTitleMenuTitleOpen;
                $titleContent .= $divTitleMenuIconsOpen . $titleMenuIcons . $divTitleMenuIconsClose;
                $titleContent .= $divTitleTextOpen;
                $titleContent .= $divTitleRefsOpen . $titleRefsContent . $divTitleRefsClose;
                $titleContent .= $divTitleNameOpen . $titleLinkOpenName . $titleNameContent . $titleLinkCloseName . $divTitleNameClose;
                $titleContent .= $divTitleIdOpen . $titleIdContent . $divTitleIdClose;
                $titleContent .= $divTitleFlagsOpen . $titleFlagsContent;
                $titleContent .= $divTitleStatusOpen . $titleStatusContent . $divTitleStatusClose;
                $titleContent .= $divTitleFlagsClose;
                $titleContent .= $divTitleTextClose;
                $titleContent .= $divTitleMenuTitleClose;
                $titleContent .= $divTitleMenuContentOpen . $menuContent . $divTitleMenuContentClose;
                $titleContent .= $divTitleMenuActionsOpen . $menuActions . $divTitleMenuActionsClose;
                $titleContent .= $divTitleMenuClose;
            }

            if ($param['enableDisplayContent']) {
                $objectContent = $this->getDisplayObjectContent($object, $param['displaySize'], $param['displayRatio']);
            }

            // Prépare le résultat à afficher.
            $result = $divDisplayOpen;
            $result .= $divTitleOpen . $titleContent . $divTitleClose;
            if (!$param['enableDisplayJS']
                && $param['enableDisplayObjectActions']
            ) {
                $result .= $divMenuContentOpen . $menuContent . $divMenuContentClose;
                $result .= $divTitleMenuActionsOpen . $menuActions . $divTitleMenuActionsClose;
            }
            $result .= $divObjectOpen . $objectContent . $divObjectClose;
            $result .= $divDisplayClose;
        }

        return $result;
    }

    /**
     * Pour la fonction getDisplayObject().
     * Prépare l'icône de l'objet.
     *
     * Si une icône est imposée, elle est utilisée.
     * Sinon fait une recherche par référence en fonction du type de l'objet.
     * Une mise à jour éventuelle de l'icône est recherchée.
     * Si l'objet de l'icône est présent, génère un chemin direct pour améliorer les performances.
     *
     * @param Node $object
     * @param string $icon
     * @return string
     */
    private function _getDisplayObjectIcon($object, $icon)
    {
        if ($icon != ''
            && $this->_ioInstance->checkLinkPresent($icon)
        ) {
            if (!is_a($icon, 'Node')) {
                $icon = $this->_nebuleInstance->newObject($icon);
            }
        } else {
            if (is_a($object, 'Entity')) {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_ENTITY);
            } elseif (is_a($object, 'Conversation')) {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_CONVERSATION);
            } elseif (is_a($object, 'Group')) {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_GROUP);
            } elseif (is_a($object, 'Wallet')) {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_OBJECT); // @todo
            } elseif (is_a($object, 'Transaction')) {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_OBJECT); // @todo
            } elseif (is_a($object, 'Token')) {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_OBJECT); // @todo
            } elseif (is_a($object, 'TokenPool')) {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_OBJECT); // @todo
            } elseif (is_a($object, 'Currency')) {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_OBJECT); // @todo
            } else {
                $icon = $this->_getImageByReference(self::REFERENCE_ICON_OBJECT);
            }
            $icon = $this->_nebuleInstance->newObject($icon);
        }

        // Cherche une mise à jour éventuelle.
        $updateIcon = $this->_getImageUpdate($icon);

        // Retourne un chemin direct si l'objet est présent.
        if ($this->_ioInstance->checkObjectPresent($updateIcon)) {
            return nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '/' . $updateIcon;
        }
        return '?' . nebule::NEBULE_LOCAL_OBJECTS_FOLDER . '=' . $updateIcon;
    }

    /**
     * Pour les fonctions getDisplayObject() et getDisplayMessage().
     * Prépare la liste des références (signataires).
     *
     * Si l'entrée est un texte, retourne le texte (à afficher).
     *
     * @param array:Object $list
     * @return string
     */
    private function _getDisplayObjectRefs($list)
    {
        $result = '';

        if (is_string($list)
            && strlen($list) != 0
        ) {
            $result = trim(filter_var($list, FILTER_SANITIZE_STRING));
            return $result;
        }

        if (!is_array($list)
            || sizeof($list) == 0
        ) {
            return '';
        }

        $size = sizeof($list);
        $count = 0;

        foreach ($list as $object) {
            $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
            $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object);
            $color = $this->_prepareObjectColor($object);
            $icon = '';
            if ($size < 11) {
                $icon = $this->_prepareObjectFace($object);
            }
            $name = '';
            if ($size < 3) {
                $name = $this->_truncateName($object->getFullName('all'), 0);
            }
            $result .= $this->convertHypertextLink($color . $icon . $name, $htlink);
            if ($size < 11) {
                $result .= ' ';
            }

            $count++;
            if ($count > 30) {
                $result .= '+';
                break;
            }
        }

        return $result;
    }

    /**
     * Pour la fonction getDisplayObject().
     * Prépare les icônes des indicateurs (flags).
     *
     * @param boolean $on
     * @param string $image
     * @param string $descOff
     * @param string $descOn
     * @return string
     */
    private function _getDisplayObjectFlag($on, $image, $descOff, $descOn)
    {
        $result = '';

        $image = $this->prepareIcon($image);
        if ($on) {
            $desc = $this->_traductionInstance->getTraduction($descOn);
        } else {
            $desc = $this->_traductionInstance->getTraduction($descOff);
        }
        $result .= '<img title="' . $desc . '" ';
        if ($on) {
            $result .= 'class="objectFlagOn" ';
        }
        $result .= 'alt="[C]" src="' . $image . '" />';

        return $result;
    }

    /**
     * Pour les fonctions getDisplayObject() et getDisplayMessage().
     * Prépare les icônes des émotions avec ou sans les compteurs ($counts).
     *
     * @param Node $object
     * @param boolean $counts
     * @return string
     */
    private function _getDisplayObjectFlagEmotions($object, $counts = false)
    {
        // Vérifie si les émotions doivent être affichées.
        if (!$this->_nebuleInstance->getOption('displayEmotions')) {
            return '';
        }
        $result = '';

        $listEmotions = array(
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET,
        );
        $listEmotions0 = array(
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE => Display::REFERENCE_ICON_EMOTION_JOIE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE => Display::REFERENCE_ICON_EMOTION_CONFIANCE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR => Display::REFERENCE_ICON_EMOTION_PEUR0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE => Display::REFERENCE_ICON_EMOTION_SURPRISE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE => Display::REFERENCE_ICON_EMOTION_TRISTESSE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT => Display::REFERENCE_ICON_EMOTION_DEGOUT0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE => Display::REFERENCE_ICON_EMOTION_COLERE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET => Display::REFERENCE_ICON_EMOTION_INTERET0,
        );
        $listEmotions1 = array(
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE => Display::REFERENCE_ICON_EMOTION_JOIE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE => Display::REFERENCE_ICON_EMOTION_CONFIANCE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR => Display::REFERENCE_ICON_EMOTION_PEUR1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE => Display::REFERENCE_ICON_EMOTION_SURPRISE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE => Display::REFERENCE_ICON_EMOTION_TRISTESSE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT => Display::REFERENCE_ICON_EMOTION_DEGOUT1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE => Display::REFERENCE_ICON_EMOTION_COLERE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET => Display::REFERENCE_ICON_EMOTION_INTERET1,
        );

        foreach ($listEmotions as $emotion) {
            // Génère la base du lien html pour revenir au bon endroit en toute situation.
            $htlink = '?' . Displays::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $this->_applicationInstance->getDisplayInstance()->getCurrentDisplayMode()
                . '&' . Displays::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . $this->_applicationInstance->getDisplayInstance()->getCurrentDisplayView()
                . '&' . nebule::COMMAND_SELECT_OBJECT . '=' . $object->getID()
                . '&' . nebule::COMMAND_SELECT_ENTITY . '=' . $this->_applicationInstance->getCurrentEntity()
                . '&' . nebule::COMMAND_SELECT_GROUP . '=' . $this->_nebuleInstance->getCurrentGroup()
                . '&' . nebule::COMMAND_SELECT_CONVERSATION . '=' . $this->_nebuleInstance->getCurrentConversation();

            // Préparation du lien.
            $source = $object->getID();
            $target = $this->_nebuleInstance->getCrypto()->hash($emotion);
            $meta = $this->_nebuleInstance->getCurrentEntity();

            // Détermine si l'émotion a été marqué par l'entité en cours.
            if ($object->getMarkEmotion($emotion, 'myself')) {
                // Création du lien.
                $action = 'x';
                $link = $action . '_' . $source . '_' . $target . '_' . $meta;
                $htlink .= '&' . Actions::DEFAULT_COMMAND_ACTION_SIGN_LINK1 . '=' . $link . $this->_nebuleInstance->getActionTicket();

                // Préparation de l'icône de l'émotion.
                $icon = $this->convertReferenceImage($listEmotions1[$emotion], $emotion, 'iconInlineDisplay');
            } else {
                // Création du lien.
                $action = 'f';
                $link = $action . '_' . $source . '_' . $target . '_' . $meta;
                $htlink .= '&' . Actions::DEFAULT_COMMAND_ACTION_SIGN_LINK1 . '=' . $link . $this->_nebuleInstance->getActionTicket();

                // Préparation de l'icône de l'émotion.
                $icon = $this->convertReferenceImage($listEmotions0[$emotion], $emotion, 'iconInlineDisplay');
            }

            // Si connecté, l'icône est active.
            if ($this->_unlocked
                && $this->_nebuleInstance->getOption('permitWrite')
                && $this->_nebuleInstance->getOption('permitWriteLink')
            ) {
                $result .= $this->convertHypertextLink($icon, $htlink);
            } else {
                $result .= $icon;
            }

            // Détermine le nombre d'entités qui ont marqué cette émotion.
            if ($counts) {
                $count = $object->getMarkEmotionSize($emotion, 'all');
                if ($count > 0) {
                    $result .= $count . ' ';
                }
            }
        }

        return $result;
    }

    /**
     * Le CSS de la fonction getDisplayMessage().
     *
     * @return null
     */
    private function _getDisplayMessageCSS()
    {
        ?>

        <style type="text/css">
            /* CSS de la fonction getDisplayMessage(). */
            .layoutMessage {
                margin: 5px 0 0 5px;
                border: 0;
                background: none;
                display: inline-block;
                vertical-align: top;
            }

            .messageDisplay {
                background: rgba(255, 255, 255, 0.333);
            }

            .messageDisplay .layoutObject {
                margin: 0;
            }

            .messageDisplaySmall {
                font-size: 32px;
            }

            .messageDisplayMedium {
                font-size: 64px;
            }

            .messageDisplayLarge {
                font-size: 128px;
            }

            .messageDisplaySmallShort {
                width: 8em;
            }

            .messageDisplayMediumShort {
                width: 6em;
            }

            .messageDisplayLargeShort {
                width: 5em;
            }

            .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                width: 256px;
            }

            @media screen and (min-width: 320px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 310px;
                }
            }

            @media screen and (min-width: 480px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 470px;
                }
            }

            @media screen and (min-width: 600px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 590px;
                }
            }

            @media screen and (min-width: 768px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 758px;
                }
            }

            @media screen and (min-width: 1024px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 914px;
                }
            }

            @media screen and (min-width: 1200px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 943px;
                }
            }

            @media screen and (min-width: 1600px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 1343px;
                }
            }

            @media screen and (min-width: 1920px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 1663px;
                }
            }

            @media screen and (min-width: 2048px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 1040px;
                }
            }

            @media screen and (min-width: 2400px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 1240px;
                }
            }

            @media screen and (min-width: 3840px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 2000px;
                }
            }

            @media screen and (min-width: 4096px) {
                .messageDisplaySmallLong, .messageDisplayMediumLong, .messageDisplayLargeLong {
                    width: 2050px;
                }
            }

            .messageHeader a:link, .messageHeader a:visited, .messageFooter a:link, .messageFooter a:visited {
                font-weight: bold;
                text-decoration: none;
                color: #000000;
            }

            .messageHeader a:hover, .messageHeader a:active, .messageFooter a:hover, .messageFooter a:active {
                font-weight: bold;
                text-decoration: underline;
                color: #000000;
            }

            .messageHeaderSmall {
                height: 16px;
                padding: 2px 2px 0 2px;
                font-size: 16px;
                margin-bottom: 2px;
                border: 0;
            }

            .messageHeaderMedium {
                height: 16px;
                padding: 2px 2px 0 2px;
                font-size: 16px;
                margin-bottom: 2px;
                border: 0;
            }

            .messageHeaderLarge {
                height: 64px;
                padding: 5px 5px 0 5px;
                font-size: 64px;
                margin-bottom: 2px;
                border: 0;
            }

            .messageFooterSmall {
                height: 16px;
                padding: 0 2px 2px 2px;
                font-size: 16px;
                margin-bottom: 8px;
                border: 0;
            }

            .messageFooterMedium {
                height: 16px;
                padding: 0 2px 2px 2px;
                font-size: 16px;
                margin-bottom: 8px;
                border: 0;
            }

            .messageFooterLarge {
                height: 64px;
                padding: 0 5px 5px 5px;
                font-size: 64px;
                margin-bottom: 16px;
                border: 0;
            }

            .messageHeaderDate {
                height: 16px;
                line-height: 16px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 12px;
                float: right;
                color: #454545
            }

            .messageFooterEntity {
                height: 16px;
                line-height: 16px;
                overflow: hidden;
                white-space: nowrap;
                font-size: 12px;
                float: right;
            }

            .messageFooterEntity img {
                height: 16px;
                width: 16px;
            }

            .messageFooterEmots {
                height: 16px;
                font-size: 16px;
                float: left;
            }

            .messageFooterEmots img {
                height: 1em;
                width: 1em;
            }

            .messageHeaderFlags {
                height: 16px;
                font-size: 16px;
                float: left;
            }

            .messageHeaderFlags img {
                height: 1em;
                width: 1em;
            }

            .messageHeaderFlagsPrt img {
                margin-left: 3px;
            }

            .messageFooterFlags {
                height: 16px;
                font-size: 16px;
                float: left;
            }

            .messageFooterFlags img {
                height: 1em;
                width: 1em;
            }

            .messageFooterFlagsPrt img {
                margin-left: 3px;
            }

            .messageContent {
                font-size: 0.8rem;
                border: 0;
                padding: 3px;
                margin: 0;
                color: #000000;
                overflow: auto;
            }

            .messageContentShort {
                width: 378px;
                max-height: 378px;
            }

            .messageContentText {
                background: rgba(255, 255, 255, 0.666);
                text-align: left;
            }

            .messageContentImage {
                background: rgba(255, 255, 255, 0.12);
                text-align: center;
            }

            .messageContentImage img {
                height: auto;
                max-width: 100%;
            }
        </style>
        <?php
    }

    /**
     * Retourne la représentation html du message d'une conversation en fonction des paramètres passés.
     *
     * Les paramètres d'activation de contenus :
     * - enableDisplayColor : Affiche le carré de couleur.
     *     Par défaut true : affiche le carré de couleur.
     *     Boolean
     * - enableDisplayIcon : Affiche le carré avec l'image du type message sur la couleur de l'objet en fond.
     *     Par défaut true : affiche le carré de l'image/icône.
     *     Boolean
     *
     * Les paramètres de définition de contenus :
     * - social : Détermine le niveau social de tri des liens.
     *     Par défaut vide : utilise le niveau social par défaut.
     *     String
     *
     * @param Link $link
     * @param array $param
     * @return string
     */
    public function getDisplayMessage(Link $link, array $param)
    {
        $result = '';

        // Prépare l'objet.
        $messageInstance = $this->_nebuleInstance->convertIdToTypedObjectInstance($link->getHashTarget_disabled());
        $signerInstance = $this->_nebuleInstance->convertIdToTypedObjectInstance($link->getHashSigner_disabled());

        // Prépare les paramètres d'activation de contenus.
        if (!isset($param['enableDisplayColor'])
            || $param['enableDisplayColor'] !== false
        ) {
            $param['enableDisplayColor'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayIcon'])
            || $param['enableDisplayIcon'] !== false
        ) {
            $param['enableDisplayIcon'] = true; // Par défaut à true.
        }

        if (!isset($param['enableDisplayRefs'])
            || $param['enableDisplayRefs'] !== false
        ) {
            $param['enableDisplayRefs'] = true; // Par défaut à true.
        }

        if (!isset($param['objectRefs'])
            || sizeof($param['objectRefs']) == 0
        ) {
            $param['objectRefs'] = array($signerInstance);
        }

        if (!isset($param['enableDisplayFlagProtection'])
            || $param['enableDisplayFlagProtection'] !== true
            || !$this->_nebuleInstance->getOption('permitProtectedObject')
        ) {
            $param['enableDisplayFlagProtection'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlagObfuscate'])
            || $param['enableDisplayFlagObfuscate'] !== true
            || !$this->_nebuleInstance->getOption('permitObfuscatedLink')
        ) {
            $param['enableDisplayFlagObfuscate'] = false; // Par défaut à false.
        }

        if (!isset($param['enableDisplayFlagState'])
            || $param['enableDisplayFlagState'] !== false
        ) {
            $param['enableDisplayFlagState'] = true; // Par défaut à true.
        }


        if ($param['enableDisplayFlagProtection']) {
            if (!isset($param['flagProtection'])
                || !is_bool($param['flagProtection'])
            ) {
                $param['flagProtection'] = $messageInstance->getMarkProtected();
            }

            if (!isset($param['flagProtectionIcon'])
                || $param['flagProtectionIcon'] == ''
                || !ctype_xdigit($param['flagProtectionIcon'])
                || !$this->_ioInstance->checkLinkPresent($param['flagProtectionIcon'])
            ) {
                $param['flagProtectionIcon'] = self::DEFAULT_ICON_LK;
            }
            if (isset($param['flagProtectionText'])) {
                $param['flagProtectionText'] = trim(filter_var($param['flagProtectionText'], FILTER_SANITIZE_STRING));
            }
            if (!isset($param['flagProtectionText'])
                || trim($param['flagProtectionText']) == ''
            ) {
                if ($param['flagProtection']) {
                    $param['flagProtectionText'] = ':::display:object:flag:protected';
                } else {
                    $param['flagProtectionText'] = ':::display:object:flag:unprotected';
                }
            }
            if (isset($param['flagProtectionLink'])) {
                $param['flagProtectionLink'] = trim(filter_var($param['flagProtectionLink'], FILTER_SANITIZE_URL));
            }
            if (!isset($param['flagProtectionLink'])
                || trim($param['flagProtectionLink']) == ''
            ) {
                $param['flagProtectionLink'] = null;
            }
        }


        if ($param['enableDisplayFlagObfuscate']) {
            if (!isset($param['flagObfuscate'])
                || !is_bool($param['flagObfuscate'])
            ) {
                $param['flagObfuscate'] = $link->getObfuscated();
            }

            if (!isset($param['flagObfuscateIcon'])
                || $param['flagObfuscateIcon'] == ''
                || !ctype_xdigit($param['flagObfuscateIcon'])
                || !$this->_ioInstance->checkLinkPresent($param['flagObfuscateIcon'])
            ) {
                $param['flagObfuscateIcon'] = self::DEFAULT_ICON_LC;
            }
            if (isset($param['flagObfuscateText'])) {
                $param['flagObfuscateText'] = trim(filter_var($param['flagObfuscateText'], FILTER_SANITIZE_STRING));
            }
            if (!isset($param['flagObfuscateText'])
                || trim($param['flagObfuscateText']) == ''
            ) {
                if ($param['flagObfuscate']) {
                    $param['flagObfuscateText'] = ':::display:object:flag:obfuscated';
                } else {
                    $param['flagObfuscateText'] = ':::display:object:flag:unobfuscated';
                }
            }
            if (isset($param['flagObfuscateLink'])) {
                $param['flagObfuscateLink'] = trim(filter_var($param['flagObfuscateLink'], FILTER_SANITIZE_URL));
            }
            if (!isset($param['flagObfuscateLink'])
                || trim($param['flagObfuscateLink']) == ''
            ) {
                $param['flagObfuscateLink'] = null;
            }
        } else {
            $param['flagObfuscate'] = false;
        }


        $sizeCSS = 'Medium';
        if (!isset($param['displaySize'])) {
            $param['displaySize'] = 'medium';
            $sizeCSS = 'Medium';
        } else {
            switch ($param['displaySize']) {
                case 'tiny':
                    $sizeCSS = 'Tiny';
                    break;
                case 'small':
                    $sizeCSS = 'Small';
                    break;
                case 'large':
                    $sizeCSS = 'Large';
                    break;
                case 'full':
                    $sizeCSS = 'Full';
                    break;
                default:
                    $param['displaySize'] = 'medium';
                    $sizeCSS = 'Medium';
                    break;
            }
        }

        $ratioCSS = 'short';
        if (!isset($param['displayRatio'])) {
            $param['displayRatio'] = 'short';
            $ratioCSS = 'Short';
        } else {
            switch ($param['displayRatio']) {
                case 'long':
                    $ratioCSS = 'Long';
                    break;
                default:
                    $param['displayRatio'] = 'short';
                    $ratioCSS = 'Short';
                    break;
            }
        }

        // Assemble les contenus.
        $divDisplayOpen = '<div class="layoutMessage">' . "\n";
        $divDisplayOpen .= ' <div class="messageDisplay messageDisplay' . $sizeCSS . ' messageDisplay' . $sizeCSS . $ratioCSS . '">' . "\n";
        $divDisplayClose = ' </div>' . "\n";
        $divDisplayClose .= '</div>' . "\n";

        $divHeaderOpen = '';
        $divHeaderClose = '';
        $headerContent = '';

        $divObjectOpen = '';
        $divObjectClose = '';
        $objectContent = '';
        $divObjectFlagsOpen = '';
        $divObjectFlagsClose = '';
        $objectFlagsContent = '';

        $divFooterOpen = '';
        $divFooterClose = '';
        $footerContent = '';
        $divHeaderFlagsOpen = '';
        $divHeaderFlagsClose = '';
        $headerFlagsContent = '';
        $divHeaderDateOpen = '';
        $divHeaderDateClose = '';
        $headerDateContent = '';

        $divFooterFlagsOpen = '';
        $divFooterFlagsClose = '';
        $footerFlagsContent = '';
        $divFooterEmotsOpen = '';
        $divFooterEmotsClose = '';
        $footerEmotsContent = '';
        $divFooterEntityOpen = '';
        $divFooterEntityClose = '';
        $footerEntityContent = '';

        // Si taille petite (1).
        if ($param['displaySize'] == 'small') {
            $divFooterOpen = ' <div class="messageFooter messageFooter' . $sizeCSS . '">' . "\n";
            $divFooterClose = ' </div>' . "\n";
            $divFooterFlagsOpen = '  <div class="messageFooterFlags">';
            $divFooterFlagsClose = '</div>' . "\n";
            $divFooterEntityOpen = '  <div class="messageFooterEntity">';
            $divFooterEntityClose = '</div>' . "\n";

            // Ajoute le bandeau bas du message.
            $footerFlagsContent .= $this->_getDisplayMessageFlags($messageInstance, $link, $param, 'Footer');

            // Prépare l'entité.
            $footerEntityContent .= $this->_getDisplayObjectRefs($param['objectRefs']);

            // Assemble la partie footer.
            $footerContent .= $divFooterFlagsOpen . $footerFlagsContent . $divFooterFlagsClose;
            $footerContent .= $divFooterEntityOpen . $footerEntityContent . $divFooterEntityClose;
        } // Si taille moyenne (2).
        elseif ($param['displaySize'] == 'medium') {
            $divHeaderOpen = ' <div class="messageHeader messageHeader' . $sizeCSS . '">' . "\n";
            $divHeaderClose = ' </div>' . "\n";
            $divHeaderFlagsOpen = '  <div class="messageHeaderFlags">';
            $divHeaderFlagsClose = '</div>' . "\n";
            $divHeaderDateOpen = '  <div class="messageHeaderDate">';
            $divHeaderDateClose = '</div>' . "\n";
            $divFooterOpen = ' <div class="messageFooter messageFooter' . $sizeCSS . '">' . "\n";
            $divFooterClose = ' </div>' . "\n";
            $divFooterEmotsOpen = '  <div class="messageFooterEmots">';
            $divFooterEmotsClose = '</div>' . "\n";
            $divFooterEntityOpen = '  <div class="messageFooterEntity">';
            $divFooterEntityClose = '</div>' . "\n";

            // Ajoute le bandeau haut du message.
            $headerFlagsContent .= $this->_getDisplayMessageFlags($messageInstance, $link, $param, 'Footer');

            // Prépare la date.
            $headerDateContent = $this->convertDate($link->getDate_disabled());

            // Ajoute le bandeau bas du message.
            $footerEmotsContent .= $this->_getDisplayObjectFlagEmotions($messageInstance, false);

            // Prépare l'entité.
            $footerEntityContent .= $this->_getDisplayObjectRefs($param['objectRefs']);

            // Assemble la partie header.
            $headerContent .= $divHeaderFlagsOpen . $headerFlagsContent . $divHeaderFlagsClose;
            $headerContent .= $divHeaderDateOpen . $headerDateContent . $divHeaderDateClose;

            // Assemble la partie footer.
            $footerContent .= $divFooterEmotsOpen . $footerEmotsContent . $divFooterEmotsClose;
            $footerContent .= $divFooterEntityOpen . $footerEntityContent . $divFooterEntityClose;
        } // Si taille grande (3).
        elseif ($param['displaySize'] == 'large') // @todo pas utilisé...
        {
            // Prépare le titre de l'objet message.
            $paramObject = array(
                'enableDisplayColor' => true,
                'enableDisplayIcon' => true,
                'enableDisplayIconApp' => false,
                'enableDisplayRefs' => true,
                'enableDisplayName' => true,
                'enableDisplayID' => false,
                'enableDisplayFlags' => false,
                'enableDisplayFlagEmotions' => $param['enableDisplayFlagEmotions'],
                'enableDisplayFlagProtection' => $this->_nebuleInstance->getOption('permitProtectedObject'),
                'enableDisplayFlagObfuscate' => $this->_nebuleInstance->getOption('permitObfuscatedLink'),
                'enableDisplayFlagUnlocked' => false,
                'enableDisplayFlagActivated' => false,
                'enableDisplayFlagState' => false,
                'enableDisplayStatus' => false,
                'enableDisplayContent' => false,
                'enableDisplayLink2Object' => true,
                'enableDisplayObjectActions' => true,
                'enableDisplayLink2Refs' => true,
                'enableDisplaySelfHook' => true,
                'enableDisplayTypeHook' => true,
                'enableDisplayJS' => true,
                'social' => '',
                'objectType' => null,
                'objectName' => $param['name'],
                'objectAppShortName' => null,
                'objectIcon' => $param['objectIcon'],
                'objectRefs' => array($param['signer']),
                'link2Object' => '',
                'flagProtection' => false,
                'flagProtectionIcon' => '',
                'flagProtectionText' => '',
                'flagProtectionLink' => '',
                'flagObfuscate' => false,
                'flagObfuscateIcon' => '',
                'flagObfuscateText' => '',
                'flagObfuscateLink' => '',
                'flagUnlocked' => false,
                'flagUnlockedIcon' => '',
                'flagUnlockedText' => '',
                'flagUnlockedLink' => '',
                'flagActivated' => false,
                'flagActivatedDesc' => '',
                'flagState' => '',
                'flagStateDesc' => '',
                'flagMessage' => '',
                'flagTargetObject' => '',
                'status' => '',
                'displaySize' => 'medium',
                'displayRatio' => 'short',
                'selfHookList' => array(),
                'selfHookName' => '',
                'typeHookName' => '',
            );
        }
        // Sinon rien.

        // Affiche le contenu, si pas protégé et présent.
        if ($messageInstance->getMarkProtected()
            && !$this->_unlocked
        ) {
            $paramInfo = array(
                'displaySize' => 'small',
                'enableDisplayIcon' => true,
                'displayRatio' => $param['displayRatio'],
                'informationType' => 'warn',
            );
            $objectContent = $this->getDisplayInformation(':::display:content:ObjectProctected', $paramInfo);
        } else {
            $objectContent = $this->getDisplayObjectContent($messageInstance, $param['displaySize'], $param['displayRatio'], false);
        }

        // Prépare le résultat à afficher.
        $result = $divDisplayOpen;
        $result .= $divHeaderOpen . $headerContent . $divHeaderClose;
        $result .= $divObjectOpen . $objectContent . $divObjectClose;
        $result .= $divFooterOpen . $footerContent . $divFooterClose;
        $result .= $divDisplayClose;

        return $result;
    }

    /**
     * Pour la fonction getDisplayMessage().
     * Prépare les icônes des drapeaux.
     *
     * @param Node $messageInstance
     * @param Link $link
     * @param array $param
     * @param string $cssCode
     * @return string
     */
    private function _getDisplayMessageFlags($messageInstance, $link, array $param, $cssCode)
    {
        $result = '<span class="message' . $cssCode . 'FlagsObj">';
        // Ajoute le lien.
        if (isset($param['link2Object'])
            && $param['link2Object'] != null
        ) {
            $result .= '<a href="' . $param['link2Object'] . '">';
        } else {
            $result .= '<a href="' . $this->_prepareDefaultObjectOrGroupOrEntityHtlink($messageInstance) . '">';
        }

        // Ajoute la couleur de l'objet.
        if (isset($param['enableDisplayColor'])) {
            $result .= $this->_prepareObjectColor($messageInstance);
        }

        // Ajoute l'image de l'objet.
        if (isset($param['enableDisplayIcon'])) {
            $result .= $this->_prepareObjectIcon($messageInstance, self::DEFAULT_ICON_CVTOBJ);
        }
        $result .= '</a></span>';

        // Prépare les flags.
        if ($param['enableDisplayFlags']) {
            $result .= '<span class="message' . $cssCode . 'FlagsPrt">';

            if ($param['enableDisplayFlagState']) {
                if (!isset($param['flagState'])
                    || strlen(trim($param['flagState'])) == 0
                ) {
                    if ($link->getValid()) {
                        $param['flagState'] = 'o';
                    } else {
                        $param['flagState'] = 'e';
                    }
                }

                if ($param['flagState'] == 'o') {
                    $result .= $this->_getDisplayObjectFlag(
                        false,
                        self::DEFAULT_ICON_IOK,
                        ':::display:link:OK',
                        '');
                } else {
                    $result .= $this->_getDisplayObjectFlag(
                        false,
                        self::DEFAULT_ICON_IERR,
                        ':::display:link:errorInvalid',
                        '');
                }
            }

            if ($param['enableDisplayFlagProtection']) {
                if ($param['flagProtectionLink'] != '') {
                    $result .= '<a href="' . $param['flagProtectionLink'] . '">';
                }
                $result .= $this->_getDisplayObjectFlag(
                    $param['flagProtection'],
                    $param['flagProtectionIcon'],
                    $param['flagProtectionText'],
                    $param['flagProtectionText']);
                if ($param['flagProtectionLink'] != '') {
                    $result .= '</a>';
                }
            }
            if ($param['enableDisplayFlagObfuscate']) {
                if ($param['flagObfuscateLink'] != '') {
                    $result .= '<a href="' . $param['flagObfuscateLink'] . '">';
                }
                $result .= $this->_getDisplayObjectFlag(
                    $param['flagObfuscate'],
                    $param['flagObfuscateIcon'],
                    $param['flagObfuscateText'],
                    $param['flagObfuscateText']);
                if ($param['flagObfuscateLink'] != '') {
                    $result .= '</a>';
                }
            }
            $result .= '</span>' . "\n";
        }

        return $result;
    }

    /**
     * Pour la fonction getDisplayObject().
     * Prépare les actions définies par un point d'ancrage pour un objet.
     * Le point d'ancrage permet aux modules d'ajouter des actions.
     *
     * @param string $selfHookName
     * @param string $typeHookName
     * @param Node $object
     * @param boolean $enableDisplayJS
     * @param string $size
     * @param array $appHookList
     * @return string
     */
    private function _getDisplayObjectHookList($selfHookName, $typeHookName, $object, $enableDisplayJS, $size, $appHookList = array())
    {
        $result = '';
        $dispHookList = array();
        $dispHookListT = array();
        $modules = $this->_applicationInstance->getModulesListInstances();

        $iconNoJS = 'NoJS';
        if ($enableDisplayJS) {
            $iconNoJS = '';
        }

        // Ajoute les actions demandées spécifiquement et individuellement.
        $i = 0;
        if (sizeof($appHookList) != 0) {
            foreach ($appHookList as $appHook) {
                if ($appHook['name'] != '') {
                    $dispHookList[$i]['moduleName'] = '&nbsp;';
                    $dispHookList[$i]['name'] = $this->getTraduction($appHook['name']);
                    $dispHookList[$i]['icon'] = $appHook['icon'];
                    if ($dispHookList[$i]['icon'] == '') {
                        $dispHookList[$i]['icon'] = self::DEFAULT_ICON_LSTOBJ;
                    }
                    $dispHookList[$i]['desc'] = $this->getTraduction($appHook['desc']);
                    $dispHookList[$i]['link'] = $appHook['link'];
                    if (isset($appHook['css'])
                        && $appHook['css'] != ''
                    ) {
                        $dispHookList[$i]['cssid'] = 'id="' . $appHook['css'] . '"';
                    } else {
                        $dispHookList[$i]['cssid'] = 'id="' . $selfHookName . '"';
                    }
                    $dispHookList[$i]['hookType'] = 'Self';
                    $i++;
                }
            }
        }

        // Ajoute les actions spécifiques à l'objet pour le module en cours.
        foreach ($modules as $module) {
            if ($module->getCommandName() == $this->_currentDisplayMode) {
                // Liste les points d'encrages à afficher.
                if (substr($module->getInterface(), 0, 1) == '1'
                    || substr($module->getInterface(), 0, 1) == '2'
                ) {
                    $appHookList = $module->getHookList($selfHookName);
                } else {
                    $appHookList = $module->getHookList($selfHookName, $object);
                }

                if (sizeof($appHookList) != 0) {
                    foreach ($appHookList as $appHook) {
                        if ($appHook['name'] != '') {
                            $dispHookList[$i]['moduleName'] = $module->getTraduction($module->getName());
                            $dispHookList[$i]['name'] = $module->getTraduction($appHook['name']);
                            $dispHookList[$i]['icon'] = $appHook['icon'];
                            if ($dispHookList[$i]['icon'] == '') {
                                $dispHookList[$i]['icon'] = self::DEFAULT_ICON_LSTOBJ;
                            }
                            $dispHookList[$i]['desc'] = $module->getTraduction($appHook['desc']);
                            $dispHookList[$i]['link'] = $appHook['link'];
                            if (isset($appHook['css'])
                                && $appHook['css'] != ''
                            ) {
                                $dispHookList[$i]['cssid'] = 'id="' . $appHook['css'] . '"';
                            } else {
                                $dispHookList[$i]['cssid'] = 'id="' . $selfHookName . $i . '"';
                            }
                            $dispHookList[$i]['hookType'] = 'Self';
                            $i++;
                        }
                    }
                }
            }
        }

        // Ajoute les actions spécifiques à l'objet pour tout sauf le module en cours.
        foreach ($modules as $module) {
            if ($module->getCommandName() != $this->_currentDisplayMode) {
                // Liste les points d'encrages à afficher.
                if (substr($module->getInterface(), 0, 1) == '1'
                    || substr($module->getInterface(), 0, 1) == '2'
                ) {
                    $appHookList = $module->getHookList($selfHookName);
                } else {
                    $appHookList = $module->getHookList($selfHookName, $object);
                }

                if (sizeof($appHookList) != 0) {
                    foreach ($appHookList as $appHook) {
                        if ($appHook['name'] != '') {
                            $dispHookList[$i]['moduleName'] = $module->getTraduction($module->getName());
                            $dispHookList[$i]['name'] = $this->getTraduction($appHook['name']);
                            $dispHookList[$i]['icon'] = $appHook['icon'];
                            if ($dispHookList[$i]['icon'] == '') {
                                $dispHookList[$i]['icon'] = self::DEFAULT_ICON_LSTOBJ;
                            }
                            $dispHookList[$i]['desc'] = $this->getTraduction($appHook['desc']);
                            $dispHookList[$i]['link'] = $appHook['link'];
                            if (isset($appHook['css'])
                                && $appHook['css'] != ''
                            ) {
                                $dispHookList[$i]['cssid'] = 'id="' . $appHook['css'] . '"';
                            } else {
                                $dispHookList[$i]['cssid'] = 'id="' . $selfHookName . $i . '"';
                            }
                            $dispHookList[$i]['hookType'] = 'Self';
                            $i++;
                        }
                    }
                }
            }
        }

        // Ajoute les actions spécifiques au type d'objet.
        $i = 0;
        foreach ($modules as $module) {
            // Liste les points d'encrages à afficher.
            if ($module->getInterface() == '3.0') {
                $appHookList = $module->getHookList($typeHookName, $object);
            } else {
                $appHookList = $module->getHookList($typeHookName);
            }
            if (sizeof($appHookList) != 0) {
                foreach ($appHookList as $appHook) {
                    if ($appHook['name'] != '') {
                        $dispHookListT[$i]['moduleName'] = $module->getTraduction($module->getName());
                        $dispHookListT[$i]['name'] = $module->getTraduction($appHook['name']);
                        $dispHookListT[$i]['icon'] = $appHook['icon'];
                        if ($dispHookListT[$i]['icon'] == '') {
                            $dispHookListT[$i]['icon'] = self::DEFAULT_ICON_LSTOBJ;
                        }
                        $dispHookListT[$i]['desc'] = $module->getTraduction($appHook['desc']);
                        $dispHookListT[$i]['link'] = $appHook['link'];
                        if (isset($appHook['css'])
                            && $appHook['css'] != ''
                        ) {
                            $dispHookListT[$i]['cssid'] = 'id="' . $appHook['css'] . '"';
                        } else {
                            $dispHookListT[$i]['cssid'] = 'id="' . $typeHookName . $i . '"';
                        }
                        $dispHookListT[$i]['hookType'] = 'Type';
                        $i++;
                    }
                }
            }
        }
        unset($modules, $module, $appHookList, $appHook);

        // Affiche les points d'encrages.
        if (sizeof($dispHookList) != 0) {
            foreach ($dispHookList as $dispHook) {
                /*	$result .= ' <a href="'.$dispHook['link'].'">'."\n";
				$result .= '  <div class="objectMenuContentAction'.$iconNoJS.' objectMenuContentAction'.$size.' objectMenuContentAction'.$dispHook['hookType'].'" '.$dispHook['cssid'].'>'."\n";
				$result .= '   <div class="objectMenuContentAction-icon'.$iconNoJS.'">';
				$result .= $this->convertUpdateImage($dispHook['icon'], $dispHook['name']);
				$result .= '</div>'."\n";
				$result .= '   <div class="objectMenuContentAction-modname">';
				$result .= '<p>'.$dispHook['moduleName'].'</p>';
				$result .= '</div>'."\n";
				$result .= '   <div class="objectMenuContentAction-title">';
				$result .= '<p>'.$dispHook['name'].'</p>';
				$result .= '</div>'."\n";
				$result .= '   <div class="objectMenuContentAction-text">';
				if ( $enableDisplayJS )
				{
					$result .= '<p>'.$dispHook['desc'].'&nbsp;</p>';
				}
				$result .= '</div>'."\n";
				$result .= '  </div>'."\n";
				$result .= ' </a>'."\n"; */

                $result .= $this->_getDisplayHookAction($dispHook, $enableDisplayJS, $size);
            }
        }
        unset($dispHookList, $dispHook);

        // Affiche les points d'encrages.
        if (sizeof($dispHookListT) != 0) {
            foreach ($dispHookListT as $dispHook) {
                /*	$result .= ' <a href="'.$dispHook['link'].'">'."\n";
				$result .= '  <div class="objectMenuContentAction'.$iconNoJS.' objectMenuContentAction'.$size.' objectMenuContentAction'.$dispHook['hookType'].'" '.$dispHook['cssid'].'>'."\n";
				$result .= '   <div class="objectMenuContentAction-icon'.$iconNoJS.'">';
				$result .= $this->convertUpdateImage($dispHook['icon'], $dispHook['name']);
				$result .= '</div>'."\n";
				$result .= '   <div class="objectMenuContentAction-modname">';
				$result .= '<p>'.$dispHook['moduleName'].'</p>';
				$result .= '</div>'."\n";
				$result .= '   <div class="objectMenuContentAction-title">';
				$result .= '<p>'.$dispHook['name'].'</p>';
				$result .= '</div>'."\n";
				$result .= '   <div class="objectMenuContentAction-text">';
				if ( $enableDisplayJS )
				{
					$result .= '<p>'.$dispHook['desc'].'&nbsp;</p>';
				}
				$result .= '</div>'."\n";
				$result .= '  </div>'."\n";
				$result .= ' </a>'."\n"; */

                $result .= $this->_getDisplayHookAction($dispHook, $enableDisplayJS, $size);
            }
        }
        unset($dispHookListT, $dispHook);

        return $result;
    }

    /**
     * Affiche un bouton des actions définies par un point d'ancrage pour un objet.
     *
     * @param array $dispHook
     * @param bool $enableDisplayJS
     * @param string $size
     * @return string
     */
    public function getDisplayHookAction(array $dispHook, bool $enableDisplayJS, $size)
    {
        if (!is_array($dispHook)) {
            return $result;
        }

        return $this->_getDisplayHookAction($dispHook, $enableDisplayJS, $size);
    }

    /**
     * Affiche un bouton des actions définies par un point d'ancrage pour un objet.
     * Le point d'ancrage permet aux modules d'ajouter des actions.
     *
     * Fonction interne.
     * Pour la fonction _getDisplayObjectHookList
     *
     * @param array $dispHook
     * @param bool $enableDisplayJS
     * @param unknown $size
     * @return string
     */
    private function _getDisplayHookAction($dispHook, $enableDisplayJS, $size)
    {
        $result = '';

        $iconNoJS = 'NoJS';
        if ($enableDisplayJS) {
            $iconNoJS = '';
        }

        // Verifications
        if (!isset($dispHook['link'])) {
            $dispHook['link'] = '';
        }
        if (!isset($dispHook['hookType'])) {
            $dispHook['hookType'] = '';
        }
        if (!isset($dispHook['icon'])) {
            $dispHook['icon'] = '';
        }
        if (!isset($dispHook['name'])) {
            $dispHook['name'] = '';
        }
        if (!isset($dispHook['moduleName'])) {
            $dispHook['moduleName'] = '';
        }
        if (!isset($dispHook['desc'])) {
            $dispHook['desc'] = '';
        }

        if ($dispHook['link'] != '') {
            $result .= ' <a href="' . $dispHook['link'] . '">' . "\n";
        }
        $result .= '  <div class="objectMenuContentAction' . $iconNoJS . ' objectMenuContentAction' . $size . ' objectMenuContentAction' . $dispHook['hookType'] . '" ' . $dispHook['link'] . '>' . "\n";
        $result .= '   <div class="objectMenuContentAction-icon' . $iconNoJS . '">';
        $result .= $this->convertUpdateImage($dispHook['icon'], $dispHook['name']);
        $result .= '</div>' . "\n";
        $result .= '   <div class="objectMenuContentAction-modname">';
        $result .= '<p>' . $dispHook['moduleName'] . '</p>';
        $result .= '</div>' . "\n";
        $result .= '   <div class="objectMenuContentAction-title">';
        $result .= '<p>' . $dispHook['name'] . '</p>';
        $result .= '</div>' . "\n";
        $result .= '   <div class="objectMenuContentAction-text">';
        if ($enableDisplayJS
            && $dispHook['desc'] != ''
        ) {
            $result .= '<p>' . $dispHook['desc'] . '&nbsp;</p>';
        }
        $result .= '</div>' . "\n";
        $result .= '  </div>' . "\n";
        if ($dispHook['link'] != '') {
            $result .= ' </a>' . "\n";
        }

        return $result;
    }


    /**
     * Le CSS des fonctions getDisplayObjectContent() et getDisplayAsObjectContent().
     *
     * @return null
     */
    private function _getDisplayObjectContentCSS()
    {
        ?>

        <style type="text/css">
            /* CSS des fonctions getDisplayObjectContent() et getDisplayAsObjectContent(). */
            .objectContent {
            }

            /* .layoutInformation { max-width:2000px; } */
            .objectContent .layoutInformation {
                margin-left: -3px;
            }

            .objectContentObject {
            }

            .objectContentEntity {
            }

            .objectContentGroup {
            }

            .objectContentConversation {
            }

            .objectContentText {
                font-size: 0.8rem;
                background: rgba(255, 255, 255, 0.666);
                text-align: left;
                color: #000000;
                font-family: sans-serif;
            }

            .objectContentCode {
                font-size: 0.8rem;
                background: rgba(255, 255, 255, 0.666);
                text-align: left;
                color: #000000;
                font-family: monospace;
            }

            .objectContentAudio {
            }

            .objectContentImage {
                background: rgba(255, 255, 255, 0.12);
                text-align: center;
            }

            .objectContentImage img {
                height: auto;
                max-width: 100%;
            }
        </style>
        <?php
    }

    /**
     * Prépare à afficher le contenu d'un objet suivant sont type.
     *
     * @param string|Node $object
     * @param string $sizeCSS [tiny|small|medium|large|full]
     * @param string $ratioCSS [short|long]
     * @return string
     */
    public function getDisplayObjectContent($object, $sizeCSS = 'medium', $ratioCSS = '', $permitWarnProtected = true)
    {
        $result = '';

        if ($sizeCSS != 'full'
            && $sizeCSS != 'large'
            && $sizeCSS != 'medium'
            && $sizeCSS != 'small'
            && $sizeCSS != 'tiny'
        ) {
            $sizeCSS = 'medium';
        }

        if ($ratioCSS != 'short'
            && $ratioCSS != 'long'
        ) {
            $ratioCSS = 'short';
        }

        // Vérifie que c'est un objet.
        if (!is_a($object, 'Node')
            && !is_a($object, 'Group')
            && !is_a($object, 'Entity')
            && !is_a($object, 'Conversation')
            && !is_a($object, 'Currency')
            && !is_a($object, 'TokenPool')
            && !is_a($object, 'Token')
            && !is_a($object, 'Transaction')
            && !is_a($object, 'Wallet')
        ) {
            $object = $this->_nebuleInstance->newObject($object);
            $id = $object->getID();
            if ($object->getType('all') == nebule::REFERENCE_OBJECT_ENTITY
                && strpos($object->readOneLineAsText(Entity::ENTITY_MAX_SIZE), nebule::REFERENCE_ENTITY_HEADER) !== false
            ) {
                $object = $this->_nebuleInstance->newEntity($id);
            } elseif ($object->getIsGroup('all')) {
                $object = $this->_nebuleInstance->newGroup($id);
            } elseif ($object->getIsConversation('all')) {
                $object = $this->_nebuleInstance->newConversation($id);
            }
        }

        $type = $object->getType('all');

        $result .= '<div class="objectContent">' . "\n";

        // Affiche l'objet suivant son type.
        if (is_a($object, 'Entity')) {
            if ($object->checkPresent()) {
                if ($sizeCSS = 'medium' || $sizeCSS = 'full') {
                    $result .= '<div class="objectContentEntity">' . "\n<p>";
                    $result .= sprintf($this->_traductionInstance->getTraduction('::UniqueID'),
                        $this->convertInlineObjectColorIcon($object) . ' ' . '<b>' . $object->getID() . "</b>\n");
                    $result .= "</p>\n";

                    if ($sizeCSS = 'full') {
                        // Liste des localisations.
                        $localisations = $object->getLocalisationsID();
                        if (sizeof($localisations) > 0) {
                            $result .= '<table border="0"><tr><td><td>' . $this->_traductionInstance->getTraduction('::EntityLocalisation') . " :</td><td>\n";
                            foreach ($localisations as $localisation) {
                                $locObject = $this->_nebuleInstance->newObject($localisation);
                                $result .= "\t " . $this->convertInlineObjectColorIcon($localisation) . ' '
                                    . $this->convertHypertextLink(
                                        $locObject->readOneLineAsText(),
                                        $locObject->readOneLineAsText()
                                    ) . "<br />\n";
                            }
                            $result .= "</td></tr></table>\n";
                            unset($localisations, $localisation, $locObject);
                        }
                    }
                    $result .= "</div>\n";
                }
            } else {
                $result .= $this->convertLineMessage(':::display:content:errorNotAvailable', 'error');
            }
        } elseif (is_a($object, 'Group')) {
            $result .= '<div class="objectContentGroup">' . "\n\t<p>"
                . sprintf($this->_traductionInstance->getTraduction('::UniqueID'),
                    $this->convertInlineObjectColorIcon($object) . ' ' . '<b>' . $object->getID() . "</b>\n");
            if ($object->getMarkClosed()) {
                $result .= "<br />\n" . $this->_traductionInstance->getTraduction('::GroupeFerme') . ".\n";
            } else {
                $result .= "<br />\n" . $this->_traductionInstance->getTraduction('::GroupeOuvert') . ".\n";
            }
            $result .= "\t</p>\n</div>\n";
        } elseif (is_a($object, 'Conversation')) {
            $result .= '<div class="objectContentConversation">' . "\n\t<p>"
                . sprintf($this->_traductionInstance->getTraduction('::UniqueID'),
                    $this->convertInlineObjectColorIcon($object) . ' ' . '<b>' . $object->getID() . "</b>\n");
            if ($object->getMarkClosed()) {
                $result .= "<br />\n" . $this->_traductionInstance->getTraduction('::ConversationFermee') . ".\n";
            } else {
                $result .= "<br />\n" . $this->_traductionInstance->getTraduction('::ConversationOuverte') . ".\n";
            }
            $result .= "\t</p>\n</div>\n";
        } else {
            // C'est un objet.
            $result .= $this->getDisplayAsObjectContent($object, $sizeCSS, $ratioCSS, $permitWarnProtected);
        }

        $result .= "</div>\n";

        return $result;
    }

    /**
     * Prépare à afficher le contenu d'un objet comme objet pur.
     *
     * Affiche un objet sans tenir compte de son type nebule (Entity|Group|Conversation).
     * Mais affiche l'objet en fonction de son type mime déclaré.
     *
     * @param string|Node $object
     * @param string $sizeCSS [tiny|small|medium|large|full]
     * @param string $ratioCSS [short|long]
     * @return string
     */
    public function getDisplayAsObjectContent($object, $sizeCSS = 'medium', $ratioCSS = '', $permitWarnProtected = true)
    {
        $result = '';

        if ($sizeCSS != 'full'
            && $sizeCSS != 'large'
            && $sizeCSS != 'medium'
            && $sizeCSS != 'small'
            && $sizeCSS != 'tiny'
        ) {
            $sizeCSS = 'medium';
        }

        if ($ratioCSS != 'short'
            && $ratioCSS != 'long'
        ) {
            $ratioCSS = 'short';
        }

        // Vérifie que c'est un objet.
        if (!is_a($object, 'Node')
            && !is_a($object, 'Group')
            && !is_a($object, 'Entity')
            && !is_a($object, 'Conversation')
        ) {
            $object = $this->_nebuleInstance->newObject($object);
        }
        $id = $object->getID();

        // Vérifie si il est protégé
        $protected = $object->getMarkProtected();

        // Extrait les propriétés de l'objet.
        $name = $object->getFullName('all');
        $typemime = $object->getType('all');
        $danger = $object->getMarkDanger();
        $warning = $object->getMarkWarning();
        $ispresent = $object->checkPresent();
        $type = $this->_traductionInstance->getTraduction($typemime);

        $param = array(
            'enableDisplayIcon' => true,
            'displaySize' => $sizeCSS,
            'displayRatio' => $ratioCSS,
            'informationType' => 'error',
        );

        // Affichage du contenu.
        if ($danger) {
            $param['informationType'] = 'error';
            $result .= $this->getDisplayInformation(':::display:content:errorBan', $param);
            $result .= $this->getDisplayInformation(':::display:content:errorNotAvailable', $param);
        } elseif ($protected
            && !$this->_unlocked
        ) {
            $param['informationType'] = 'warn';
            $result .= $this->getDisplayInformation(':::display:content:ObjectProctected', $param);
            $result .= "<br />\n";
            $param['informationType'] = 'error';
            $result .= $this->getDisplayInformation(':::display:content:errorNotAvailable', $param);
        } elseif ($ispresent) {
            if ($warning) {
                $param['informationType'] = 'warn';
                $result .= $this->getDisplayInformation(':::display:content:warningTaggedWarning', $param);
            }
            if ($protected
                && $this->_unlocked
                && $permitWarnProtected
            ) {
                $param['informationType'] = 'warn';
                $result .= $this->getDisplayInformation(':::display:content:warningObjectProctected', $param);
            }

            switch ($typemime) {
                case nebule::REFERENCE_OBJECT_PNG :
                case nebule::REFERENCE_OBJECT_JPEG :
                    $content = $object->getContent(0);
                    if ($content != null) {
                        $result .= '<div class="objectContentObject objectContentImage"><img src="?o=' . $id
                            . '" alt="Image ' . $id . '"></div>' . "\n";
                    } else {
                        $param['informationType'] = 'error';
                        $result .= $this->getDisplayInformation(':::display:content:errorNotDisplayable', $param);
                    }
                    break;
                case nebule::REFERENCE_OBJECT_TEXT :
                    $content = htmlspecialchars($object->getContent(0));
                    if ($content != null) {
                        $result .= '<div class="objectContentObject objectContentText"><p>' . $content . '</p></div>' . "\n";
                    } else {
                        $param['informationType'] = 'error';
                        $result .= $this->getDisplayInformation(':::display:content:errorNotDisplayable', $param);
                    }
                    unset($content);
                    break;
                case nebule::REFERENCE_OBJECT_ENTITY :
                case nebule::REFERENCE_OBJECT_HTML :
                case nebule::REFERENCE_OBJECT_CSS :
                case nebule::REFERENCE_OBJECT_APP_PHP :
                case nebule::REFERENCE_OBJECT_PHP :
                case nebule::REFERENCE_NEBULE_OBJET_MONNAIE :
                case nebule::REFERENCE_NEBULE_OBJET_MONNAIE_SAC :
                case nebule::REFERENCE_NEBULE_OBJET_MONNAIE_JETON :
                    $content = htmlspecialchars($object->getContent(0));
                    if ($content != null) {
                        $result .= '<div class="objectContentObject objectContentCode"><pre>' . $content . '</pre></div>' . "\n";
                    } else {
                        $param['informationType'] = 'error';
                        $result .= $this->getDisplayInformation(':::display:content:errorNotDisplayable', $param);
                    }
                    unset($content);
                    break;
                case nebule::REFERENCE_OBJECT_MP3 :
                    $content = $object->getContent(0);
                    if ($content != null) {
                        $result .= '<div class="objectContentObject objectContentAudio"><audio controls><source src="?o=' . $id . '" type="audio/mp3" />' . $this->_traductionInstance->getTraduction(':::warn_NoAudioTagSupport') . '</audio></div>' . "\n";
                    } else {
                        $param['informationType'] = 'error';
                        $result .= $this->getDisplayInformation(':::display:content:errorNotDisplayable', $param);
                    }
                    break;
                case nebule::REFERENCE_OBJECT_OGG :
                    $content = $object->getContent(0);
                    if ($content != null) {
                        $result .= '<div class="objectContentObject objectContentAudio"><audio controls><source src="?o=' . $id . '" type="audio/ogg" />' . $this->_traductionInstance->getTraduction(':::warn_NoAudioTagSupport') . '</audio></div>' . "\n";
                    } else {
                        $param['informationType'] = 'error';
                        $result .= $this->getDisplayInformation(':::display:content:errorNotDisplayable', $param);
                    }
                    break;
                case nebule::REFERENCE_OBJECT_CRYPT_RSA :
                    $param['informationType'] = 'warn';
                    $result .= $this->getDisplayInformation(':::display:content:ObjectProctected', $param);
                    break;
                default :
                    $param['informationType'] = 'error';
                    $result .= $this->getDisplayInformation(':::display:content:errorNotDisplayable', $param);
                    break;
            }
        } else {
            $param['informationType'] = 'error';
            $result .= $this->getDisplayInformation(':::display:content:errorNotAvailable', $param);
        }

        // Recherche si l'objet a une mise à jour.
        $instance = $this->_applicationInstance->getCurrentObjectInstance();
        $UpdateID = $instance->findUpdate(false, false);
        if ($instance->getID() != $UpdateID) {
            $param['informationType'] = 'information';
            $param2 = array(
                'enableDisplayColor' => true,
                'enableDisplayIcon' => true,
                'enableDisplayName' => true,
                'enableDisplayLink2Object' => true,
                'enableDisplayObjectActions' => false,
                'displaySize' => 'tiny',
                'enableDisplayContent' => false, // Doit impérativement être à false pour éviter une boucle de la mort.
            );
            $result .= "</div>\n";
            $result .= '<div class="objectContent">' . "\n";
            $result .= $this->getDisplayInformation(
                $this->_applicationInstance->getTraductionInstance()->getTraduction(':::display:content:ObjectHaveUpdate')
                . '<br />' . $this->getDisplayObject($UpdateID, $param2),
                $param
            );
        }
        unset($instance, $UpdateID, $param, $param2);

        return $result;
    }


    /**
     * Le CSS de la fonction getDisplayObjectsList().
     *
     * @return null
     */
    private function _getDisplayObjectsListCSS()
    {
        ?>

        <style type="text/css">
            /* CSS de la fonction getDisplayObjectsList(). */
            .layoutObjectsList {
                width: 100%;
            }

            .objectsListContent {
                margin: auto;
                text-align: center;
                font-size: 0;
                min-height: 34px;
                padding: 0 5px 5px 0;
                background: none;
            }

            /* max-width:2005px; */
            .objectsListContent p, .objectsListContent form {
                font-size: 1rem;
                color: #000000;
                text-align: left;
            }

            .objectsListContent p a, .objectsListContent form a {
                color: #000000;
            }
        </style>
        <?php
    }

    /**
     * Affiche une liste l'objets avec leurs paramètres propres ou des messages imbriqués.
     *
     * Se base sur la fonction getDisplayObject() pour l'affichage des objets.
     * Se base sur la fonction getDisplayInformation() pour l'affichage des messages.
     *
     * Si 'information' est défini et que les paramètres contiennent 'informationType',
     *   alors on affiche un message et non un objet.
     * Si 'object' n'est défini pour aucun des éléments du tableau,
     *   alors affiche un message générique pour dire que la liste est vide.
     *   Sauf si on demande explicitement de ne pas afficher le message.
     *
     * @param array $list
     * @param string $size
     * @param boolean $displayNoObject
     * @return string
     */
    public function getDisplayObjectsList($list, $size = 'medium', $displayNoObject = false)
    {
        $result = '';

        if (!is_array($list)) {
            return '';
        }

        $result .= '<div class="layoutObjectsList">' . "\n";
        $result .= '<div class="objectsListContent">' . "\n";

        // Prépare le message si pas d'objet à afficher.
        $noObject = true;
        foreach ($list as $item) {
            if (isset($item['object'])
                || isset($item['information'])
                || isset($item['link'])
            ) {
                $noObject = false;
            }
        }
        if ($noObject
            && !$displayNoObject
        ) {
            $param = array(
                'enableDisplayIcon' => true,
                'informationType' => 'information',
            );
            $result .= $this->getDisplayInformation('::EmptyList', $param);
        }

        foreach ($list as $item) {
            $param = $item['param'];
            $param['displaySize'] = $size;

            // Détermine si c'est un objet ou un message à afficher.
            if (isset($item['object'])
                && (is_a($item['object'], 'Node')
                    || $item['object'] != ''
                )
            ) {
                $result .= $this->getDisplayObject($item['object'], $param);
            } elseif (isset($param['informationType'])
                && isset($item['information'])
                && $param['informationType'] != ''
                && $item['information'] != ''
            ) {
                $result .= $this->getDisplayInformation($item['information'], $param);
            } elseif (isset($item['link'])
                && is_a($item['link'], 'Link')
            ) {
                $result .= $this->getDisplayMessage($item['link'], $param);
            }
            // Sinon n'affiche rien.
        }
        unset($param, $item);

        $result .= '</div>' . "\n";
        $result .= '</div>' . "\n";

        return $result;
    }


    /**
     * Le CSS de la fonction getDisplayMenuList().
     *
     * @return null
     */
    private function _getDisplayMenuListCSS()
    {
        ?>

        <style type="text/css">
            /* CSS de la fonction getDisplayObject(). */
            .layoutMenuList {
                font-size: 0;
                padding-top: 4px;
                width: 100%;
            }

            .menuListContent {
                margin: auto;
                text-align: center;
            }

            .menuListContentActionDiv {
                display: inline-block;
            }

            .menuListContentActionDiv a:link, .menuListContentActionDiv a:visited {
                font-weight: normal;
                text-decoration: none;
            }

            .menuListContentActionDiv a:hover, .menuListContentActionDiv a:active {
                font-weight: bold;
                text-decoration: none;
            }

            .menuListContentAction {
                background: #ababab;
                height: 64px;
                margin-bottom: 5px;
                margin-right: 5px;
                text-align: left;
                color: #545454;
            }

            .menuListContentActionSmall {
                width: 128px;
            }

            .menuListContentActionMedium {
                width: 295px;
            }

            .menuListContentActionLarge {
                width: 395px;
            }

            .menuListContentAction-content {
                padding: 5px;
            }

            .menuListContentAction-icon {
                float: left;
                height: 64px;
                width: 64px;
                margin-right: 5px;
            }

            .menuListContentAction-ref {
                font-size: 0.6rem;
                font-style: italic;
                overflow: hidden;
                white-space: nowrap;
            }

            .menuListContentAction-title {
                font-size: 1.1rem;
                font-weight: bold;
                overflow: hidden;
                white-space: normal;
            }

            .menuListContentAction-desc {
                font-size: 0.8rem;
                overflow: hidden;
                white-space: nowrap;
            }
        </style>
        <?php
    }

    /**
     * Affiche un menu constitué d'une liste d'entrées avec icône, titre et lien html.
     * Peut éventuellement afficher une description par entrée.
     *
     * La liste $list est un tableau de listes, chacunes contenant :
     * - icon : la référence de l'îcone, obligatoire ;
     * - title : le titre de l'entrée, obligatoire ;
     * - htlink : le lien HTML, obligatoire ;
     * - desc : la description sous le titre, facultatif ;
     * - ref : un texte de référence au dessus du titre, facultatif ;
     * - class : un texte qui référence une classe CSS, facultatif.
     * La taille peut être :
     * - Small
     * - Medium
     * - Large
     * Par défaut la taille est Medium.
     *
     * @param array $list
     * @param string $size
     * @return string
     */
    public function getDisplayMenuList($list, $size = 'Medium')
    {
        $result = '';

        if (sizeof($list) == 0) {
            return '';
        }

        foreach ($list as $i => $item) {
            if (!isset($item['icon']) || $item['icon'] == ''
                || !isset($item['title']) || $item['title'] == ''
                || !isset($item['htlink']) || $item['htlink'] == ''
            ) {
                unset($list[$i]);
            }
            if (!isset($item['class'])) {
                $list[$i]['class'] = '';
            }
            if (!isset($item['ref'])
                || $item['ref'] == ''
            ) {
                $list[$i]['ref'] = '&nbsp;';
            }
            if (!isset($item['desc'])
                || $item['desc'] == ''
            ) {
                $list[$i]['desc'] = '&nbsp;';
            }
        }

        if (sizeof($list) == 0) {
            return '';
        }

        // Vérification de $size.
        if ($size != 'Small'
            && $size != 'Medium'
            && $size != 'Large'
        ) {
            $size = 'Medium';
        }

        $result .= '<div class="layoutMenuList">' . "\n";
        $result .= '<div class="menuListContent">' . "\n";

        foreach ($list as $item) {
            $result .= '<div class="menuListContentActionDiv">' . "\n";
            $result .= '<a href="' . $item['htlink'] . '">' . "\n";

            $result .= ' <div class="menuListContentAction menuListContentAction' . $size . "\n";
            if (isset($item['class'])) {
                $result .= ' ' . $item['class'];
            }
            $result .= '">' . "\n";
            $result .= '  <div class="menuListContentAction-icon">';
            $result .= $this->convertUpdateImage($item['icon'], $item['title']);
            $result .= '</div>' . "\n";

            $result .= '  <div class="menuListContentAction-content">' . "\n";
            $result .= '   <p class="menuListContentAction-ref">' . $item['ref'] . '</p>' . "\n";
            $result .= '   <p class="menuListContentAction-title">' . $item['title'] . '</p>' . "\n";
            $result .= '   <p class="menuListContentAction-desc">' . $item['desc'] . '</p>' . "\n";

            $result .= "  </div>\n";
            $result .= " </div></a>\n";
            $result .= "</div>\n";
        }

        $result .= '</div>' . "\n";
        $result .= '</div>' . "\n";

        return $result;
    }

    /**
     * Affiche la liste de menu en fonction d'un point d'ancrage.
     * Utilise la fonction getDisplayMenuList().
     *
     * Le point d'enrage $hook est un texte qui sert de référence.
     * les modules sont interrogés pour avoir les entrées correspondantes à cette référence.
     * La taille peut être :
     * - Small
     * - Medium
     * - Large
     * Par défaut la taille est Medium.
     * Lors de la consultation des points d'encrage, il est possible de passer un objet à utiliser.
     *
     * @param array $hook
     * @param string $size
     * @param string $object
     * @return string
     */
    public function getDisplayHookMenuList($hook, $size = 'Medium', $object = 'none')
    {
        $list = array();
        $i = 0;
        $module = null;

        $modules = $this->_applicationInstance->getModulesListInstances();
        foreach ($modules as $module) {
            // Liste les points d'encrages à afficher.
            $appHookList = $module->getHookList($hook, $object);
            $appHook = null;
            foreach ($appHookList as $appHook) {
                if ($appHook['name'] != '') {
                    $list[$i]['ref'] = $module->getTraduction($module->getName());
                    $list[$i]['title'] = $module->getTraduction($appHook['name']);
                    $list[$i]['icon'] = $appHook['icon'];
                    if ($list[$i]['icon'] == '') {
                        $list[$i]['icon'] = self::DEFAULT_ICON_LSTOBJ;
                    }
                    $list[$i]['desc'] = $module->getTraduction($appHook['desc']);
                    $list[$i]['htlink'] = $appHook['link'];
                    if (isset($appHook['css'])
                        && $appHook['css'] != ''
                    ) {
                        $list[$i]['class'] = $appHook['css'];
                    } else {
                        $list[$i]['class'] = $hook;
                    }
                    $i++;
                }
            }
            unset($appHookList, $appHook);
        }
        unset($modules, $module);

        // Affiche la liste.
        return $this->getDisplayMenuList($list, $size);
    }

    /**
     * @param list $hook
     * @return void
     * @todo Fonction périmée remplacée par getDisplayHookMenuList().
     *
     */
    public function displayHookList($hook)
    {
        echo $this->getDisplayHookMenuList($hook, 'Medium');
    }


    /**
     * Le CSS de la fonction getDisplayTitle().
     *
     * @return null
     */
    private function _getDisplayTitleCSS()
    {
        ?>

        <style type="text/css">
            /* CSS de la fonction getDisplayTitle(). */
            .layoutTitle {
                margin-bottom: 10px;
                margin-top: 32px;
                width: 100%;
                height: 32px;
                text-align: center;
            }

            .titleContent {
                margin: auto;
                text-align: center;
            }

            .titleContentDiv {
                display: inline-block;
                background: #333333;
                height: 32px;
                width: 384px;
            }

            .titleContentEntity {
                display: inline-block;
            }

            .titleContentEntity .layoutObject {
                margin: -11px 0 0 0;
            }

            .titleContentIcon {
                float: left;
            }

            .titleContentIcon img {
                height: 32px;
                width: 32px;
                margin-right: 5px;
            }

            .titleContent h1 {
                font-size: 1.2rem;
                font-weight: bold;
                color: #ababab;
                overflow: hidden;
                white-space: nowrap;
                margin-top: 5px;
            }
        </style>
        <?php
    }

    /**
     * Affiche un titre de paragraphe.
     *
     * La variable $displayEntity et l'option 'forceDisplayEntityOnTitle' forcent l'affichage de l'entité en cours.
     *
     * @param string $title
     * @param string $icon
     * @param boolean $displayEntity
     * @return string
     */
    public function getDisplayTitle($title, $icon = '', $displayEntity = false)
    {
        $result = '';

        if (trim($title) == '') {
            return '';
        }

        if ($displayEntity !== true) {
            $displayEntity = false;
        }

        $result .= '<div class="layoutTitle">' . "\n";
        $result .= ' <div class="titleContent">' . "\n";

        $result .= '  <div class="titleContentDiv">' . "\n";
        if ($icon != '') {
            $result .= '   <div class="titleContentIcon">' . "\n";
            $result .= $this->convertUpdateImage($icon, $title);
            $result .= "   </div>\n";
        }
        $result .= '   <h1>' . $this->_traductionInstance->getTraduction($title) . "</h1>\n";
        $result .= "  </div>\n";

        if ($this->_applicationInstance->getCurrentEntity() != $this->_nebuleInstance->getCurrentEntity()
            || $this->_nebuleInstance->getOption('forceDisplayEntityOnTitle')
            || $displayEntity
        ) {
            $result .= '  <div class="titleContentEntity">' . "\n";
            $param = array(
                'enableDisplayColor' => true,
                'enableDisplayIcon' => true,
                'enableDisplayRefs' => false,
                'enableDisplayName' => true,
                'enableDisplayID' => false,
                'enableDisplayFlags' => false,
                'enableDisplayStatus' => false,
                'enableDisplayContent' => false,
                'displaySize' => 'small',
                'displayRatio' => 'short',
                'enableDisplayJS' => false,
                'enableDisplayObjectActions' => false,
            );
            $result .= $this->getDisplayObject($this->_applicationInstance->getCurrentEntity(), $param);
            $result .= "  </div>\n";
        }

        $result .= " </div>\n";
        $result .= "</div>\n";

        return $result;
    }


    /**
     * Le CSS de la fonction getDisplayInformation().
     *
     * Le style CSS est hérité de celui utilisé pour la fonction getDisplayObject() et adapté.
     *
     * @return null
     */
    private function _getDisplayInformationCSS()
    {
        ?>

        <style type="text/css">
            /* CSS de la fonction getDisplayInformation(). */
            .informationTitleIcons img {
                background: none;
            }

            .informationDisplay {
                height: auto;
            }

            .informationDisplayMessage {
                background: #333333;
            }

            .informationDisplayOk {
                background: #103020;
            }

            .informationDisplayWarn {
                background: #ffe080;
            }

            .informationDisplayError {
                background: #ffa0a0;
            }

            .informationDisplayInformation {
                background: #ababab;
            }

            .informationTitleText {
                background: none;
                height: auto;
            }

            .informationDisplayTiny {
            }

            .informationDisplaySmall {
                min-height: 32px;
                font-size: 32px;
                border: 0;
            }

            .informationDisplayMedium {
                min-height: 64px;
                font-size: 64px;
                border: 0;
            }

            .informationDisplayLarge {
                min-height: 128px;
                font-size: 128px;
                border: 0;
            }

            .informationDisplayFull {
                min-height: 256px;
                font-size: 256px;
                border: 0;
            }

            .informationTitleTinyText {
                min-height: 16px;
                background: none;
            }

            .informationTitleSmallText {
                min-height: 30px;
                text-align: left;
                padding: 1px 0 1px 1px;
                color: #000000;
            }

            .informationTitleMediumText {
                min-height: 58px;
                text-align: left;
                padding: 3px 0 3px 3px;
                color: #000000;
            }

            .informationTitleLargeText {
                min-height: 122px;
                text-align: left;
                padding: 3px 0 3px 3px;
                color: #000000;
            }

            .informationTitleFullText {
                min-height: 246px;
                text-align: left;
                padding: 5px 0 5px 5px;
                color: #000000;
            }

            .informationTitleName {
                font-weight: normal;
                overflow: hidden;
                height: auto;
            }

            .informationTitleNameMessage, .informationTitleRefsMessage {
                color: #ffffff;
            }

            .informationTitleNameOk, .informationTitleRefsOk {
                color: #ffffff;
            }

            .informationTitleNameWarn, .informationTitleRefsWarn {
                color: #ff8000;
            }

            .informationTitleNameWarn {
                font-weight: bold;
            }

            .informationTitleNameError, .informationTitleRefsError {
                color: #ff0000;
            }

            .informationTitleNameError {
                font-weight: bold;
            }

            .informationTitleNameInformation, .informationTitleRefsInformation {
                color: #000000;
            }

            .informationTitleTinyName {
                height: 1rem;
                line-height: 1rem;
                font-size: 1rem;
            }

            .informationTitleSmallName {
                line-height: 14px;
                overflow: hidden;
                white-space: normal;
                font-size: 1rem;
            }

            .informationTitleMediumName {
                line-height: 22px;
                overflow: hidden;
                white-space: normal;
                font-size: 1.2rem;
            }

            .informationTitleLargeName {
                line-height: 30px;
                overflow: hidden;
                white-space: normal;
                font-size: 1.5rem;
            }

            .informationTitleFullName {
                line-height: 62px;
                overflow: hidden;
                white-space: normal;
                font-size: 2rem;
            }
        </style>
        <?php
    }

    /**
     * Affiche un message d'information avec un style en fonction du type de message.
     *
     * Le message peut contenir 5 arguments remplacés dans le texte après la traduction.
     * Dans le texte, chaque chaine %s est remplacée successivement avec les arguments à concurence de 5.
     *
     * Le style CSS est hérité de celui utilisé pour la fonction getDisplayObject() et adapté.
     *
     * Les paramètres d'activation de contenus :
     * - enableDisplayIcon : Affiche le carré avec l'image attaché à l'objet ou l'icône de son type.
     *     Par défaut true : affiche le carré de l'image/icône.
     *     Boolean
     * - enableDisplayAlone : Affiche le message dans une position identique à un titre. C'est utilisé pour un message isolé.
     *     Par défaut false : n'affiche pas en isolé.
     *     Boolean
     *
     * Les paramètres de définition de contenus :
     * - informationType : Détermine le type de message.
     *     Les types disponibles :
     *     - message : affichage d'un message simple en blanc sur fond noir transparent.
     *     - ok : affichage d'un message de validation en blanc sur fond vert.
     *     - warn : affichage d'un message d'avertissement en jaune gras sur fond orange clair.
     *     - error : affichage d'un message d'erreur en rouge gras sur fond rose clair.
     *     - info : affichage d'un message simple en noir sur fond blanc transparent (style d'affichage des objets).
     *     Par défaut info.
     *     String
     * - informationTypeName : Détermine le nom du type de message à afficher.
     *     Par défaut vide.
     *     String
     * - displaySize : Détermine la taille de l'affichage de l'élément complet.
     *     Tailles disponibles :
     *     - tiny : très petite taille correspondant à un carré de base de 16 pixels de large.
     *         Certains éléments ne sont pas affichés.
     *     - small : petite taille correspondant à un carré de base de 32 pixels de large.
     *     - medium : taille moyenne correspondant à un carré de base de 64 pixels de large par défaut.
     *     - large : grande taille correspondant à un carré de base de 128 pixels de large par défaut.
     *     - full : très grande taille correspondant à un carré de base de 256 pixels de large par défaut.
     *     Par défaut medium : taille moyenne.
     *     String
     * - displayRatio : Détermine la forme de l'affichage par son ratio dans la mesure du possible si pas d'affichage du contenu de l'objet.
     *     Ratios disponibles :
     *     - square : forme carrée de 2x2 displaySize.
     *     - short : forme plate courte de 6x1 displaySize.
     *     - long : forme plate longue de toute largeure disponible.
     *     Par défaut short : forme plate courte.
     *     String
     * - icon : Détermine l'icône à utiliser.
     *     Si vide, l'icône est sélectionnée automatiquement en fonction du type de message.
     *     Par défaut vide : l'icône est sélectionnée automatiquement.
     *     enableDisplayIcon doit être à true.
     *     String
     *
     * Exemple de table de paramètres avec les valeurs par défaut :
     *
     * $param = array(
     * 'enableDisplayIcon' => true,
     * 'enableDisplayAlone' => false,
     * 'informationType' => 'information',
     * 'informationTypeName' => '',
     * 'displaySize' => 'medium',
     * 'displayRatio' => 'short',
     * 'icon' => '',
     * );
     *
     * @param string $message
     * @param array $param
     * @param string $arg1
     * @param string $arg2
     * @param string $arg3
     * @param string $arg4
     * @param string $arg5
     * @return string
     */
    public function getDisplayInformation($message, $param, $arg1 = '', $arg2 = '', $arg3 = '', $arg4 = '', $arg5 = '')
    {
        $result = '';

        // Prépare les paramètres d'activation de contenus.
        if (!isset($param['enableDisplayIcon'])
            || $param['enableDisplayIcon'] !== false
        ) {
            $param['enableDisplayIcon'] = true; // Par défaut à true.
        }

        $message = sprintf($this->_traductionInstance->getTraduction($message), $arg1, $arg2, $arg3, $arg4, $arg5);
        if (!is_string($param['informationType'])
            || $param['informationType'] != 'information'
        ) {
            //$message = filter_var($message, FILTER_SANITIZE_STRING); @todo refaire un filtre.
        } else {
            // @todo faire un filtre pour le type message...
        }
        $contentDisplayMessage = trim($message);
        if ($contentDisplayMessage == '') {
            return '';
        }

        if (!isset($param['enableDisplayAlone'])) {
            $param['enableDisplayAlone'] = false;
        }
        if ($param['enableDisplayAlone'] === true) {
            $result .= '<div class="layoutAloneItem">' . "\n";
            $result .= ' <div class="aloneItemContent">' . "\n";
        }

        // Avec une première lettre majuscule pour le CSS.
        $messageType = '';
        switch (strtolower($param['informationType'])) {
            case 'info':
            case 'information':
                $messageType = 'Information';
                break;
            case 'ok':
                $messageType = 'Ok';
                break;
            case 'warn':
            case 'warning':
                $messageType = 'Warn';
                break;
            case 'nok':
            case 'err':
            case 'error':
                $messageType = 'Error';
                break;
            case 'message':
                $messageType = 'Message';
                break;
            default:
                $messageType = 'Information';
                break;
        }

        $messageTextIcon = '';
        $messageIcon = '';
        if (isset($param['icon'])
            && $param['icon'] !== ''
        ) {
            $messageIcon = $param['icon'];
        } else {
            switch ($messageType) {
                case 'Information':
                case 'Message':
                    $messageTextIcon = '::::INFORMATION';
                    $messageIcon = self::DEFAULT_ICON_IINFO;
                    break;
                case 'Ok':
                    $messageTextIcon = '::::OK';
                    $messageIcon = self::DEFAULT_ICON_IOK;
                    break;
                case 'Warn':
                    $messageTextIcon = '::::WARN';
                    $messageIcon = self::DEFAULT_ICON_IWARN;
                    break;
                case 'Error':
                    $messageTextIcon = '::::ERROR';
                    $messageIcon = self::DEFAULT_ICON_IERR;
                    break;
            }
        }
        if (isset($param['informationTypeName'])
            && $param['informationTypeName'] != ''
        ) {
            $messageTextIcon = $param['informationTypeName'];
        }

        $sizeCSS = 'Medium';
        if (!isset($param['displaySize'])) {
            $param['displaySize'] = 'medium';
            $sizeCSS = 'Medium';
        } else {
            switch ($param['displaySize']) {
                case 'tiny':
                    $sizeCSS = 'Tiny';
                    break;
                case 'small':
                    $sizeCSS = 'Small';
                    break;
                case 'large':
                    $sizeCSS = 'Large';
                    break;
                case 'full':
                    $sizeCSS = 'Full';
                    break;
                default:
                    $param['displaySize'] = 'medium';
                    $sizeCSS = 'Medium';
                    break;
            }
        }

        $ratioCSS = 'short';
        if (!isset($param['displayRatio'])) {
            $param['displayRatio'] = 'short';
            $ratioCSS = 'Short';
        } else {
            switch ($param['displayRatio']) {
                case 'square':
                    $ratioCSS = 'Square';
                    break;
                case 'long':
                    $ratioCSS = 'Long';
                    break;
                default:
                    $param['displayRatio'] = 'short';
                    $ratioCSS = 'Short';
                    break;
            }
        }

        // Prépare les contenus.
        $contentDisplayIcon = '';
        if ($param['enableDisplayIcon']) {
            $contentDisplayIcon = $this->convertUpdateImage($messageIcon, $messageTextIcon);
            // $contentDisplayIcon = $this->convertReferenceImage($messageIcon, $messageTextIcon); @todo par référence
        }

        // Assemble les contenus.
        $divDisplayOpen = '';
        $divDisplayClose = '';
        $divTitleOpen = '';
        $divTitleClose = '';
        $titleContent = '';
        $divTitleIconsOpen = '';
        $divTitleIconsClose = '';
        $titleIconsContent = '';
        $divTitleTextOpen = '';
        $divTitleTextClose = '';
        $divTitleRefsOpen = '';
        $divTitleRefsClose = '';
        $titleRefsContent = '';
        $divTitleNameOpen = '';
        $divTitleNameClose = '';
        $titleNameContent = '';
        if ($param['displaySize'] == 'tiny') {
            $result = '<span style="font-size:1em" class="objectTitleIconsInline">' . $contentDisplayIcon . '</span>' . $contentDisplayMessage;
        } else {
            $divDisplayOpen = '<div class="layoutObject layoutInformation">' . "\n";
            $divDisplayClose = '</div>' . "\n";
            $divTitleOpen = ' <div class="objectTitle objectDisplay' . $sizeCSS . $ratioCSS . ' informationDisplay informationDisplay' . $sizeCSS . ' informationDisplay' . $messageType . '">' . "\n";
            $divTitleClose = ' </div>' . "\n";
            $divTitleIconsOpen = '  <div class="objectTitleIcons informationTitleIcons informationTitleIcons' . $messageType . '">';
            $divTitleIconsClose = '</div>' . "\n";
            $padding = 0;
            if ($param['enableDisplayIcon']) {
                $titleIconsContent = $contentDisplayIcon;
                $padding += 1;
            }
            $divTitleTextOpen = '  <div class="objectTitleText' . $padding . ' informationTitleText informationTitle' . $sizeCSS . 'Text">' . "\n";
            $divTitleTextClose = '  </div>' . "\n";
            $divTitleRefsOpen = '   <div class="objectTitleRefs objectTitle' . $sizeCSS . 'Refs informationTitleRefs informationTitleRefs' . $messageType . '">';
            $divTitleRefsClose = '</div>' . "\n";
            $divTitleNameOpen = '   <div class="informationTitleName informationTitleName' . $messageType . ' informationTitle' . $sizeCSS . 'Name">';
            $divTitleNameClose = '</div>' . "\n";
            $titleRefsContent = $this->_traductionInstance->getTraduction($messageTextIcon);
            $titleNameContent = $contentDisplayMessage;

            $titleContent = $divTitleIconsOpen . $titleIconsContent . $divTitleIconsClose . "\n";
            $titleContent .= $divTitleTextOpen;
            $titleContent .= $divTitleRefsOpen . $titleRefsContent . $divTitleRefsClose;
            $titleContent .= $divTitleNameOpen . $titleNameContent . $divTitleNameClose;
            $titleContent .= $divTitleTextClose;

            // Prépare le résultat à afficher.
            $result .= $divDisplayOpen;
            $result .= $divTitleOpen . $titleContent . $divTitleClose;
            $result .= $divDisplayClose;
        }

        if ($param['enableDisplayAlone'] === true) {
            $result .= " </div>\n";
            $result .= "</div>\n";
        }

        return $result;
    }


    /**
     * Le CSS de la fonction getDisplayLink().
     *
     * @return null
     */
    private function _getDisplayLinkCSS()
    {
        ?>

        <style type="text/css">
            /* CSS de la fonction getDisplayLink(). */
            .layoutLink {
                margin-right: 5px;
            }

            .linkDisplay {
            }

            .linkDisplaySmall img {
                height: 16px;
            }

            .linkDisplayMedium img {
                height: 32px;
            }

            .linkDisplayLarge img {
                height: 64px;
            }
        </style>
        <?php
    }

    /**
     * Retourne la représentation html du lien en fonction des paramètres passés.
     *
     * Les paramètres de définition de contenus :
     * - displaySize : Détermine la taille de l'affichage de l'élément complet.
     *     Tailles disponibles :
     *     - small : très petite taille correspondant à un carré de base de 16 pixels de large.
     *         Certains éléments ne sont pas affichés.
     *     - medium : taille moyenne correspondant à un carré de base de 32 pixels de large par défaut.
     *     - large : grande taille correspondant à un carré de base de 64 pixels de large par défaut.
     *     Par défaut small : taille petite.
     *     String
     *
     * Exemple de table de paramètres avec les valeurs par défaut :
     *
     * $param = array(
     * 'displaySize' => 'small',
     * );
     *
     * @param Link|string $link
     * @param array $param
     * @return string
     */
    public function getDisplayLink($link, array $param)
    {
        /**
         * Résultat à retourner pour affichage.
         * @var string $result
         */
        $result = '';

        /**
         * Instance du lien à afficher.
         * @var Link $instance
         */
        $instance = null;

        // Prépare le lien.
        if (is_a($link, 'Link')) {
            $instance = $link;
        } elseif (is_string($link)) {
            $instance = $this->_nebuleInstance->newLink($link);
        }

        // Teste la validité du lien.
        if ($instance == null
            || !is_a($instance, 'Link')
        ) {
            return '';
        }

        $sizeCSS = 'Medium';
        if (!isset($param['displaySize'])) {
            $param['displaySize'] = 'medium';
            $sizeCSS = 'Medium';
        } else {
            switch ($param['displaySize']) {
                case 'small':
                    $sizeCSS = 'Small';
                    break;
                case 'large':
                    $sizeCSS = 'Large';
                    break;
                default:
                    $param['displaySize'] = 'medium';
                    $sizeCSS = 'Medium';
                    break;
            }
        }

        $divDisplayOpen = '<span class="layoutLink">' . "\n";
        $divDisplayClose = '</span>' . "\n";
        $divLinkOpen = ' <span class="linkDisplay linkDisplay' . $sizeCSS . ' ">' . "\n";
        $divLinkClose = ' </span>' . "\n";

        $contantDisplayIcon = '';
        $contantDisplayValid = '';
        $contantDisplaySigner = '';
        $contantDisplayDate = '';
        $contantDisplayAction = '';
        $contantDisplaySource = '';
        $contantDisplayTarget = '';
        $contantDisplayMeta = '';

        if ($instance->getVerified()
            && $instance->getValid()
        ) {
            if ($instance->getSigned()) {
                $contantDisplayValid .= '<img title="OK" ';
                $contantDisplayValid .= 'alt="[O]" src="o/' . $this->_getImageByReference(self::REFERENCE_ICON_OK) . '" ';
                $contantDisplayValid .= '/>';
            } else {
                $contantDisplayValid .= '<img title="ERROR" ';
                $contantDisplayValid .= 'alt="[E]" src="o/' . $this->_getImageByReference(self::REFERENCE_ICON_ERROR) . '" ';
                $contantDisplayValid .= '/>';
            }

            $object = $this->_nebuleInstance->newObject($instance->getHashSigner_disabled());
            $contantDisplaySigner .= '<img title="' . $object->getFullName();
            $contantDisplaySigner .= '" style="background:#' . $object->getPrimaryColor();
            $contantDisplaySigner .= ';" alt="[]" src="o/' . self::DEFAULT_ICON_ALPHA_COLOR . '" />';

            $contantDisplayDate = '';

            $icon = self::REFERENCE_ICON_LINK_LL;
            switch ($instance->getAction_disabled()) {
                case 'f':
                    $icon = self::REFERENCE_ICON_LINK_LF;
                    break;
                case 'u':
                    $icon = self::REFERENCE_ICON_LINK_LU;
                    break;
                case 'd':
                    $icon = self::REFERENCE_ICON_LINK_LD;
                    break;
                case 'e':
                    $icon = self::REFERENCE_ICON_LINK_LE;
                    break;
                case 'c':
                    $icon = self::REFERENCE_ICON_LINK_LC;
                    break;
                case 'k':
                    $icon = self::REFERENCE_ICON_LINK_LK;
                    break;
                case 's':
                    $icon = self::REFERENCE_ICON_LINK_LS;
                    break;
                case 'x':
                    $icon = self::REFERENCE_ICON_LINK_LX;
                    break;
            }
            $contantDisplayAction .= '<img title="Action ' . $instance->getAction_disabled() . '" ';
            $contantDisplayAction .= 'alt="[' . $instance->getAction_disabled() . ']" ';
            $contantDisplayAction .= 'src="o/' . $this->_getImageByReference($icon) . '" />';

            $object = $this->_nebuleInstance->newObject($instance->getHashSource_disabled());
            $contantDisplaySource .= '<img title="' . $object->getFullName();
            $contantDisplaySource .= '" style="background:#' . $object->getPrimaryColor();
            $contantDisplaySource .= ';" alt="[]" src="o/' . self::DEFAULT_ICON_ALPHA_COLOR . '" />';

            $object = $this->_nebuleInstance->newObject($instance->getHashTarget_disabled());
            $contantDisplayTarget .= '<img title="' . $object->getFullName();
            $contantDisplayTarget .= '" style="background:#' . $object->getPrimaryColor();
            $contantDisplayTarget .= ';" alt="[]" src="o/' . self::DEFAULT_ICON_ALPHA_COLOR . '" />';

            $object = $this->_nebuleInstance->newObject($instance->getHashMeta_disabled());
            $contantDisplayMeta .= '<img title="' . $object->getFullName();
            $contantDisplayMeta .= '" style="background:#' . $object->getPrimaryColor();
            $contantDisplayMeta .= ';" alt="[]" src="o/' . self::DEFAULT_ICON_ALPHA_COLOR . '" />';
        } else {
            $contantDisplayIcon .= '<img title="ERROR" ';
            $contantDisplayIcon .= 'alt="[E]" src="o/' . $this->_getImageByReference(self::REFERENCE_ICON_LINK_LL) . '" ';
            $contantDisplayIcon .= '/>';

            $contantDisplayValid .= '<img title="ERROR" ';
            $contantDisplayValid .= 'alt="[E]" src="o/' . $this->_getImageByReference(self::REFERENCE_ICON_ERROR) . '" ';
            $contantDisplayValid .= '/>';
        }

        $result .= $divDisplayOpen;
        $result .= $divLinkOpen;
        $result .= $contantDisplayIcon;
        $result .= $contantDisplayValid;
        $result .= $contantDisplaySigner;
        $result .= $contantDisplayDate;
        $result .= $contantDisplayAction;
        $result .= $contantDisplaySource;
        $result .= $contantDisplayTarget;
        $result .= $contantDisplayMeta . "\n";
        $result .= $divLinkClose;
        $result .= $divDisplayClose;

        return $result;
    }


    /**
     * Affiche l'image du carré de couleur de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string|Node|entity $object
     * @param string $htlink
     * @return null
     */
    public function displayObjectColor($object, $htlink = '')
    {
        echo $this->convertObjectColor($object, $htlink);
    }

    /**
     * Prépare l'image du carré de couleur de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string|Node|entity $object
     * @param string $htlink
     * @return string
     */
    public function convertObjectColor($object, $htlink = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        $image = $this->_prepareObjectColor($object, 'iconNormalDisplay');
        return $this->convertHypertextLink($image, $htlink);
    }

    /**
     * Affiche l'image du carré de couleur de l'objet ou de l'entité, mais pas de lien vers l'objet.
     *
     * @param string $object
     * @return null
     */
    public function displayInlineObjectColorNolink($object)
    {
        echo $this->convertInlineObjectColorNolink($object);
    }

    /**
     * Prépare l'image du carré de couleur de l'objet ou de l'entité, mais pas de lien vers l'objet.
     *
     * @param string $object
     * @return null
     */
    public function convertInlineObjectColorNolink($object)
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $color = $this->_prepareObjectColor($object, 'iconInlineDisplay');
        return $color;
    }

    /**
     * Affiche l'image de l'icône de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string|Node|entity $object
     * @param string $htlink
     * @return null
     */
    public function displayObjectIcon($object, $htlink = '', $icon = '')
    {
        echo $this->convertObjectIcon($object, $htlink, $icon);
    }

    /**
     * Prépare l'image de l'icône de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string|Node|entity $object
     * @param string $htlink
     * @return string
     */
    public function convertObjectIcon($object, $htlink = '', $icon = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        if ($icon != '') {
            $icon = $this->_prepareObjectIcon($object, $icon, 'iconNormalDisplay');
        } else {
            $icon = $this->_prepareObjectFace($object, 'iconNormalDisplay');
        }
        return $this->convertHypertextLink($color . $icon, $htlink);
    }

    /**
     * Affiche l'image du carré de couleur et l'icône de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string|Node|entity $object
     * @param string $htlink
     * @return null
     */
    public function displayObjectColorIcon($object, $htlink = '', $icon = '')
    {
        echo $this->convertObjectColorIcon($object, $htlink, $icon);
    }

    /**
     * Prépare l'image du carré de couleur et l'icône de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string|Node|entity $object
     * @param string $htlink
     * @return string
     */
    public function convertObjectColorIcon($object, $htlink = '', $icon = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        $color = $this->_prepareObjectColor($object, 'iconNormalDisplay');
        if ($icon != '') {
            $icon = $this->_prepareObjectIcon($object, $icon, 'iconNormalDisplay');
        } else {
            $icon = $this->_prepareObjectFace($object, 'iconNormalDisplay');
        }
        return $this->convertHypertextLink($color . $icon, $htlink);
    }

    /**
     * Prépare en version inserré au texte l'image du carré de couleur de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string|Node|entity $object
     * @param string $htlink
     * @return string
     */
    public function prepareInlineObjectColor($object, $htlink = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        $color = $this->_prepareObjectColor($object, 'iconInlineDisplay');
        return $this->convertHypertextLink($color, $htlink);
    }

    /**
     * Affiche en version inserré au texte l'image de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string $object
     * @param string $htlink
     * @return null
     */
    public function displayInlineObjectColor($object, $htlink = '')
    {
        echo $this->convertInlineObjectColor($object, $htlink);
    }

    /**
     * Prépare en version inserré au texte l'image de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string $object
     * @param string $htlink
     * @return string
     */
    public function convertInlineObjectColor($object, $htlink = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        $color = $this->_prepareObjectColor($object, 'iconInlineDisplay');
        return $this->convertHypertextLink($color, $htlink);
    }

    /**
     * Affiche en version inserré au texte l'image de l'objet ou de l'entité et le nom ou un texte, lien vers l'objet.
     *
     * @param string $object
     * @param string $text
     * @param string $htlink
     * @return null
     */
    public function displayInlineObjectColorText($object, $text = '', $htlink = '')
    {
        echo $this->convertInlineObjectColorText($object, $text, $htlink);
    }

    /**
     * Prépare en version inserré au texte l'image de l'objet ou de l'entité et le nom ou un texte, lien vers l'objet.
     *
     * @param string $object
     * @param string $text
     * @param string $htlink
     * @return string
     */
    public function convertInlineObjectColorText($object, $text = '', $htlink = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        if ($text == '') {
            $text = $object->getFullName('all');
        }
        $text = $this->_truncateName($text, 0);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        $color = $this->_prepareObjectColor($object, 'iconInlineDisplay');
        return $this->convertHypertextLink($color . $text, $htlink);
    }

    /**
     * Affiche en version inserré au texte l'image de l'objet ou de l'entité et le nom, lien vers l'objet.
     *
     * @param string $object
     * @param string $htlink
     * @return null
     */
    public function displayInlineObjectColorName($object, $htlink = '')
    {
        echo $this->convertInlineObjectColorName($object, $htlink);
    }

    /**
     * Prépare en version inserré au texte l'image de l'objet ou de l'entité et le nom, lien vers l'objet.
     *
     * @param string $object
     * @param string $htlink
     * @return string
     */
    public function convertInlineObjectColorName($object, $htlink = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        $name = $this->_truncateName($object->getFullName('all'), 0);
        $color = $this->_prepareObjectColor($object, 'iconInlineDisplay');
        return $this->convertHypertextLink($color . $name, $htlink);
    }

    /**
     * Affiche en version inserré au texte l'icône couleur, l'image et un texte ou le nom de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string $object
     * @param string $htlink
     * @return null
     */
    public function displayInlineObjectColorIcon($object, $htlink = '')
    {
        echo $this->convertInlineObjectColorIcon($object, $htlink);
    }

    public function convertInlineObjectColorIcon($object, $htlink = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        $color = $this->_prepareObjectColor($object, 'iconInlineDisplay');
        $icon = $this->_prepareObjectFace($object, 'iconInlineDisplay');
        return $this->convertHypertextLink($color . $icon, $htlink);
    }

    /**
     * Affiche en version inserré au texte l'icône couleur, l'image et un texte ou le nom de l'objet ou de l'entité, lien vers l'objet.
     *
     * @param string $object
     * @param string $htlink
     * @return null
     */
    public function displayInlineObjectColorIconName($object, $htlink = '')
    {
        echo $this->convertInlineObjectColorIconName($object, $htlink);
    }

    public function convertInlineObjectColorIconName($object, $htlink = '')
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $htlink = $this->_prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        $name = $this->_truncateName($object->getFullName('all'), 0);
        $color = $this->_prepareObjectColor($object, 'iconInlineDisplay');
        $icon = $this->_prepareObjectFace($object, 'iconInlineDisplay');
        return $this->convertHypertextLink($color . $icon . $name, $htlink);
    }

    /**
     * Affiche en version inserré au texte l'icône couleur, l'image et un texte ou le nom de l'objet ou de l'entité, mais pas de lien vers l'objet.
     *
     * @param string $object
     * @return null
     */
    public function displayInlineObjectColorIconNameNolink($object)
    {
        echo $this->convertInlineObjectColorIconNameNolink($object);
    }

    /**
     * Prépare en version inserré au texte l'icône couleur, l'image et un texte ou le nom de l'objet ou de l'entité, mais pas de lien vers l'objet.
     *
     * @param string $object
     * @return null
     */
    public function convertInlineObjectColorIconNameNolink($object)
    {
        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);
        $name = $this->_truncateName($object->getFullName('all'), 0);
        $color = $this->_prepareObjectColor($object, 'iconInlineDisplay');
        $icon = $this->_prepareObjectFace($object, 'iconInlineDisplay');
        return $color . $icon . $name;
    }


    /* --------------------------------------------------------------------------------
	 *  Affichage des liens.
	 * -------------------------------------------------------------------------------- */
    public function displayInlineLinkFace($link)
    {
        echo $this->convertInlineLinkFace($link);
    }

    public function convertInlineLinkFace($link)
    {
        if ($link == '') {
            return '';
        }
        if (!is_a($link, 'Link')) {
            $link = $this->_nebuleInstance->newLink($link);
        }
        if (!$link->getValid()) {
            return '';
        }

        switch ($link->getAction_disabled()) {
            case 'f':
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LF, 'f', 'iconInlineDisplay');
                break;
            case 'u':
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LU, 'u', 'iconInlineDisplay');
                break;
            case 'd':
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LD, 'd', 'iconInlineDisplay');
                break;
            case 'e':
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LE, 'e', 'iconInlineDisplay');
                break;
            case 'c':
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LC, 'c', 'iconInlineDisplay');
                break;
            case 'k':
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LK, 'k', 'iconInlineDisplay');
                break;
            case 's':
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LS, 's', 'iconInlineDisplay');
                break;
            case 'x':
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LX, 'x', 'iconInlineDisplay');
                break;
            default :
                $icon = $this->convertUpdateImage(self::DEFAULT_ICON_LL, 'l', 'iconInlineDisplay');
                break;
        }

        $colorDate = $this->convertUpdateImage(self::DEFAULT_ICON_IMLOG, $link->getDate_disabled(), 'iconInlineDisplay');

        // Prépare le contenu à afficher.
        $return = $this->convertInlineObjectColor($link->getHashSigner_disabled());
        $return .= $colorDate;
        $return .= $icon;
        $return .= $this->convertInlineObjectColor($link->getHashSource_disabled());
        $return .= $this->convertInlineObjectColor($link->getHashTarget_disabled());
        $return .= $this->convertInlineObjectColor($link->getHashMeta_disabled());

        return $return;
    }

    public function displayInlineIconFace($iconName)
    {
        echo $this->convertInlineIconFace($iconName);
    }

    public function convertInlineIconFace($iconName)
    {
        $iconID = '';
        if (ctype_xdigit($iconName) && $this->_nebuleInstance->getIO()->checkLinkPresent($iconName)) {
            $iconID = $iconName;
        } elseif (strstr($iconName, ':') !== false) {
            $iconID = constant($iconName);
        } else {
            $iconID = constant('self::' . $iconName);
        }

        $instance = $this->_nebuleInstance->newObject($iconID);
        if ($instance->getID() == '0') {
            return '';
        }

        return $this->convertUpdateImage($instance, $this->_traductionInstance->getTraduction($instance->getName('all')), 'iconInlineDisplay');
    }

    public function displayInlineInfoFace()
    {
        echo $this->convertInlineInfoFace();
    }

    public function convertInlineInfoFace()
    {
        return $this->convertUpdateImage(self::DEFAULT_ICON_IINFO, $this->_traductionInstance->getTraduction('::::INFO'), 'iconInlineDisplay');
    }

    public function displayInlineOKFace()
    {
        echo $this->convertInlineOKFace();
    }

    public function convertInlineOKFace()
    {
        return $this->convertUpdateImage(self::DEFAULT_ICON_IOK, $this->_traductionInstance->getTraduction('::::OK'), 'iconInlineDisplay');
    }

    public function displayInlineWarningFace()
    {
        echo $this->convertInlineWarningFace();
    }

    public function convertInlineWarningFace()
    {
        return $this->convertUpdateImage(self::DEFAULT_ICON_IWARN, $this->_traductionInstance->getTraduction('::::WARN'), 'iconInlineDisplay');
    }

    public function displayInlineErrorFace()
    {
        echo $this->convertInlineErrorFace();
    }

    public function convertInlineErrorFace()
    {
        return $this->convertUpdateImage(self::DEFAULT_ICON_IERR, $this->_traductionInstance->getTraduction('::::ERROR'), 'iconInlineDisplay');
    }

    public function displayInlineLastAction()
    {
        $array = $this->_metrologyInstance->getLastAction();
        switch ($array['type']) {
            case 'addlnk' :
                $this->displayInlineIconFace('DEFAULT_ICON_ADDLNK');
                if ($array['result']) {
                    $this->displayInlineOKFace();
                } else {
                    $this->displayInlineErrorFace();
                }
                $this->displayInlineLinkFace($array['action']);
                break;
            case 'addobj' :
                $this->displayInlineIconFace('DEFAULT_ICON_ADDOBJ');
                if ($array['result']) {
                    $this->displayInlineOKFace();
                } else {
                    $this->displayInlineErrorFace();
                }
                $this->displayInlineObjectColor($array['action']);
                break;
            case 'delobj' :
                $this->displayInlineIconFace('DEFAULT_ICON_LD');
                if ($array['result']) {
                    $this->displayInlineOKFace();
                } else {
                    $this->displayInlineErrorFace();
                }
                $this->displayInlineObjectColor($array['action']);
                break;
            case 'addent' :
                $this->displayInlineIconFace('DEFAULT_ICON_ADDENT');
                if ($array['result']) {
                    $this->displayInlineOKFace();
                } else {
                    $this->displayInlineErrorFace();
                }
                $this->displayInlineObjectColorIcon($array['action']);
                break;
        }
        echo "\n";
        unset($array);
    }

    public function displayInlineAllActions()
    {
        $count = 0;
        while ($array = $this->_metrologyInstance->getFirstAction()) {
            if ($count > 0) {
                echo "- \n";
            }
            switch ($array['type']) {
                case 'addlnk' :
                    $this->displayInlineIconFace('DEFAULT_ICON_ADDLNK');
                    if ($array['result']) {
                        $this->displayInlineOKFace();
                    } else {
                        $this->displayInlineErrorFace();
                    }
                    $this->displayInlineLinkFace($array['action']);
                    $count++;
                    break;
                case 'addobj' :
                    $this->displayInlineIconFace('DEFAULT_ICON_ADDOBJ');
                    if ($array['result']) {
                        $this->displayInlineOKFace();
                    } else {
                        $this->displayInlineErrorFace();
                    }
                    $this->displayInlineObjectColor($array['action']);
                    $count++;
                    break;
                case 'delobj' :
                    $this->displayInlineIconFace('DEFAULT_ICON_LD');
                    if ($array['result']) {
                        $this->displayInlineOKFace();
                    } else {
                        $this->displayInlineErrorFace();
                    }
                    $this->displayInlineObjectColor($array['action']);
                    $count++;
                    break;
                case 'addent' :
                    $this->displayInlineIconFace('DEFAULT_ICON_ADDENT');
                    if ($array['result']) {
                        $this->displayInlineOKFace();
                    } else {
                        $this->displayInlineErrorFace();
                    }
                    $this->displayInlineObjectColorIcon($array['action']);
                    $count++;
                    break;
                default :
                    $count = 1;
            }
            echo "&nbsp;";
        }
        unset($array);
        // Flush la sortie vers le navigateur.
        flush();
    }


    /**
     * Affiche en version inserré au texte les icônes des émotions de l'objet.
     *
     * @param string $object
     * @return null
     */
    public function displayInlineEmotions($object)
    {
        echo $this->convertInlineEmotions($object);
    }

    /**
     * Prépare l'affichage en version inserré au texte les icônes des émotions de l'objet.
     *
     * @param string $object
     * @return string
     */
    public function convertInlineEmotions($object)
    {
        // Vérifie si les émotions doivent être affichées.
        if (!$this->_nebuleInstance->getOption('displayEmotions')) {
            return '';
        }

        $object = $this->_nebuleInstance->convertIdToTypedObjectInstance($object);

        // Ouverture de la DIV.
        $result = "\n<div class=\"inlineemotions\">\n\t<p>\n\t\t";

        $listEmotions = array(
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET,
        );
        $listEmotions0 = array(
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE => Display::REFERENCE_ICON_EMOTION_JOIE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE => Display::REFERENCE_ICON_EMOTION_CONFIANCE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR => Display::REFERENCE_ICON_EMOTION_PEUR0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE => Display::REFERENCE_ICON_EMOTION_SURPRISE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE => Display::REFERENCE_ICON_EMOTION_TRISTESSE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT => Display::REFERENCE_ICON_EMOTION_DEGOUT0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE => Display::REFERENCE_ICON_EMOTION_COLERE0,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET => Display::REFERENCE_ICON_EMOTION_INTERET0,
        );
        $listEmotions1 = array(
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_JOIE => Display::REFERENCE_ICON_EMOTION_JOIE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_CONFIANCE => Display::REFERENCE_ICON_EMOTION_CONFIANCE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_PEUR => Display::REFERENCE_ICON_EMOTION_PEUR1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_SURPRISE => Display::REFERENCE_ICON_EMOTION_SURPRISE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_TRISTESSE => Display::REFERENCE_ICON_EMOTION_TRISTESSE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_DEGOUT => Display::REFERENCE_ICON_EMOTION_DEGOUT1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_COLERE => Display::REFERENCE_ICON_EMOTION_COLERE1,
            nebule::REFERENCE_NEBULE_OBJET_EMOTION_INTERET => Display::REFERENCE_ICON_EMOTION_INTERET1,
        );

        foreach ($listEmotions as $emotion) {
            // Génère la base du lien html pour revenir au bon endroit en toute situation.
            $htlink = '?' . Displays::DEFAULT_DISPLAY_COMMAND_MODE . '=' . $this->_applicationInstance->getDisplayInstance()->getCurrentDisplayMode()
                . '&' . Displays::DEFAULT_DISPLAY_COMMAND_VIEW . '=' . $this->_applicationInstance->getDisplayInstance()->getCurrentDisplayView()
                . '&' . nebule::COMMAND_SELECT_OBJECT . '=' . $object->getID()
                . '&' . nebule::COMMAND_SELECT_ENTITY . '=' . $this->_applicationInstance->getCurrentEntity()
                . '&' . nebule::COMMAND_SELECT_GROUP . '=' . $this->_nebuleInstance->getCurrentGroup()
                . '&' . nebule::COMMAND_SELECT_CONVERSATION . '=' . $this->_nebuleInstance->getCurrentConversation();

            // Préparation du lien.
            $source = $object->getID();
            $target = $this->_nebuleInstance->getCrypto()->hash($emotion);
            $meta = $this->_nebuleInstance->getCurrentEntity();

            // Détermine si l'émotion a été marqué par l'entité en cours.
            if ($object->getMarkEmotion($emotion, 'myself')) {
                // Création du lien.
                $action = 'x';
                $link = $action . '_' . $source . '_' . $target . '_' . $meta;
                $htlink .= '&' . Actions::DEFAULT_COMMAND_ACTION_SIGN_LINK1 . '=' . $link . $this->_nebuleInstance->getActionTicket();

                // Préparation de l'icône de l'émotion.
                $icon = $this->convertReferenceImage($listEmotions1[$emotion], $emotion, 'iconInlineDisplay');
            } else {
                // Création du lien.
                $action = 'f';
                $link = $action . '_' . $source . '_' . $target . '_' . $meta;
                $htlink .= '&' . Actions::DEFAULT_COMMAND_ACTION_SIGN_LINK1 . '=' . $link . $this->_nebuleInstance->getActionTicket();

                // Préparation de l'icône de l'émotion.
                $icon = $this->convertReferenceImage($listEmotions0[$emotion], $emotion, 'iconInlineDisplay');
            }

            // Si connecté, l'icône est active.
            if ($this->_unlocked
                && $this->_nebuleInstance->getOption('permitWrite')
                && $this->_nebuleInstance->getOption('permitWriteLink')
            ) {
                $result .= $this->convertHypertextLink($icon, $htlink);
            } else {
                $result .= $icon;
            }

            // Détermine le nombre d'entités qui ont marqué cette émotion.
            $count = $object->getMarkEmotionSize($emotion, 'all');
            if ($count > 0) {
                $result .= $count . ' ';
            }
        }

        // Fermeture de la DIV.
        $result .= "\n\t</p>\n</div>\n";

        return $result;
    }


    /**
     * Affiche le bouton pour continuer l'affichage lorsque la liste est longue.
     *
     * @param string $ref
     * @param string $url
     * @param string $text
     * @return boolean
     */
    public function displayButtonNextObject($ref, $url, $text)
    {
        if ($ref == '') {
            return false;
        }
        if ($url == '') {
            return false;
        }
        if ($text == '') {
            return false;
        }

        echo "<div class=\"inlinecontent\" id=\"$ref\">\n";
        echo "<p class=\"inlinecontentnext\" onclick=\"replaceNextContentFromURL('$ref', '$url')\">$text</p>\n";

        return true;
    }


    /**
     * Affiche des entrés.
     *
     * @param array $list
     * @return void
     */
    public function displayItemList($list)
    {
        if (sizeof($list) == 0) {
            return;
        }
        ?>

        <div class="textAction">
            <?php
            foreach ($list as $item) {
                // Affichage.
                if (is_a($item['object'], 'Node')) {
                    $this->_displayArboItem($item);
                }
            }
            unset($name, $icon, $desc, $link);
            ?>

            <div class="oneAction-close"></div>
        </div>
        <?php
    }

    /**
     * Affiche un élément de l'arborescence.
     *
     * @param array $item
     * @return void
     */
    private function _displayArboItem($item)
    {
        if (sizeof($item) == 0) {
            return;
        }
        if (!is_a($item['object'], 'Node')
            && !is_a($item['object'], 'Entity')
            && !is_a($item['object'], 'Group')
            && !is_a($item['object'], 'Conversation')
            && !is_a($item['object'], 'Currency')
            && !is_a($item['object'], 'TokenPool')
            && !is_a($item['object'], 'Token')
            && !is_a($item['object'], 'Transaction')
            && !is_a($item['object'], 'Wallet')
        ) {
            return;
        }

        // Extraction.
        $object = $item['object'];

        $entity = null;
        $entityID = '0';
        if (is_a($item['entity'], 'entity')) {
            $entity = $item['entity'];
            $entityID = $entity->getID();
        } elseif ($item['entity'] != ''
            && $item['entity'] != '0'
            && ctype_xdigit($item['entity'])
            && $this->_nebuleInstance->getIO()->checkObjectPresent($item['entity'])
            && $this->_nebuleInstance->getIO()->checkLinkPresent($item['entity'])
        ) {
            $entity = $this->_nebuleInstance->newEntity($item['entity']);
            $entityID = $entity->getID();
        }

        $htlink = '';
        if (isset($item['link'])) {
            $htlink = $item['link'];
        }

        $desc = '';
        if (isset($item['desc'])) {
            $desc = $this->_traductionInstance->getTraduction($item['desc']);
        }

        $icon = '';
        if (isset($item['icon'])) {
            $icon = $item['icon'];
        }

        $type = $object->getType('all');
        // Extrait un nom d'objet à afficher de façon correcte.
        $entityName = '';
        if ($entityID != '0') {
            $entityName = $entity->getFullName('all');
        }

        if ($object->getIsEntity('all')) {
            $name = $object->getFullName('all');
        } else {
            $name = $object->getName('all');
        }
        $namesize = 21;
        $shortname = $name;

        // Normalise la variable si vide.
        $htlink = $this->prepareDefaultObjectOrGroupOrEntityHtlink($object, $htlink);
        ?>

        <div class="oneActionItem" id="<?php
        if ($entityID == $this->_applicationInstance->getCurrentEntity()) {
            echo 'selfEntity';
        } else {
            echo 'otherEntity';
        }
        ?>">
            <div class="oneActionItem-top">
                <div class="oneAction-icon">
                    <?php $this->displayObjectColorIcon($object, $htlink, $icon); ?>
                </div>
                <?php
                if ($entityName != '') {
                    ?>

                    <div class="oneAction-entityname">
                        <p><?php $this->_applicationInstance->getDisplayInstance()->displayInlineObjectColorIconName($entity); ?></p>
                    </div>
                    <?php
                }
                ?>

                <div class="oneAction-title">
                    <p><?php $this->displayHypertextLink($shortname, $htlink); ?></p>
                </div>
                <?php
                if (isset($item['desc'])
                    && strlen($item['desc']) != 0
                ) {
                    ?>

                    <div class="oneAction-text">
                        <p><?php echo $desc; ?></p>
                    </div>
                    <?php
                }
                ?>

            </div>
            <?php
            if ($object->getMarkWarning()
                || $object->getMarkDanger()
                || $object->getMarkProtected()
                || (isset($item['actions'])
                    && sizeof($item['actions']) != 0
                )
            ) {
                ?>

                <div class="oneActionItem-bottom">
                    <?php
                    if ($object->getMarkWarning()) {
                        ?>

                        <div class="oneAction-warn">
                            <p><?php $this->displayUpdateImage(
                                    self::DEFAULT_ICON_IWARN,
                                    ':::display:content:warningTaggedWarning',
                                    'iconInlineDisplay');
                                echo ' ';
                                $this->_traductionInstance->echoTraduction(':::display:content:warningTaggedWarning'); ?></p>
                        </div>
                        <?php
                    }
                    if ($object->getMarkDanger()) {
                        ?>

                        <div class="oneAction-error">
                            <p><?php $this->displayUpdateImage(
                                    self::DEFAULT_ICON_IERR,
                                    ':::display:content:errorBan',
                                    'iconInlineDisplay');
                                echo ' ';
                                $this->_traductionInstance->echoTraduction(':::display:content:errorBan'); ?></p>
                        </div>
                        <?php
                    }
                    if ($object->getMarkProtected()) {
                        ?>

                        <div class="oneAction-ok">
                            <p><?php $this->displayUpdateImage(
                                    self::DEFAULT_ICON_LK,
                                    ':::display:content:ObjectProctected',
                                    'iconInlineDisplay');
                                echo ' ';
                                $this->_traductionInstance->echoTraduction(':::display:content:ObjectProctected'); ?></p>
                        </div>
                        <?php
                    }
                    if (isset($item['actions'])
                        && sizeof($item['actions']) != 0
                    ) {
                        ?>

                        <div class="oneAction-actions">
                            <?php
                            foreach ($item['actions'] as $action) {
                                $actionIcon = $this->convertUpdateImage($action['icon'], $action['name'], 'iconInlineDisplay');
                                $actionName = $this->_traductionInstance->getTraduction($action['name']);
                                echo '<p>' . $actionIcon . ' ' . $this->convertHypertextLink($actionName, $action['link']) . "</p>\n";
                                unset($actionIcon, $actionName);
                            }
                            ?>
                        </div>
                        <?php
                    }
                    ?>
                </div>
                <?php
            }
            ?>

        </div>
        <?php
        unset($object, $entityName, $name, $shortname, $icon, $desc);
    }
}


/**
 * Classe Actions communes.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
abstract class Actions
{
    /* ---------- ---------- ---------- ---------- ----------
	 * Constantes.
	 *
	 * Leur modification change profondément le comportement de l'application.
	 *
	 * Si déclarées 'const' ou 'static' elles ne sont pas remplacée dans les classes enfants
	 *   lorsque l'on appelle des fonctions de la classe parente non écrite dans la classe enfant.
	 */
    const DEFAULT_COMMAND_APPLICATION = 'a';
    const DEFAULT_COMMAND_NEBULE_BOOTSTRAP = 'a=0';
    const DEFAULT_COMMAND_NEBULE_FLUSH = 'f';
    const DEFAULT_COMMAND_NEBULE_RESCUE = 'r';
    const DEFAULT_COMMAND_ACTION_SIGN_LINK1 = 'actsiglnk1';
    const DEFAULT_COMMAND_ACTION_SIGN_LINK1_OBFUSCATE = 'actsiglnk1o';
    const DEFAULT_COMMAND_ACTION_SIGN_LINK2 = 'actsiglnk2';
    const DEFAULT_COMMAND_ACTION_SIGN_LINK2_OBFUSCATE = 'actsiglnk2o';
    const DEFAULT_COMMAND_ACTION_SIGN_LINK3 = 'actsiglnk3';
    const DEFAULT_COMMAND_ACTION_SIGN_LINK3_OBFUSCATE = 'actsiglnk3o';
    const DEFAULT_COMMAND_ACTION_UPLOAD_SIGNED_LINK = 'actupsl';
    const DEFAULT_COMMAND_ACTION_UPLOAD_FILE_LINKS = 'actupfl';
    const DEFAULT_COMMAND_ACTION_OBFUSCATE_LINK = 'actobflnk';
    const DEFAULT_COMMAND_ACTION_DELETE_OBJECT = 'actdelobj';
    const DEFAULT_COMMAND_ACTION_DELETE_OBJECT_FORCE = 'actdelobjf';
    const DEFAULT_COMMAND_ACTION_DELETE_OBJECT_OBFUSCATE = 'actdelobjo';
    const DEFAULT_COMMAND_ACTION_PROTECT_OBJECT = 'actprtobj';
    const DEFAULT_COMMAND_ACTION_UNPROTECT_OBJECT = 'actuprtobj';
    const DEFAULT_COMMAND_ACTION_SHARE_PROTECT_TO_ENTITY = 'actshrprtent';
    const DEFAULT_COMMAND_ACTION_SHARE_PROTECT_TO_GROUP_OPENED = 'actshrprtgrpo';
    const DEFAULT_COMMAND_ACTION_SHARE_PROTECT_TO_GROUP_CLOSED = 'actshrprtgrpc';
    const DEFAULT_COMMAND_ACTION_CANCEL_SHARE_PROTECT_TO_ENTITY = 'actushrprtent';
    const DEFAULT_COMMAND_ACTION_SYNCHRONIZE_OBJECT = 'actsynobj';
    const DEFAULT_COMMAND_ACTION_SYNCHRONIZE_ENTITY = 'actsynent';
    const DEFAULT_COMMAND_ACTION_SYNCHRONIZE_NEW_ENTITY = 'actsynnewent';
    const DEFAULT_COMMAND_ACTION_SYNCHRONIZE_LINKS = 'actsynlnk';
    const DEFAULT_COMMAND_ACTION_SYNCHRONIZE_APPLICATION = 'actsynapp';
    const DEFAULT_COMMAND_ACTION_UPLOAD_FILE = 'upfile';
    const DEFAULT_COMMAND_ACTION_UPLOAD_FILE_UPDATE = 'upfilemaj';
    const DEFAULT_COMMAND_ACTION_UPLOAD_FILE_ASK_UPDATE = 'upfileaskmaj';
    const DEFAULT_COMMAND_ACTION_UPLOAD_FILE_PROTECT = 'upfileprt';
    const DEFAULT_COMMAND_ACTION_UPLOAD_FILE_OBFUSCATE_LINKS = 'upfileobf';
    const DEFAULT_COMMAND_ACTION_UPLOAD_TEXT = 'uptext';
    const DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_NAME = 'uptextname';
    const DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_TYPE = 'uptexttype';
    const DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_PROTECT = 'uptextprt';
    const DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_OBFUSCATE_LINKS = 'uptextobf';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY = 'creaent';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_PREFIX = 'creaentprefix';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_SUFFIX = 'creaentsuffix';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_FIRSTNAME = 'creaentfstnam';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_NIKENAME = 'creaentniknam';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_NAME = 'creaentnam';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_PASSWORD1 = 'creaentpwd1';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_PASSWORD2 = 'creaentpwd2';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_ALGORITHM = 'creaentalgo';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_TYPE = 'creaenttype';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_AUTONOMY = 'creaentaut';
    const DEFAULT_COMMAND_ACTION_CREATE_ENTITY_OBFUSCATE_LINKS = 'creaentobf';
    const DEFAULT_COMMAND_ACTION_CREATE_GROUP = 'creagrp';
    const DEFAULT_COMMAND_ACTION_CREATE_GROUP_NAME = 'creagrpnam';
    const DEFAULT_COMMAND_ACTION_CREATE_GROUP_CLOSED = 'creagrpcld';
    const DEFAULT_COMMAND_ACTION_CREATE_GROUP_OBFUSCATE_LINKS = 'creagrpobf';
    const DEFAULT_COMMAND_ACTION_DELETE_GROUP = 'actdelgrp';
    const DEFAULT_COMMAND_ACTION_ADD_TO_GROUP = 'actaddtogrp';
    const DEFAULT_COMMAND_ACTION_REMOVE_FROM_GROUP = 'actremtogrp';
    const DEFAULT_COMMAND_ACTION_ADD_ITEM_TO_GROUP = 'actadditogrp';
    const DEFAULT_COMMAND_ACTION_REMOVE_ITEM_FROM_GROUP = 'actremitogrp';
    const DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION = 'creacvt';
    const DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION_NAME = 'creacvtnam';
    const DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION_CLOSED = 'creacvtcld';
    const DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION_PROTECTED = 'creacvtprt';
    const DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION_OBFUSCATE_LINKS = 'creacvtobf';
    const DEFAULT_COMMAND_ACTION_DELETE_CONVERSATION = 'actdelcvt';
    const DEFAULT_COMMAND_ACTION_ADD_TO_CONVERSATION = 'actaddtocvt';
    const DEFAULT_COMMAND_ACTION_REMOVE_FROM_CONVERSATION = 'actremtocvt';
    const DEFAULT_COMMAND_ACTION_ADD_ITEM_TO_CONVERSATION = 'actadditocvt';
    const DEFAULT_COMMAND_ACTION_REMOVE_ITEM_FROM_CONVERSATION = 'actremitocvt';
    const DEFAULT_COMMAND_ACTION_CREATE_MESSAGE = 'creamsg';
    const DEFAULT_COMMAND_ACTION_CREATE_MESSAGE_PROTECTED = 'creamsgprt';
    const DEFAULT_COMMAND_ACTION_CREATE_MESSAGE_OBFUSCATE_LINKS = 'creamsgobf';
    const DEFAULT_COMMAND_ACTION_MARK_OBJECT = 'actmarkobj';
    const DEFAULT_COMMAND_ACTION_UNMARK_OBJECT = 'actunmarkobj';
    const DEFAULT_COMMAND_ACTION_UNMARK_ALL_OBJECT = 'actunmarkallobj';
    const DEFAULT_COMMAND_ACTION_ADD_PROPERTY = 'actaddprop';
    const DEFAULT_COMMAND_ACTION_ADD_PROPERTY_OBJECT = 'actaddpropobj';
    const DEFAULT_COMMAND_ACTION_ADD_PROPERTY_VALUE = 'actaddpropval';
    const DEFAULT_COMMAND_ACTION_ADD_PROPERTY_PROTECTED = 'actaddpropprf';
    const DEFAULT_COMMAND_ACTION_ADD_PROPERTY_OBFUSCATE_LINKS = 'actaddpropobf';
    const DEFAULT_COMMAND_ACTION_CREATE_CURRENCY = 'creacur';
    const DEFAULT_COMMAND_ACTION_CREATE_TOKEN_POOL = 'creactp';
    const DEFAULT_COMMAND_ACTION_CREATE_TOKENS = 'creactk';
    const DEFAULT_COMMAND_ACTION_CREATE_TOKENS_COUNT = 'creactkcnt';


    /* ---------- ---------- ---------- ---------- ----------
	 * Variables.
	 *
	 * Les valeurs par défaut sont indicatives. Ne pas les replacer.
	 * Les variables sont systématiquement recalculées.
	 */
    /**
     * Instance nebule.
     *
     * @var nebule
     */
    protected $_nebuleInstance;

    /**
     * Instance sylabe.
     *
     * @var sylabe
     */
    protected $_applicationInstance;

    /**
     * Instance de metrologie.
     *
     * @var metrology
     */
    protected $_metrology;

    /**
     * Instance des entrées/sorties.
     *
     * @var IO
     */
    protected $_io;

    /**
     * Instance de traduction.
     *
     * @var Traductions
     */
    protected $_traduction;

    /**
     * Instance d'affichage.
     *
     * @var Displays
     */
    protected $_display;

    /**
     * Etat de verrouillage de l'entité en cours.
     *
     * @var boolean
     */
    protected $_unlocked = false;

    /**
     * Constructeur.
     *
     * @param Application $applicationInstance
     * @return void
     */
    public function __construct(Application $applicationInstance)
    {
        $this->_applicationInstance = $applicationInstance;
    }

    /**
     * Initialisation des variables et instances interdépendantes.
     *
     * @return void
     */
    public function initialisation()
    {
        $this->_nebuleInstance = $this->_applicationInstance->getNebuleInstance();
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Load actions', Metrology::LOG_LEVEL_DEBUG); // Log
        $this->_traduction = $this->_applicationInstance->getTraductionInstance();
        $this->_display = $this->_applicationInstance->getDisplayInstance();
        $this->_metrology = $this->_applicationInstance->getMetrologyInstance();
        $this->_io = $this->_nebuleInstance->getIO();
        $this->_unlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();

        // Aucun affichage, aucune traduction, aucune action avant le retour de cette fonction.
        // Les instances interdépendantes doivent être synchronisées.
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return 'Action';
    }

    /**
     * Fonction de mise en sommeil.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return array();
    }

    /**
     * Fonction de réveil.
     *
     * Récupère l'instance de la librairie nebule et de l'application.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $applicationInstance;

        $this->_applicationInstance = $applicationInstance;
    }

    /**
     * Initialisation des variables et instances interdépendantes.
     * @return void
     * @todo à optimiser avec __wakeup et __sleep.
     *
     */
    public function initialisation2()
    {
        $this->_nebuleInstance = $this->_applicationInstance->getNebuleInstance();
        $this->_nebuleInstance->getMetrologyInstance()->addLog('Load actions', Metrology::LOG_LEVEL_DEBUG); // Log
        $this->_traduction = $this->_applicationInstance->getTraductionInstance();
        $this->_display = $this->_applicationInstance->getDisplayInstance();
        $this->_metrology = $this->_applicationInstance->getMetrologyInstance();
        $this->_io = $this->_nebuleInstance->getIO();
        $this->_unlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();

        // Aucun affichage, aucune traduction, aucune action avant le retour de cette fonction.
        // Les instances interdépendantes doivent être synchronisées.
    }


    /**
     * Traitement des actions génériques.
     *
     * Tout traitement générique doit se faire entité déverrouillée.
     * Les actions nécessitent la création de nouveaux liens.
     *
     * @return void
     */
    public function genericActions()
    {
        $this->_metrology->addLog('Generic actions', Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie que l'entité est déverrouillée.
        if (!$this->_unlocked) {
            return;
        }

        // Extrait les actions.
        $this->_extractActionObfuscateLink();
        $this->_extractActionDeleteObject();
        $this->_extractActionProtectObject();
        $this->_extractActionUnprotectObject();
        $this->_extractActionShareProtectObjectToEntity();
        $this->_extractActionShareProtectObjectToGroupOpened();
        $this->_extractActionShareProtectObjectToGroupClosed();
        $this->_extractActionCancelShareProtectObjectToEntity();
        $this->_extractActionSynchronizeObject();
        $this->_extractActionSynchronizeEntity();
        $this->_extractActionSynchronizeObjectLinks();
        $this->_extractActionSynchronizeApplication();
        $this->_extractActionSynchronizeNewEntity();
        $this->_extractActionMarkObject();
        $this->_extractActionUnmarkObject();
        $this->_extractActionUnmarkAllObjects();
        $this->_extractActionUploadFile();
        $this->_extractActionUploadText();
        $this->_extractActionCreateGroup();
        $this->_extractActionDeleteGroup();
        $this->_extractActionAddToGroup();
        $this->_extractActionRemoveFromGroup();
        $this->_extractActionAddItemToGroup();
        $this->_extractActionRemoveItemFromGroup();
        $this->_extractActionCreateConversation();
        $this->_extractActionDeleteConversation();
        $this->_extractActionAddMessageOnConversation();
        $this->_extractActionRemoveMessageOnConversation();
        $this->_extractActionAddMemberOnConversation();
        $this->_extractActionRemoveMemberOnConversation();
        $this->_extractActionCreateMessage();
        $this->_extractActionCreateCurrency();
        $this->_extractActionCreateTokenPool();
        $this->_extractActionCreateTokens();
        $this->_extractActionAddProperty();

        $this->_metrology->addLog('Router generic actions', Metrology::LOG_LEVEL_DEBUG); // Log

        // Gère la dissimulation d'un lien.
        if ($this->_actionObfuscateLinkInstance != ''
            && is_a($this->_actionObfuscateLinkInstance, 'Link')
            && $this->_nebuleInstance->getOption('permitObfuscatedLink')
        ) {
            $this->_actionObfuscateLink();
        }

        // Gère la suppression d'un objet.
        if ($this->_actionDeleteObject
            && is_a($this->_actionDeleteObjectInstance, 'Node')
        ) {
            $this->_actionDeleteObject();
        }

        // Gère la protection/déprotection d'un objet.
        if ($this->_actionProtectObjectInstance != ''
            && is_a($this->_actionProtectObjectInstance, 'Node')
        ) {
            $this->_actionProtectObject();
        }
        if ($this->_actionUnprotectObjectInstance != ''
            && is_a($this->_actionUnprotectObjectInstance, 'Node')
        ) {
            $this->_actionUnprotectObject();
        }
        if ($this->_actionShareProtectObjectToEntity != '') {
            $this->_actionShareProtectObjectToEntity();
        }
        if ($this->_actionShareProtectObjectToGroupOpened != '') {
            $this->_actionShareProtectObjectToGroupOpened();
        }
        if ($this->_actionShareProtectObjectToGroupClosed != '') {
            $this->_actionShareProtectObjectToGroupClosed();
        }
        if ($this->_actionCancelShareProtectObjectToEntity != '') {
            $this->_actionCancelShareProtectObjectToEntity();
        }

        // Gère les synchronisations (toujours les objets avant les liens).
        if ($this->_actionSynchronizeObjectInstance != '') {
            $this->_actionSynchronizeObject();
        }
        if ($this->_actionSynchronizeEntityInstance != '') {
            $this->_actionSynchronizeEntity();
        }
        if ($this->_actionSynchronizeObjectLinksInstance != '') {
            $this->_actionSynchronizeObjectLinks();
        }
        if ($this->_actionSynchronizeApplicationInstance != '') {
            $this->_actionSynchronizeApplication();
        }
        if ($this->_actionSynchronizeNewEntityID != '') {
            $this->_actionSynchronizeNewEntity();
        }

        // Gère les marques des objets.
        if ($this->_actionMarkObject != '') {
            $this->_actionMarkObject();
        }
        if ($this->_actionUnmarkObject != '') {
            $this->_actionUnmarkObject();
        }
        if ($this->_actionUnmarkAllObjects) {
            $this->_actionUnmarkAllObjects();
        }

        // Gère les téléchargements.
        if ($this->_actionUploadFile) {
            $this->_actionUploadFile();
        }
        if ($this->_actionUploadText) {
            $this->_actionUploadText();
        }

        // Gère les groupes.
        if ($this->_actionCreateGroup) {
            $this->_actionCreateGroup();
        }
        if ($this->_actionDeleteGroup) {
            $this->_actionDeleteGroup();
        }
        if ($this->_actionAddToGroup != '') {
            $this->_actionAddToGroup();
        }
        if ($this->_actionRemoveFromGroup != '') {
            $this->_actionRemoveFromGroup();
        }
        if ($this->_actionAddItemToGroup != '') {
            $this->_actionAddItemToGroup();
        }
        if ($this->_actionRemoveItemFromGroup != '') {
            $this->_actionRemoveItemFromGroup();
        }

        // Gère les conversations et messages.
        if ($this->_actionCreateConversation) {
            $this->_actionCreateConversation();
        }
        if ($this->_actionDeleteConversation) {
            $this->_actionDeleteConversation();
        }
        if ($this->_actionAddMessageOnConversation != '') {
            $this->_actionAddMessageOnConversation();
        }
        if ($this->_actionRemoveMessageOnConversation != '') {
            $this->_actionRemoveMessageOnConversation();
        }
        if ($this->_actionAddMemberOnConversation != '') {
            $this->_actionAddMemberOnConversation();
        }
        if ($this->_actionRemoveMemberOnConversation != '') {
            $this->_actionRemoveMemberOnConversation();
        }
        if ($this->_actionCreateMessage) {
            $this->_actionCreateMessage();
        }
        if ($this->_actionAddProperty != '') {
            $this->_actionAddProperty();
        }

        // Gère les monnaies.
        if ($this->_actionCreateCurrency) {
            $this->_actionCreateCurrency();
        }
        if ($this->_actionCreateTokenPool) {
            $this->_actionCreateTokenPool();
        }
        if ($this->_actionCreateTokens) {
            $this->_actionCreateTokens();
        }

        $this->_metrology->addLog('Generic actions end', Metrology::LOG_LEVEL_DEBUG); // Log
    }


    /**
     * Traitement des actions spéciales.
     *
     * Les actions peuvent être réalisées sans entité déverrouillée, mais pas nécessairement.
     * Certaines actions ne nécessitent pas la création de nouveaux liens. C'est par exemple
     *   le cas de la génération d'une nouvelle entité qui va générer ses propres liens.
     * Certaines actions peuvent avoir un comportement restreint si elles ne peuvent générer
     *   de nouveaux liens mais permettre de prendre en compte des liens déjà signés.
     *
     * Les actions spéciales doivent avoir des pré-requis bien ciblés pour éviter tout contournement.
     *
     * @return void
     */
    public function specialActions()
    {
        $this->_metrology->addLog('Special actions', Metrology::LOG_LEVEL_DEBUG); // Log

        // Vérifie que l'action de création d'entité soit permise entité verrouillée.
        if ($this->_unlocked
            || $this->_nebuleInstance->getOption('permitPublicCreateEntity')
        ) {
            $this->_extractActionCreateEntity();
        }

        // Vérifie que l'action de chargement de lien soit permise.
        if ($this->_nebuleInstance->getOption('permitUploadLink')
            || $this->_unlocked
        ) {
            // Extrait les actions.
            $this->_extractActionSignLink1();
            $this->_extractActionSignLink2();
            $this->_extractActionSignLink3();
            $this->_extractActionUploadLink();
            $this->_extractActionUploadFileLinks();
        }

        $this->_metrology->addLog('Router generic actions', Metrology::LOG_LEVEL_DEBUG); // Log

        // Si l'action de création d'entité est validée.
        if ($this->_actionCreateEntity) {
            $this->_actionCreateEntity();
        }

        // Si l'action de chargement de lien est permise y compris entité verrouillée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitUploadLink')
            && ($this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                || $this->_nebuleInstance->getOption('permitPublicUploadLink')
                || $this->_unlocked
            )
        ) {
            // Lien à signer 1.
            if ($this->_unlocked
                && $this->_nebuleInstance->getOption('permitCreateLink')
                && $this->_actionSignLinkInstance1 != ''
                && is_a($this->_actionSignLinkInstance1, 'Link')
            ) {
                $this->_actionSignLink($this->_actionSignLinkInstance1, $this->_actionSignLinkInstance1Obfuscate);
            }

            // Lien à signer 2.
            if ($this->_unlocked
                && $this->_nebuleInstance->getOption('permitCreateLink')
                && $this->_actionSignLinkInstance2 != ''
                && is_a($this->_actionSignLinkInstance2, 'Link')
            ) {
                $this->_actionSignLink($this->_actionSignLinkInstance2, $this->_actionSignLinkInstance2Obfuscate);
            }

            // Lien à signer 3.
            if ($this->_unlocked
                && $this->_nebuleInstance->getOption('permitCreateLink')
                && $this->_actionSignLinkInstance3 != ''
                && is_a($this->_actionSignLinkInstance3, 'Link')
            ) {
                $this->_actionSignLink($this->_actionSignLinkInstance3, $this->_actionSignLinkInstance3Obfuscate);
            }

            // Liens pré-signés.
            if ($this->_actionUploadLinkInstance != null
                && is_a($this->_actionUploadLinkInstance, 'Link')
            ) {
                $this->_actionUploadLink($this->_actionUploadLinkInstance);
            }

            // Fichier de liens pré-signés.
            if ($this->_actionUploadFileLinks) {
                $this->_actionUploadFileLinks();
            }
        }

        $this->_metrology->addLog('Special actions end', Metrology::LOG_LEVEL_DEBUG); // Log
    }


    /**
     * Extrait pour action si on doit signer un lien (1).
     */
    protected function _extractActionSignLink1()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCreateLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action sign link 1', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SIGN_LINK1, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            $argObfuscate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SIGN_LINK1_OBFUSCATE);

            // Si le champs est vide, extrait le contenu de la variable POST.
            if ($arg == '') {
                $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_SIGN_LINK1, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            }

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) != 0
            ) {
                $this->_actionSignLinkInstance1 = $this->_nebuleInstance->flatLinkExtractAsInstance($arg);
                $this->_actionSignLinkInstance1Obfuscate = $argObfuscate;
            }
            unset($arg);
        }
    }

    protected $_actionSignLinkInstance1 = '';
    protected $_actionSignLinkInstance1Obfuscate = false;

    /**
     * Extrait pour action si on doit signer un lien (2).
     */
    protected function _extractActionSignLink2()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCreateLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action sign link 2', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SIGN_LINK2, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            $argObfuscate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SIGN_LINK2_OBFUSCATE);

            // Si le champs est vide, extrait le contenu de la variable POST.
            if ($arg == '') {
                $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_SIGN_LINK2, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            }

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) != 0
            ) {
                $this->_actionSignLinkInstance2 = $this->_nebuleInstance->flatLinkExtractAsInstance($arg);
                $this->_actionSignLinkInstance2Obfuscate = $argObfuscate;
            }
            unset($arg);
        }
    }

    protected $_actionSignLinkInstance2 = '';
    protected $_actionSignLinkInstance2Obfuscate = false;

    /**
     * Extrait pour action si on doit signer un lien (3).
     */
    protected function _extractActionSignLink3()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCreateLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action sign link 3', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SIGN_LINK3, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            $argObfuscate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SIGN_LINK3_OBFUSCATE);

            // Si le champs est vide, extrait le contenu de la variable POST.
            if ($arg == '') {
                $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_SIGN_LINK3, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            }

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) != 0
            ) {
                $this->_actionSignLinkInstance3 = $this->_nebuleInstance->flatLinkExtractAsInstance($arg);
                $this->_actionSignLinkInstance3Obfuscate = $argObfuscate;
            }
            unset($arg);
        }
    }

    protected $_actionSignLinkInstance3 = '';
    protected $_actionSignLinkInstance3Obfuscate = false;


    /**
     * Définit si il y a une action en cours de chargement de lien pré-signé.
     * Contient le lien à charger ou un texte vide.
     *
     * @var Link|string
     */
    protected $_actionUploadLinkInstance = null;

    /**
     * Extrait un lien pré-signé.
     *
     * Nécessite :
     * - droit d'écriture
     * - droit d'écriture des liens
     * - droit de chargement de liens
     * - droit de chargement public de liens ou du maître du code ou entité déverrouillée
     *
     * @return void
     */
    protected function _extractActionUploadLink()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitUploadLink')
            && ($this->_nebuleInstance->getOption('permitPublicUploadLink')
                || $this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                || $this->_unlocked
            )
        ) {
            $this->_metrology->addLog('Extract action upload signed link', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_UPLOAD_SIGNED_LINK, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Si le champs est vide, extrait le contenu de la variable POST.
            if ($arg == '') {
                $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_SIGNED_LINK, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            }

            // Vérifie si restriction des liens au maître du code. Non par défaut.
            $permitNotCodeMaster = false;
            if ($this->_nebuleInstance->getOption('permitPublicUploadLink')
                || $this->_unlocked
            ) {
                $permitNotCodeMaster = true;
            }

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) != 0
            ) {
                $instance = $this->_nebuleInstance->flatLinkExtractAsInstance($arg);
                if ($instance->getVerified()
                    && $instance->getValid()
                    && $instance->getSigned()
                    && ($instance->getHashSigner_disabled() == $this->_nebuleInstance->getCodeAuthority()
                        || $permitNotCodeMaster
                    )
                ) {
                    $this->_actionUploadLinkInstance = $instance;
                }
                unset($instance);
            }
            unset($arg);
        }
    }


    /**
     * Extrait pour action si on doit dissimuler un lien.
     */
    protected function _extractActionObfuscateLink()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitObfuscatedLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action obfuscate link', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_OBFUSCATE_LINK, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Si le champs est vide, extrait le contenu de la variable POST.
            if ($arg == '') {
                $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_OBFUSCATE_LINK, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            }

            // Extraction du lien et stockage pour traitement.
            if (strlen($arg) != 0) {
                $this->_actionObfuscateLinkInstance = $this->_nebuleInstance->flatLinkExtractAsInstance($arg);
            }
            unset($arg);
        }
    }

    protected $_actionObfuscateLinkInstance = '';


    /**
     * Renvoie si l'action de suppression d'objet est validée.
     */
    public function getDeleteObject()
    {
        return $this->_actionDeleteObject;
    }

    /**
     * Renvoie l'ID de l'objet supprimé.
     */
    public function getDeleteObjectID()
    {
        return $this->_actionDeleteObjectID;
    }

    /**
     * Extrait pour action si on doit supprimer l'objet en cours.
     */
    protected function _extractActionDeleteObject()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action delete object', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $argObject = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_DELETE_OBJECT, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
            $argForce = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_DELETE_OBJECT_FORCE);
            $argObfuscate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_DELETE_OBJECT_OBFUSCATE);

            // Extraction de l'objet à supprimer.
            if ($argObject != ''
                && strlen($argObject) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($argObject)
            ) {
                $this->_actionDeleteObjectID = $argObject;
                $this->_actionDeleteObjectInstance = $this->_nebuleInstance->newObject($argObject);
                $this->_actionDeleteObject = true;
            }
            // Extraction si la suppression doit être forcée.
            if ($argForce) {
                $this->_actionDeleteObjectForce = true;
            }
            // Extraction si la suppression doit être cachée.
            if ($argObfuscate
                && $this->_nebuleInstance->getOption('permitObfuscatedLink')
            ) {
                $this->_actionDeleteObjectObfuscate = true;
            }

            unset($argObject, $argForce, $argObfuscate);
        }
    }

    protected $_actionDeleteObject = false;
    protected $_actionDeleteObjectID = '0';
    protected $_actionDeleteObjectInstance = '';
    protected $_actionDeleteObjectForce = '';
    protected $_actionDeleteObjectObfuscate = '';


    /**
     * Extrait pour action si on doit protéger l'objet en cours.
     */
    protected function _extractActionProtectObject()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action protect object', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_PROTECT_OBJECT, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionProtectObjectInstance = $this->_nebuleInstance->newObject($arg);
            }
            unset($arg);
        }
    }

    protected $_actionProtectObjectInstance = '';


    /**
     * Extrait pour action si on doit déprotéger l'objet en cours.
     */
    protected function _extractActionUnprotectObject()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action unprotect object', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_UNPROTECT_OBJECT, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionUnprotectObjectInstance = $this->_nebuleInstance->newObject($arg);
            }
            unset($arg);
        }
    }

    protected $_actionUnprotectObjectInstance = '';


    /**
     * Extrait pour action si on doit partager la protection de l'objet à une entité.
     */
    protected function _extractActionShareProtectObjectToEntity()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action share protect object to entity', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SHARE_PROTECT_TO_ENTITY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionShareProtectObjectToEntity = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionShareProtectObjectToEntity = '';


    /**
     * Extrait pour action si on doit partager la protection de l'objet à un groupe ouvert.
     */
    protected function _extractActionShareProtectObjectToGroupOpened()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action share protect object to opened group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SHARE_PROTECT_TO_GROUP_OPENED, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionShareProtectObjectToGroupOpened = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionShareProtectObjectToGroupOpened = '';


    /**
     * Extrait pour action si on doit partager la protection de l'objet à un groupe ouvert.
     */
    protected function _extractActionShareProtectObjectToGroupClosed()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action share protect object to closed group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SHARE_PROTECT_TO_GROUP_CLOSED, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionShareProtectObjectToGroupClosed = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionShareProtectObjectToGroupClosed = '';


    /**
     * Extrait pour action si on doit annuler le partage la protection de l'objet à une entité.
     */
    protected function _extractActionCancelShareProtectObjectToEntity()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action cancel share protect object to entity', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_CANCEL_SHARE_PROTECT_TO_ENTITY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionCancelShareProtectObjectToEntity = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionCancelShareProtectObjectToEntity = '';


    /**
     * Retourne l'objet synchronisé.
     * @return string|entity
     */
    public function getSynchronizeObjectInstance()
    {
        return $this->_actionSynchronizeObjectInstance;
    }

    /**
     * Extrait pour action si on doit synchroniser l'objet en cours.
     */
    protected function _extractActionSynchronizeObject()
    {
        // Vérifie que l'écriture d'objets soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
        ) {
            $this->_metrology->addLog('Extract action synchronize object', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SYNCHRONIZE_OBJECT, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction de l'id et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionSynchronizeObjectInstance = $this->_nebuleInstance->newObject($arg);
            }
            unset($arg);
        }
    }

    protected $_actionSynchronizeObjectInstance = '';


    /**
     * Retourne l'entité synchronisée.
     * @return string|entity
     */
    public function getSynchronizeEntityInstance()
    {
        return $this->_actionSynchronizeEntityInstance;
    }

    /**
     * Extrait pour action si on doit synchroniser l'objet en cours.
     */
    protected function _extractActionSynchronizeEntity()
    {
        // Vérifie que l'écriture d'objets soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
        ) {
            $this->_metrology->addLog('Extract action synchronize entity', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SYNCHRONIZE_ENTITY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction de l'id et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionSynchronizeEntityInstance = $this->_nebuleInstance->newEntity($arg);
            }
            unset($arg);
        }
    }

    protected $_actionSynchronizeEntityInstance = '';


    /**
     * Retourne l'objet synchronisé.
     * @return string|entity
     */
    public function getSynchronizeObjectLinksInstance()
    {
        return $this->_actionSynchronizeObjectLinksInstance;
    }

    /**
     * Extrait pour action si on doit synchroniser les liens de l'objet en cours.
     */
    protected function _extractActionSynchronizeObjectLinks()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
        ) {
            $this->_metrology->addLog('Extract action synchronize object links', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SYNCHRONIZE_LINKS, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction de l'id et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionSynchronizeObjectLinksInstance = $this->_nebuleInstance->newObject($arg);
            }
            unset($arg);
        }
    }

    protected $_actionSynchronizeObjectLinksInstance = '';


    /**
     * Retourne l'entité synchronisée.
     * @return string|entity
     */
    public function getSynchronizeApplicationInstance()
    {
        return $this->_actionSynchronizeApplicationInstance;
    }

    /**
     * Extrait pour action si on doit synchroniser l'objet en cours.
     */
    protected function _extractActionSynchronizeApplication()
    {
        // Vérifie que l'écriture d'objets soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitSynchronizeObject')
            && $this->_nebuleInstance->getOption('permitSynchronizeLink')
            && $this->_nebuleInstance->getOption('permitSynchronizeApplication')
            && ($this->_nebuleInstance->getOption('permitPublicSynchronizeApplication')
                || $this->_unlocked
            )
        ) {
            $this->_metrology->addLog('Extract action synchronize entity', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_SYNCHRONIZE_APPLICATION, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction de l'id et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionSynchronizeApplicationInstance = $this->_nebuleInstance->newObject($arg);
            }
            unset($arg);
        }
    }

    protected $_actionSynchronizeApplicationInstance = '';


    /**
     * Retourne l'entité synchronisée depuis une URL.
     * @return string|entity
     */
    public function getSynchronizeNewEntityInstance()
    {
        return $this->_actionSynchronizeNewEntityInstance;
    }

    /**
     * Extrait pour action si on doit synchroniser l'objet en cours.
     */
    protected function _extractActionSynchronizeNewEntity()
    {
        // Vérifie que l'écriture d'objets soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitSynchronizeObject')
            && $this->_nebuleInstance->getOption('permitSynchronizeLink')
        ) {
            $this->_metrology->addLog('Extract action synchronize new entity', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
			 *  ------------------------------------------------------------------------------------------
			 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
			 *  ------------------------------------------------------------------------------------------
			 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_SYNCHRONIZE_NEW_ENTITY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction de l'URL et stockage pour traitement.
            if ($arg != ''
                && strlen($arg) >= 9
                && ctype_print($arg)
            ) {
                // Décompose l'URL.
                $parseURL = parse_url($arg);
                // Extrait le protocol.
                if (isset($parseURL['scheme'])
                    && ($parseURL['scheme'] == 'http'
                        || $parseURL['scheme'] == 'https'
                    )
                ) {
                    $scheme = $parseURL['scheme'];
                } else {
                    // Il manque le protocol, suppose que c'est http.
                    $scheme = 'http';
                    $parseURL = parse_url($scheme . '://' . $arg);
                }
                // Vérifie les champs de l'URL.
                if ($parseURL['host'] != ''
                    && $parseURL['path'] != ''
                    && substr($parseURL['path'], 0, 3) == '/o/'
                ) {
                    // Extrait l'ID de l'objet de l'entité à synchroniser.
                    $id = substr($parseURL['path'], 3);
                    $this->_metrology->addLog('Extract action synchronize new entity - ID=' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
                    // Vérifie l'ID.
                    if (!$this->_io->checkObjectPresent($id)
                        && ctype_xdigit($id)
                    ) {
                        // Si c'est bon on prépare pour la synchronisation.
                        $this->_actionSynchronizeNewEntityID = $id;
                        $this->_actionSynchronizeNewEntityURL = $scheme . '://' . $parseURL['host'];
                        if (isset($parseURL['port'])) {
                            $port = $parseURL['port'];
                            $this->_actionSynchronizeNewEntityURL .= ':' . $port;
                        }
                        $this->_metrology->addLog('Extract action synchronize new entity - URL=' . $this->_actionSynchronizeNewEntityURL, Metrology::LOG_LEVEL_DEBUG); // Log
                    }
                }
            }
            unset($arg);
        }
    }

    protected $_actionSynchronizeNewEntityID = '';
    protected $_actionSynchronizeNewEntityURL = '';
    protected $_actionSynchronizeNewEntityInstance = '';


    /**
     * Extrait pour action si on doit marquer un objet.
     */
    protected function _extractActionMarkObject()
    {
        $this->_metrology->addLog('Extract action mark object', Metrology::LOG_LEVEL_DEBUG); // Log

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_MARK_OBJECT, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

        // Extraction du lien et stockage pour traitement.
        if ($arg != ''
            && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
            && ctype_xdigit($arg)
        ) {
            $this->_actionMarkObject = $arg;
        }
        unset($arg);
    }

    protected $_actionMarkObject = '';


    /**
     * Extrait pour action si on doit retirer la marque d'un objet.
     */
    protected function _extractActionUnmarkObject()
    {
        $this->_metrology->addLog('Extract action unmark object', Metrology::LOG_LEVEL_DEBUG); // Log

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_UNMARK_OBJECT, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

        // Extraction du lien et stockage pour traitement.
        if ($arg != ''
            && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
            && ctype_xdigit($arg)
        ) {
            $this->_actionUnmarkObject = $arg;
        }
        unset($arg);
    }

    protected $_actionUnmarkObject = '';


    /**
     * Extrait pour action si on doit supprimer toutes les marques des objets.
     *
     * @return void
     */
    protected function _extractActionUnmarkAllObjects()
    {
        $this->_metrology->addLog('Extract action unmark all objects', Metrology::LOG_LEVEL_DEBUG); // Log

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        $arg = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_UNMARK_ALL_OBJECT);

        // Extraction du lien et stockage pour traitement.
        if ($arg !== false) {
            $this->_actionUnmarkAllObjects = true;
        }
        unset($arg);
    }

    protected $_actionUnmarkAllObjects = false;


    /**
     * Définit si il y a une action en cours de téléchargement d'un fichier de liens pré-signés.
     *
     * @var boolean
     */
    protected $_actionUploadFileLinks = false;
    /**
     * Nom du fichier de liens pré-signés.
     *
     * @var string
     */
    protected $_actionUploadFileLinksName = '';
    /**
     * Taille du fichier de liens pré-signés.
     *
     * @var string
     */
    protected $_actionUploadFileLinksSize = '';
    /**
     * Chemin du fichier de liens pré-signés.
     *
     * @var string
     */
    protected $_actionUploadFileLinksPath = '';
    /**
     * Statut d'erreur de traitement.
     *
     * @var boolean
     */
    protected $_actionUploadFileLinksError = false;
    /**
     * Message du statut d'erreur de traitement.
     *
     * @var string
     */
    protected $_actionUploadFileLinksErrorMessage = 'Initialisation du transfert.';

    /**
     * Renvoie si l'action de transfert de fichier de liens pré-signés vers le serveur est validé.
     *
     * @return boolean
     */
    public function getUploadFileSignedLinks()
    {
        return $this->_actionUploadFileLinks;
    }

    /**
     * Extrait pour action si un fichier de liens pré-signés est téléchargé vers le serveur.
     *
     * Nécessite :
     * - droit d'écriture
     * - droit d'écriture des liens
     * - droit de chargement de liens
     * - droit de chargement public de liens ou du maître du code ou entité déverrouillée
     *
     * @return void
     */
    protected function _extractActionUploadFileLinks()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitUploadLink')
            && ($this->_nebuleInstance->getOption('permitPublicUploadLink')
                || $this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                || $this->_unlocked
            )
        ) {
            $this->_metrology->addLog('Extract action upload file of signed links', Metrology::LOG_LEVEL_DEBUG); // Log

            // Lit le contenu de la variable _FILE si un fichier est téléchargé.
            if (isset($_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_LINKS]['error'])
                && $_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_LINKS]['error'] == UPLOAD_ERR_OK
                && trim($_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_LINKS]['name']) != ''
            ) {
                /*
				 *  ------------------------------------------------------------------------------------------
				 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
				 *  ------------------------------------------------------------------------------------------
				 */
                // Extraction des méta données du fichier.
                $upname = mb_convert_encoding(strtok(trim(filter_var($_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_LINKS]['name'], FILTER_SANITIZE_STRING)), "\n"), 'UTF-8');
                $upsize = $_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_LINKS]['size'];
                $uppath = $_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_LINKS]['tmp_name'];

                // Si le fichier est bien téléchargé.
                if (file_exists($uppath)) {
                    // Si le fichier n'est pas trop gros.
                    if ($upsize <= $this->_nebuleInstance->getOption('ioReadMaxData')) {
                        // Ecriture des variables.
                        $this->_actionUploadFileLinks = true;
                        $this->_actionUploadFileLinksName = $upname;
                        $this->_actionUploadFileLinksSize = $upsize;
                        $this->_actionUploadFileLinksPath = $uppath;
                    } else {
                        $this->_metrology->addLog('Action _extractActionUploadFileLinks File size too big', Metrology::LOG_LEVEL_ERROR); // Log
                        $this->_actionUploadFileLinksError = true;
                        $this->_actionUploadFileLinksErrorMessage = 'File size too big';
                    }
                } else {
                    $this->_metrology->addLog('Action _extractActionUploadFileLinks File upload error', Metrology::LOG_LEVEL_ERROR); // Log
                    $this->_actionUploadFileLinksError = true;
                    $this->_actionUploadFileLinksErrorMessage = 'File upload error';
                }
                unset($upname, $upsize, $uppath);
            }
        }
    }


    /*
	 * Transfert de fichier et nébulisation.
	 */
    protected $_actionUploadFile = false,
        $_actionUploadFileID = '0',
        $_actionUploadFileName = '',
        $_actionUploadFileExtension = '',
        $_actionUploadFileType = '',
        $_actionUploadFileSize = '',
        $_actionUploadFilePath = '',
        $_actionUploadFileUpdate = false,
        $_actionUploadFileProtect = false,
        $_actionUploadFileObfuscateLinks = false,
        $_actionUploadFileError = false,
        $_actionUploadFileErrorMessage = 'Initialisation du transfert.';

    /**
     * Renvoie si l'action de transfert de fichier vers le serveur est validée.
     *
     * @return boolean
     */
    public function getUploadObject()
    {
        return $this->_actionUploadFile;
    }

    /**
     * Renvoie l'ID du fichier téléchargé vers le serveur.
     *
     * @return string
     */
    public function getUploadObjectID()
    {
        return $this->_actionUploadFileID;
    }

    /**
     * Renvoie si erreur.
     *
     * @return boolean
     */
    public function getUploadObjectError()
    {
        return $this->_actionUploadFileError;
    }

    /**
     * Renvoie le message d'erreur.
     *
     * @return string
     */
    public function getUploadObjectErrorMessage()
    {
        return $this->_actionUploadFileErrorMessage;
    }

    /**
     * Extrait pour action si un fichier est téléchargé vers le serveur.
     *
     * @return void
     */
    protected function _extractActionUploadFile()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action upload file', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            $uploadArgName = self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE;
            if (!isset($_FILES[$uploadArgName])) {
                return;
            }
            $uploadRawName = $_FILES[$uploadArgName]['name'];
            $uploadError = $_FILES[$uploadArgName]['error'];

            switch ($_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE]['error']) {
                case UPLOAD_ERR_OK:
                    // Extraction des méta données du fichier.
                    $upfname = mb_convert_encoding(strtok(trim(filter_var($_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE]['name'], FILTER_SANITIZE_STRING)), "\n"), 'UTF-8');
                    $upinfo = pathinfo($upfname);
                    $upext = $upinfo['extension'];
                    $upname = basename($upfname, '.' . $upext);
                    $upsize = $_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE]['size'];
                    $uppath = $_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE]['tmp_name'];
                    $uptype = '';
                    // Si le fichier est bien téléchargé.
                    if (file_exists($uppath)) {
                        // Si le fichier n'est pas trop gros.
                        if ($upsize <= $this->_nebuleInstance->getOption('ioReadMaxData')) {
                            // Lit le type mime.
                            $finfo = finfo_open(FILEINFO_MIME_TYPE);
                            $uptype = finfo_file($finfo, $uppath);
                            finfo_close($finfo);
                            if ($uptype == 'application/octet-stream') {
                                $uptype = $this->_getFilenameTypeMime("$upname.$upext");
                            }

                            // Extrait les options de téléchargement.
                            $argUpd = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_UPDATE);
                            $argPrt = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_PROTECT);
                            $argObf = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE_OBFUSCATE_LINKS);

                            // Ecriture des variables.
                            $this->_actionUploadFile = true;
                            $this->_actionUploadFileName = $upname;
                            $this->_actionUploadFileExtension = $upext;
                            $this->_actionUploadFileType = $uptype;
                            $this->_actionUploadFileSize = $upsize;
                            $this->_actionUploadFilePath = $uppath;
                            $this->_actionUploadFileUpdate = $argUpd;
                            if ($this->_nebuleInstance->getOption('permitProtectedObject')) {
                                $this->_actionUploadFileProtect = $argPrt;
                            }
                            if ($this->_nebuleInstance->getOption('permitObfuscatedLink')) {
                                $this->_actionUploadFileObfuscateLinks = $argObf;
                            }
                        } else {
                            $this->_metrology->addLog('Action _extractActionUploadFile ioReadMaxData exeeded', Metrology::LOG_LEVEL_ERROR);
                            $this->_actionUploadFileError = true;
                            $this->_actionUploadFileErrorMessage = 'Le fichier dépasse la taille limite de transfert.';
                        }
                    } else {
                        $this->_metrology->addLog('Action _extractActionUploadFile upload error', Metrology::LOG_LEVEL_ERROR);
                        $this->_actionUploadFileError = true;
                        $this->_actionUploadFileErrorMessage = "No uploaded file.";
                    }
                    unset($upfname, $upinfo, $upext, $upname, $upsize, $uppath, $uptype);
                    break;
                case UPLOAD_ERR_INI_SIZE:
                    $this->_metrology->addLog('Action _extractActionUploadFile upload PHP error UPLOAD_ERR_INI_SIZE', Metrology::LOG_LEVEL_ERROR);
                    $this->_actionUploadFileError = true;
                    $this->_actionUploadFileErrorMessage = "The uploaded file exceeds the upload_max_filesize directive in php.ini.";
                    break;
                case UPLOAD_ERR_FORM_SIZE:
                    $this->_metrology->addLog('Action _extractActionUploadFile upload PHP error UPLOAD_ERR_FORM_SIZE', Metrology::LOG_LEVEL_ERROR);
                    $this->_actionUploadFileError = true;
                    $this->_actionUploadFileErrorMessage = "The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form.";
                    break;
                case UPLOAD_ERR_PARTIAL:
                    $this->_metrology->addLog('Action _extractActionUploadFile upload PHP error UPLOAD_ERR_PARTIAL', Metrology::LOG_LEVEL_ERROR);
                    $this->_actionUploadFileError = true;
                    $this->_actionUploadFileErrorMessage = "The uploaded file was only partially uploaded.";
                    break;
                case UPLOAD_ERR_NO_FILE:
                    $this->_metrology->addLog('Action _extractActionUploadFile upload PHP error UPLOAD_ERR_NO_FILE', Metrology::LOG_LEVEL_ERROR);
                    $this->_actionUploadFileError = true;
                    $this->_actionUploadFileErrorMessage = "No file was uploaded.";
                    break;
                case UPLOAD_ERR_NO_TMP_DIR:
                    $this->_metrology->addLog('Action _extractActionUploadFile upload PHP error UPLOAD_ERR_NO_TMP_DIR', Metrology::LOG_LEVEL_ERROR);
                    $this->_actionUploadFileError = true;
                    $this->_actionUploadFileErrorMessage = "Missing a temporary folder.";
                    break;
                case UPLOAD_ERR_CANT_WRITE:
                    $this->_metrology->addLog('Action _extractActionUploadFile upload PHP error UPLOAD_ERR_CANT_WRITE', Metrology::LOG_LEVEL_ERROR);
                    $this->_actionUploadFileError = true;
                    $this->_actionUploadFileErrorMessage = "Failed to write file to disk.";
                    break;
                case UPLOAD_ERR_EXTENSION:
                    $this->_metrology->addLog('Action _extractActionUploadFile upload PHP error UPLOAD_ERR_EXTENSION', Metrology::LOG_LEVEL_ERROR);
                    $this->_actionUploadFileError = true;
                    $this->_actionUploadFileErrorMessage = "A PHP extension stopped the file upload. PHP does not provide a way to ascertain which extension caused the file upload to stop.";
                    break;
            }
        }
    }

    /**
     * Lit le type mime d'un fichier par rapport à son extension et la table de correspondance $nebule_mimepathfile.
     *
     * @param string $f
     * @return string
     */
    protected function _getFilenameTypeMime($f)
    {
        $m = '/etc/mime.types'; // Chemin du fichier pour trouver le type mime.
        $e = substr(strrchr($f, '.'), 1);
        if (empty($e)) {
            return 'application/octet-stream';
        }
        $r = "/^([\w\+\-\.\/]+)\s+(\w+\s)*($e\s)/i";
        $ls = file($m);
        foreach ($ls as $l) {
            if (substr($l, 0, 1) == '#') {
                continue;
            }
            $l = rtrim($l) . ' ';
            if (!preg_match($r, $l, $m)) {
                continue;
            }
            return $m[1];
        }
        return 'application/octet-stream';
    }


    /*
	 * Transfert de texte et nébulisation.
	 */
    protected $_actionUploadText = false;
    protected $_actionUploadTextName = '';
    protected $_actionUploadTextType = '';
    protected $_actionUploadTextContent = '';
    protected $_actionUploadTextID = '0';
    protected $_actionUploadTextProtect = false;
    protected $_actionUploadTextObfuscateLinks = false;
    protected $_actionUploadTextError = false;
    protected $_actionUploadTextErrorMessage = 'Initialisation du transfert.';

    /**
     * Renvoie si l'action de transfert de texte vers le serveur est validée.
     *
     * @return boolean
     */
    public function getUploadText()
    {
        return $this->_actionUploadText;
    }

    /**
     * Renvoie le nom du texte téléchargé vers le serveur.
     */
    public function getUploadTextName()
    {
        return $this->_actionUploadTextName;
    }

    /**
     * Renvoie l'ID du texte téléchargé vers le serveur.
     */
    public function getUploadTextID()
    {
        return $this->_actionUploadTextID;
    }

    /**
     * Renvoie le code erreur.
     */
    public function getUploadTextError()
    {
        return $this->_actionUploadTextError;
    }

    /**
     * Renvoie le message d'erreur.
     */
    public function getUploadTextErrorMessage()
    {
        return $this->_actionUploadTextErrorMessage;
    }

    /**
     * Extrait pour action si un texte est téléchargé vers le serveur.
     */
    protected function _extractActionUploadText()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisées.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action upload text', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit si la variable POST existe.
            $arg = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_TEXT);

            // Extraction du lien et stockage pour traitement.
            if ($arg !== false) {
                // Lit et nettoye le contenu des variables POST.
                $argText = filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_TEXT, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);
                $argName = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_NAME, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                $argType = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_TYPE, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));

                // Extrait les options de téléchargement.
                $argPrt = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_PROTECT);
                $argObf = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_OBFUSCATE_LINKS);

                if (strlen($argText) != 0) {
                    $this->_actionUploadText = true;
                    $this->_actionUploadTextContent = $argText;
                    $this->_actionUploadTextName = $argName;
                    if ($argType != '') {
                        $this->_actionUploadTextType = $argType;
                    } else {
                        $this->_actionUploadTextType = nebule::REFERENCE_OBJECT_TEXT;
                    }

                    if ($this->_nebuleInstance->getOption('permitProtectedObject')) {
                        $this->_actionUploadTextProtect = $argPrt;
                    }
                    if ($this->_nebuleInstance->getOption('permitObfuscatedLink')) {
                        $this->_actionUploadTextObfuscateLinks = $argObf;
                    }
                }
                unset($argText, $argName, $argPrt, $argObf);
            }
            unset($arg);
        }
    }


    /*
	 * Création d'entité.
	 */
    protected $_actionCreateEntity = false;
    protected $_actionCreateEntityPrefix = '';
    protected $_actionCreateEntitySuffix = '';
    protected $_actionCreateEntityFirstname = '';
    protected $_actionCreateEntityNikename = '';
    protected $_actionCreateEntityName = '';
    protected $_actionCreateEntityPassword = '';
    protected $_actionCreateEntityType = '';
    protected $_actionCreateEntityID = '0';
    protected $_actionCreateEntityObfuscateLinks = false;
    protected $_actionCreateEntityInstance = '';
    protected $_actionCreateEntityError = false;
    protected $_actionCreateEntityErrorMessage = 'Initialisation de la création.';

    /**
     * Renvoie si l'action de création d'entité a été faite.
     *
     * @return boolean
     */
    public function getCreateEntity()
    {
        return $this->_actionCreateEntity;
    }

    /**
     * Revoie l'ID de la nouvelle entité.
     */
    public function getCreateEntityID()
    {
        return $this->_actionCreateEntityID;
    }

    /**
     * Revoie l'instance de la nouvelle entité.
     */
    public function getCreateEntityInstance()
    {
        return $this->_actionCreateEntityInstance;
    }

    /**
     * Revoie le code erreur de création de la nouvelle entité.
     *
     * @return boolean
     */
    public function getCreateEntityError()
    {
        return $this->_actionCreateEntityError;
    }

    /**
     * Revoie le message d'erreur de création de la nouvelle entité.
     */
    public function getCreateEntityErrorMessage()
    {
        return $this->_actionCreateEntityErrorMessage;
    }

    /**
     * Extrait pour action si une entité doit être créée.
     */
    protected function _extractActionCreateEntity()
    {
        // Vérifie que la création de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteEntity')
            && ($this->_unlocked
                || $this->_nebuleInstance->getOption('permitPublicCreateEntity')
            )
        ) {
            $this->_metrology->addLog('Extract action create entity', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argCreate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY);

            // Extraction du lien et stockage pour traitement.
            if ($argCreate !== false) {
                $this->_actionCreateEntity = true;
            }
            unset($argCreate);

            // Si on crée une nouvelle entité.
            if ($this->_actionCreateEntity) {
                // Lit et nettoye le contenu des variables GET.
                $argPrefix = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_PREFIX, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                $argSuffix = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_SUFFIX, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                $argFstnam = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_FIRSTNAME, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                $argNiknam = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_NIKENAME, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                $argName = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_NAME, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                $argPasswd1 = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_PASSWORD1, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                $argPasswd2 = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_PASSWORD2, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                $argType = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_TYPE, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

                // Extrait les options de téléchargement.
                $argObf = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_ENTITY_OBFUSCATE_LINKS);

                // Sauvegarde les valeurs.
                $this->_actionCreateEntityPrefix = $argPrefix;
                $this->_actionCreateEntitySuffix = $argSuffix;
                $this->_actionCreateEntityFirstname = $argFstnam;
                $this->_actionCreateEntityNikename = $argNiknam;
                $this->_actionCreateEntityName = $argName;
                if ($this->_nebuleInstance->getOption('permitObfuscatedLink')) {
                    $this->_actionCreateEntityObfuscateLinks = $argObf;
                }

                if ($argPasswd1 == $argPasswd2) {
                    $this->_actionCreateEntityPassword = $argPasswd1;
                } else {
                    $this->_metrology->addLog('Action _extractActionCreateEntity passwords not match', Metrology::LOG_LEVEL_ERROR); // Log
                    $this->_actionCreateEntityError = true;
                    $this->_actionCreateEntityErrorMessage = 'Les mots de passes ne sont pas identiques.';
                }

                if ($argType == 'human'
                    || $argType == 'robot'
                ) {
                    $this->_actionCreateEntityType = $argType;
                } else {
                    $this->_actionCreateEntityType = '';
                }

                unset($argPrefix, $argSuffix, $argFstnam, $argNiknam, $argName, $argPasswd1, $argPasswd2, $argType);
            }
        } else {
            $this->_metrology->addLog('Action _extractActionCreateEntity not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateEntityError = true;
            $this->_actionCreateEntityErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Renvoie si l'action de création du groupe a été faite.
     */
    public function getCreateGroup()
    {
        return $this->_actionCreateGroup;
    }

    /**
     * Revoie l'ID du nouveau groupe.
     */
    public function getCreateGroupID()
    {
        return $this->_actionCreateGroupID;
    }

    /**
     * Revoie l'instance du nouveau groupe.
     */
    public function getCreateGroupInstance()
    {
        return $this->_actionCreateGroupInstance;
    }

    /**
     * Revoie le code erreur de création du nouveau groupe.
     */
    public function getCreateGroupError()
    {
        return $this->_actionCreateGroupError;
    }

    /**
     * Revoie le message d'erreur de création du nouveau groupe.
     */
    public function getCreateGroupErrorMessage()
    {
        return $this->_actionCreateGroupErrorMessage;
    }

    /**
     * Extrait pour action si un groupe doit être créé.
     */
    protected function _extractActionCreateGroup()
    {
        // Vérifie que la création de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action create group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argCreate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_CREATE_GROUP);

            // Extraction du lien et stockage pour traitement.
            if ($argCreate !== false) {
                $this->_actionCreateGroup = true;
            }
            unset($argCreate);

            // Si on crée une nouvelle entité.
            if ($this->_actionCreateGroup) {
                // Lit et nettoye le contenu des variables GET.
                $argName = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_GROUP_NAME, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));

                // Extrait les options de téléchargement.
                $argCld = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_GROUP_CLOSED);
                $argObf = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_GROUP_OBFUSCATE_LINKS);

                // Sauvegarde les valeurs.
                $this->_actionCreateGroupName = $argName;
                $this->_actionCreateGroupClosed = $argCld;
                if ($this->_nebuleInstance->getOption('permitObfuscatedLink')) {
                    $this->_actionCreateGroupObfuscateLinks = $argObf;
                }

                unset($argName);
            }
        } else {
            $this->_metrology->addLog('Action _extractActionCreateGroup not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateGroupError = true;
            $this->_actionCreateGroupErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionCreateGroup = false,
        $_actionCreateGroupName = '',
        $_actionCreateGroupID = '0',
        $_actionCreateGroupClosed = false,
        $_actionCreateGroupObfuscateLinks = false,
        $_actionCreateGroupInstance = '',
        $_actionCreateGroupError = false,
        $_actionCreateGroupErrorMessage = 'Initialisation de la création.';


    /**
     * Renvoie si l'action de suppression du groupe a été faite.
     */
    public function getDeleteGroup()
    {
        return $this->_actionDeleteGroup;
    }

    /**
     * Revoie l'ID du groupe.
     */
    public function getDeleteGroupID()
    {
        return $this->_actionDeleteGroupID;
    }

    /**
     * Revoie le code erreur de suppression du groupe.
     */
    public function getDeleteGroupError()
    {
        return $this->_actionDeleteGroupError;
    }

    /**
     * Revoie le message d'erreur de suppression du groupe.
     */
    public function getDeleteGroupErrorMessage()
    {
        return $this->_actionDeleteGroupErrorMessage;
    }

    /**
     * Extrait pour action si un groupe doit être supprimé.
     */
    protected function _extractActionDeleteGroup()
    {
        // Vérifie que la suppression de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action delete group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argDelete = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_DELETE_GROUP, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($argDelete !== ''
                && strlen($argDelete) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($argDelete)
            ) {
                $this->_actionDeleteGroup = true;
                $this->_actionDeleteGroupID = $argDelete;
            }
            unset($argDelete);
        } else {
            $this->_metrology->addLog('Action _extractActionDeleteGroup not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionDeleteGroupError = true;
            $this->_actionDeleteGroupErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionDeleteGroup = false,
        $_actionDeleteGroupID = '0',
        $_actionDeleteGroupError = false,
        $_actionDeleteGroupErrorMessage = 'Initialisation de la supression.';


    /**
     * Renvoie si l'action d'ajout de objet courant au groupe a été faite.
     */
    public function getAddToGroup()
    {
        return $this->_actionAddToGroup;
    }

    /**
     * Extrait pour action si l'objet courant doit être ajouté à un groupe.
     */
    protected function _extractActionAddToGroup()
    {
        // Vérifie que l'ajout de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action add to group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_ADD_TO_GROUP, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg !== ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionAddToGroup = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionAddToGroup = '';


    /**
     * Renvoie si l'action de suppression de l'objet courant du groupe a été faite.
     */
    public function getRemoveFromGroup()
    {
        return $this->_actionRemoveFromGroup;
    }

    /**
     * Extrait pour action si l'objet courant doit être retirer d'un groupe.
     */
    protected function _extractActionRemoveFromGroup()
    {
        // Vérifie que l'ajout de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action remove from group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_REMOVE_FROM_GROUP, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg !== ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionRemoveFromGroup = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionRemoveFromGroup = '';


    /**
     * Renvoie si l'action d'ajout d'un objet au groupe courant a été faite.
     */
    public function getAddItemToGroup()
    {
        return $this->_actionAddItemToGroup;
    }

    /**
     * Extrait pour action si un objet doit être ajouté au groupe courant.
     */
    protected function _extractActionAddItemToGroup()
    {
        // Vérifie que l'ajout de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action add item to group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_ADD_ITEM_TO_GROUP, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg !== ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionAddItemToGroup = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionAddItemToGroup = '';


    /**
     * Renvoie si l'action de retrait du groupe a été faite.
     */
    public function getRemoveItemFromGroup()
    {
        return $this->_actionRemoveItemFromGroup;
    }

    /**
     * Extrait pour action si un objet doit être retiré au groupe courant.
     */
    protected function _extractActionRemoveItemFromGroup()
    {
        // Vérifie que l'ajout de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action remove item from group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_REMOVE_ITEM_FROM_GROUP, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg !== ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionRemoveItemFromGroup = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionRemoveItemFromGroup = '';


    /**
     * Renvoie si l'action de création de la conversation a été faite.
     */
    public function getCreateConversation()
    {
        return $this->_actionCreateConversation;
    }

    /**
     * Revoie l'ID de la nouvelle conversation.
     */
    public function getCreateConversationID()
    {
        return $this->_actionCreateConversationID;
    }

    /**
     * Revoie l'instance de la nouvelle conversation.
     */
    public function getCreateConversationInstance()
    {
        return $this->_actionCreateConversationInstance;
    }

    /**
     * Revoie le code erreur de création de la nouvelle conversation.
     */
    public function getCreateConversationError()
    {
        return $this->_actionCreateConversationError;
    }

    /**
     * Revoie le message d'erreur de création de la nouvelle conversation.
     */
    public function getCreateConversationErrorMessage()
    {
        return $this->_actionCreateConversationErrorMessage;
    }

    /**
     * Extrait pour action si une conversation doit être créé.
     */
    protected function _extractActionCreateConversation()
    {
        // Vérifie que la création de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action create group', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argCreate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION);

            // Extraction du lien et stockage pour traitement.
            if ($argCreate !== false) {
                $this->_actionCreateConversation = true;
            }
            unset($argCreate);

            // Si on crée une nouvelle conversation.
            if ($this->_actionCreateConversation) {
                // Lit et nettoye le contenu des variables GET.
                $argName = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION_NAME, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));

                // Extrait les options de téléchargement.
                $argCld = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION_CLOSED);
                $argPrt = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION_PROTECTED);
                $argObf = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_CONVERSATION_OBFUSCATE_LINKS);

                // Sauvegarde les valeurs.
                $this->_actionCreateConversationName = $argName;
                $this->_actionCreateConversationClosed = $argCld;
                if ($this->_nebuleInstance->getOption('permitProtectedObject')) {
                    $this->_actionCreateConversationProtected = $argPrt;
                }
                if ($this->_nebuleInstance->getOption('permitObfuscatedLink')) {
                    $this->_actionCreateConversationObfuscateLinks = $argObf;
                }

                unset($argName);
            }
        } else {
            $this->_metrology->addLog('Action _extractActionCreateConversation not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateConversationError = true;
            $this->_actionCreateConversationErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionCreateConversation = false,
        $_actionCreateConversationName = '',
        $_actionCreateConversationID = '0',
        $_actionCreateConversationClosed = false,
        $_actionCreateConversationProtected = false,
        $_actionCreateConversationObfuscateLinks = false,
        $_actionCreateConversationInstance = '',
        $_actionCreateConversationError = false,
        $_actionCreateConversationErrorMessage = 'Initialisation de la création.';


    /**
     * Renvoie si l'action de suppression de la conversation a été faite.
     */
    public function getDeleteConversation()
    {
        return $this->_actionDeleteConversation;
    }

    /**
     * Revoie l'ID de la conversation.
     */
    public function getDeleteConversationID()
    {
        return $this->_actionDeleteConversationID;
    }

    /**
     * Revoie le code erreur de suppression de la conversation.
     */
    public function getDeleteConversationError()
    {
        return $this->_actionDeleteConversationError;
    }

    /**
     * Revoie le message d'erreur de suppression de la conversation.
     */
    public function getDeleteConversationErrorMessage()
    {
        return $this->_actionDeleteConversationErrorMessage;
    }

    /**
     * Extrait pour action si une conversation doit être supprimé.
     */
    protected function _extractActionDeleteConversation()
    {
        // Vérifie que la suppression de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action delete conversation', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argDelete = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_DELETE_CONVERSATION, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($argDelete !== ''
                && strlen($argDelete) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($argDelete)
            ) {
                $this->_actionDeleteConversation = true;
                $this->_actionDeleteConversationID = $argDelete;
            }
            unset($argDelete);
        } else {
            $this->_metrology->addLog('Action _extractActionDeleteConversation not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionDeleteConversationError = true;
            $this->_actionDeleteConversationErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionDeleteConversation = false,
        $_actionDeleteConversationID = '0',
        $_actionDeleteConversationError = false,
        $_actionDeleteConversationErrorMessage = 'Initialisation de la supression.';


    /**
     * Renvoie si l'action d'ajout de objet courant à la conversation a été faite.
     */
    public function getAddMessageOnConversation()
    {
        return $this->_actionAddMessageOnConversation;
    }

    /**
     * Extrait pour action si l'objet courant doit être ajouté à une conversation.
     */
    protected function _extractActionAddMessageOnConversation()
    {
        // Vérifie que l'ajout de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action add to conversation', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_ADD_TO_CONVERSATION, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg !== ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionAddMessageOnConversation = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionAddMessageOnConversation = '';


    /**
     * Renvoie si l'action de suppression de l'objet courant de la conversation a été faite.
     */
    public function getRemoveMessageOnConversation()
    {
        return $this->_actionRemoveMessageOnConversation;
    }

    /**
     * Extrait pour action si l'objet courant doit être retirer d'une conversation.
     */
    protected function _extractActionRemoveMessageOnConversation()
    {
        // Vérifie que l'ajout de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action remove from conversation', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_REMOVE_FROM_CONVERSATION, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg !== ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionRemoveMessageOnConversation = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionRemoveMessageOnConversation = '';


    /**
     * Renvoie si l'action d'ajout d'un objet à la conversation courant a été faite.
     */
    public function getAddMemberOnConversation()
    {
        return $this->_actionAddMemberOnConversation;
    }

    /**
     * Extrait pour action si un objet doit être ajouté à la conversation courant.
     */
    protected function _extractActionAddMemberOnConversation()
    {
        // Vérifie que l'ajout de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action add item to conversation', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_ADD_ITEM_TO_CONVERSATION, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg !== ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionAddMemberOnConversation = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionAddMemberOnConversation = '';


    /**
     * Renvoie si l'action de retrait de la conversation a été faite.
     */
    public function getRemoveMemberOnConversation()
    {
        return $this->_actionRemoveMemberOnConversation;
    }

    /**
     * Extrait pour action si un objet doit être retiré à la conversation courant.
     */
    protected function _extractActionRemoveMemberOnConversation()
    {
        // Vérifie que l'ajout de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action remove item from conversation', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_REMOVE_ITEM_FROM_CONVERSATION, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($arg !== ''
                && strlen($arg) >= nebule::NEBULE_MINIMUM_ID_SIZE
                && ctype_xdigit($arg)
            ) {
                $this->_actionRemoveMemberOnConversation = $arg;
            }
            unset($arg);
        }
    }

    protected $_actionRemoveMemberOnConversation = '';

    /**
     * Extrait pour action si une conversation doit être créé.
     *
     * @return void
     */
    protected function _extractActionCreateMessage()
    {
        // Vérifie que la création de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action create message', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argCreate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_CREATE_MESSAGE);

            // Extraction du lien et stockage pour traitement.
            if ($argCreate !== false)
                $this->_actionCreateMessage = true;
            unset($argCreate);

            // Si on crée un nouveau message.
            if ($this->_actionCreateMessage) {
                // Extrait les options de téléchargement.
                // !!! Utilise les constantes de upload de texte pour que la protection et la dissimulation soient bien pris en compte.
                //$argPrt	= filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_MESSAGE_PROTECTED);
                $argPrt = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_PROTECT);
                //$argObf	= filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_MESSAGE_OBFUSCATE_LINKS);
                $argObf = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_UPLOAD_TEXT_OBFUSCATE_LINKS);

                // Sauvegarde les valeurs.
                if ($this->_nebuleInstance->getOption('permitProtectedObject')) {
                    $this->_actionCreateMessageProtected = $argPrt;
                }
                if ($this->_nebuleInstance->getOption('permitObfuscatedLink')) {
                    $this->_actionCreateMessageObfuscateLinks = $argObf;
                }
            }

            // Le reste des valeurs est récupéré par la partie création d'un texte.
        } else {
            $this->_metrology->addLog('Action _extractActionCreateMessage not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateMessageError = true;
            $this->_actionCreateMessageErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionCreateMessage = false,
        $_actionCreateMessageID = '0',
        $_actionCreateMessageError = false,
        $_actionCreateMessageProtected = false,
        $_actionCreateMessageObfuscateLinks = false,
        $_actionCreateMessageErrorMessage = 'Initialisation de la supression.';


    /**
     * Revoie le code erreur d'ajout de propriété.
     */
    public function getAddPropertyError()
    {
        return $this->_actionAddPropertyError;
    }

    /**
     * Revoie le message d'erreur d'ajout de propriété.
     */
    public function getAddPropertyErrorMessage()
    {
        return $this->_actionAddPropertyErrorMessage;
    }

    /**
     * Extrait pour action si une propriété doit être ajoutée à un objet.
     *
     * @return void
     */
    protected function _extractActionAddProperty()
    {
        // Vérifie que la création de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action add property', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argAdd = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_ADD_PROPERTY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));

            // Extraction du lien et stockage pour traitement.
            if ($argAdd != '')
                $this->_actionAddProperty = $argAdd;
            unset($argAdd);

            // Si on crée une nouvelle propriété.
            if ($this->_actionAddProperty != '') {
                // Extrait les autres variables.
                $argObj = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_ADD_PROPERTY_OBJECT, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW));
                $argVal = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_ADD_PROPERTY_VALUE, FILTER_SANITIZE_STRING));
                $argPrt = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_ADD_PROPERTY_PROTECTED);
                $argObf = filter_has_var(INPUT_POST, self::DEFAULT_COMMAND_ACTION_ADD_PROPERTY_OBFUSCATE_LINKS);

                // Sauvegarde les valeurs.
                if ($argVal != '') {
                    if ($argObj == '') {
                        $this->_actionAddPropertyObject = $this->_nebuleInstance->getCurrentObject();
                    } else {
                        $this->_actionAddPropertyObject = $argObj;
                    }
                    $this->_actionAddPropertyValue = $argVal;
                    if ($this->_nebuleInstance->getOption('permitProtectedObject')) {
                        $this->_actionAddPropertyProtected = $argPrt;
                    }
                    if ($this->_nebuleInstance->getOption('permitObfuscatedLink')) {
                        $this->_actionAddPropertyObfuscateLinks = $argObf;
                    }
                } else {
                    $this->_metrology->addLog('Action _extractActionAddProperty null value', Metrology::LOG_LEVEL_ERROR); // Log
                    $this->_actionAddPropertyError = true;
                    $this->_actionAddPropertyErrorMessage = 'Valeur vide.';
                }
                unset($argObj, $argVal, $argPrt, $argObf);
            }
        } else {
            $this->_metrology->addLog('Action _extractActionAddProperty not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionAddPropertyError = true;
            $this->_actionAddPropertyErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionAddProperty = '',
        $_actionAddPropertyObject = '',
        $_actionAddPropertyValue = '',
        $_actionAddPropertyProtected = false,
        $_actionAddPropertyObfuscateLinks = false,
        $_actionAddPropertyError = false,
        $_actionAddPropertyErrorMessage = 'Initialisation de la supression.';


    /**
     * Renvoie si l'action de création de la monnaie a été faite.
     *
     * @return boolean
     */
    public function getCreateCurrency()
    {
        return $this->_actionCreateCurrency;
    }

    /**
     * Revoie l'ID du nouveau sac de jetons.
     *
     * @return string
     */
    public function getCreateCurrencyID()
    {
        return $this->_actionCreateCurrencyID;
    }

    /**
     * Revoie l'instance du nouveau sac de jetons.
     *
     * @return Currency
     */
    public function getCreateCurrencyInstance()
    {
        return $this->_actionCreateCurrencyInstance;
    }

    /**
     * Revoie les paramètres de la nouvelle monnaie.
     *
     * @return array
     */
    public function getCreateCurrencyParam()
    {
        return $this->_actionCreateCurrencyParam;
    }

    /**
     * Revoie le code erreur de création de la nouvelle monnaie.
     *
     * @return boolean
     */
    public function getCreateCurrencyError()
    {
        return $this->_actionCreateCurrencyError;
    }

    /**
     * Revoie le message d'erreur de création de la nouvelle monnaie.
     *
     * @return string
     */
    public function getCreateCurrencyErrorMessage()
    {
        return $this->_actionCreateCurrencyErrorMessage;
    }

    /**
     * Extrait pour action si une monnaie doit être créé.
     *
     * array( 'currency' => array(
     * ...,
     * 'CurrencyType' => array(
     * 'key' => 'TYP',
     * 'shortname' => 'ctyp',
     * 'type' => 'string',
     * 'info' => 'omcptyp',
     * 'limit' => '32',
     * 'force' => 'cryptocurrency', ),
     * 'display' => '64',
     * 'forceable' => true,
     * ...,
     * ),
     * ...,
     * )
     *
     * @return void
     */
    protected function _extractActionCreateCurrency()
    {
        // Vérifie que la création de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCurrency')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action create currency', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argCreate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_CREATE_CURRENCY);

            // Extraction du lien et stockage pour traitement.
            if ($argCreate !== false) {
                $this->_actionCreateCurrency = true;
            }
            unset($argCreate);

            // Si on crée une nouvelle monnaie.
            if ($this->_actionCreateCurrency) {
                // Récupère la liste des propriétés.
                $instance = $this->_nebuleInstance->getCurrentCurrencyInstance();
                $propertiesList = $instance->getPropertiesList();
                unset($instance);

                foreach ($propertiesList['currency'] as $name => $property) {
                    // Extrait une valeur.
                    if (isset($property['checkbox'])) {
                        $value = '';
                        $valueArray = filter_input(INPUT_POST, $property['shortname'], FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES | FILTER_FORCE_ARRAY);
                        foreach ($valueArray as $item) {
                            $value .= ' ' . trim($item);
                        }
                        $this->_actionCreateCurrencyParam[$name] = trim($value);
                        unset($value, $valueArray);
                    } else {
                        $this->_actionCreateCurrencyParam[$name] = trim(filter_input(INPUT_POST, $property['shortname'], FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                    }
                    $this->_metrology->addLog('Extract action create currency - _' . $property['shortname'] . ':' . $this->_actionCreateCurrencyParam[$name], Metrology::LOG_LEVEL_DEVELOP); // Log

                    // Extrait si forcé.
                    if (isset($property['forceable'])) {
                        $this->_actionCreateCurrencyParam['Force' . $name] = filter_has_var(INPUT_POST, 'f' . $property['shortname']);
                        if ($this->_actionCreateCurrencyParam['Force' . $name]) {
                            $this->_metrology->addLog('Extract action create currency - f' . $property['shortname'] . ':true', Metrology::LOG_LEVEL_DEBUG); // Log
                        }
                    }
                }
            }
        } else {
//			$this->_actionCreateCurrencyError = true;
            $this->_actionCreateCurrencyErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionCreateCurrency = false;
    protected $_actionCreateCurrencyID = '';
    protected $_actionCreateCurrencyInstance = null;
    protected $_actionCreateCurrencyParam = array();
    protected $_actionCreateCurrencyError = false;
    protected $_actionCreateCurrencyErrorMessage = 'Initialisation de la création.';


    /**
     * Renvoie si l'action de création du sac de jetons a été faite.
     *
     * @return boolean
     */
    public function getCreateTokenPool()
    {
        return $this->_actionCreateTokenPool;
    }

    /**
     * Revoie l'ID du nouveau sac de jetons.
     *
     * @return string
     */
    public function getCreateTokenPoolID()
    {
        return $this->_actionCreateTokenPoolID;
    }

    /**
     * Revoie l'instance du nouveau sac de jetons.
     *
     * @return TokenPool
     */
    public function getCreateTokenPoolInstance()
    {
        return $this->_actionCreateTokenPoolInstance;
    }

    /**
     * Revoie les paramètres du nouveau sac de jetons.
     *
     * @return array
     */
    public function getCreateTokenPoolParam()
    {
        return $this->_actionCreateTokenPoolParam;
    }

    /**
     * Revoie le code erreur de création du nouveau sac de jetons.
     *
     * @return boolean
     */
    public function getCreateTokenPoolError()
    {
        return $this->_actionCreateTokenPoolError;
    }

    /**
     * Revoie le message d'erreur de création du nouveau sac de jetons.
     *
     * @return string
     */
    public function getCreateTokenPoolErrorMessage()
    {
        return $this->_actionCreateTokenPoolErrorMessage;
    }

    /**
     * Extrait pour action si un sac de jetons doit être créé.
     *
     * @return void
     */
    protected function _extractActionCreateTokenPool()
    {
        // Vérifie que la création de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCurrency')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action create token pool', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argCreate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_CREATE_TOKEN_POOL);

            // Extraction du lien et stockage pour traitement.
            if ($argCreate !== false) {
                $this->_actionCreateTokenPool = true;
            }
            unset($argCreate);

            // Si on crée un nouveau sac de jetons.
            if ($this->_actionCreateTokenPool) {
                // Récupère la liste des propriétés.
                $instance = $this->_nebuleInstance->getCurrentTokenPoolInstance();
                $propertiesList = $instance->getPropertiesList();
                unset($instance);

                foreach ($propertiesList['tokenpool'] as $name => $property) {
                    // Extrait une valeur.
                    if (isset($property['checkbox'])) {
                        $value = '';
                        $valueArray = filter_input(INPUT_POST, $property['shortname'], FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES | FILTER_FORCE_ARRAY);
                        foreach ($valueArray as $item) {
                            $value .= ' ' . trim($item);
                        }
                        $this->_actionCreateTokenPoolParam[$name] = trim($value);
                        unset($value, $valueArray);
                    } else {
                        $this->_actionCreateTokenPoolParam[$name] = trim(filter_input(INPUT_POST, $property['shortname'], FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                    }
                    $this->_metrology->addLog('Extract action create token pool - p' . $property['key'] . ':' . $this->_actionCreateTokenPoolParam[$name], Metrology::LOG_LEVEL_DEBUG); // Log

                    // Extrait si forcé.
                    if (isset($property['forceable'])) {
                        $this->_actionCreateTokenPoolParam['Force' . $name] = filter_has_var(INPUT_POST, 'f' . $property['shortname']);
                        if ($this->_actionCreateTokenPoolParam['Force' . $name]) {
                            $this->_metrology->addLog('Extract action create token pool - f' . $property['shortname'] . ':true', Metrology::LOG_LEVEL_DEBUG); // Log
                        }
                    }
                }
            }
        } else {
//			$this->_actionCreateTokenPoolError = true;
            $this->_actionCreateTokenPoolErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionCreateTokenPool = false;
    protected $_actionCreateTokenPoolID = '';
    protected $_actionCreateTokenPoolInstance = null;
    protected $_actionCreateTokenPoolParam = array();
    protected $_actionCreateTokenPoolError = false;
    protected $_actionCreateTokenPoolErrorMessage = 'Initialisation de la création.';


    /**
     * Renvoie si l'action de création des jetons a été faite.
     *
     * @return boolean
     */
    public function getCreateTokens()
    {
        return $this->_actionCreateTokens;
    }

    /**
     * Revoie les ID des nouveaux jetons.
     *
     * @return array:string
     */
    public function getCreateTokensID()
    {
        return $this->_actionCreateTokensID;
    }

    /**
     * Revoie les instances des nouveaux jetons.
     *
     * @return array:Token
     */
    public function getCreateTokensInstance()
    {
        return $this->_actionCreateTokensInstance;
    }

    /**
     * Revoie les paramètres des nouveaux jetons.
     *
     * @return array
     */
    public function getCreateTokensParam()
    {
        return $this->_actionCreateTokensParam;
    }

    /**
     * Revoie le code erreur de création des nouveaux jetons.
     *
     * @return boolean
     */
    public function getCreateTokensError()
    {
        return $this->_actionCreateTokensError;
    }

    /**
     * Revoie le message d'erreur de création des nouveaux jetons.
     *
     * @return string
     */
    public function getCreateTokensErrorMessage()
    {
        return $this->_actionCreateTokensErrorMessage;
    }

    /**
     * Extrait pour action si des jetons doivent être créés.
     *
     * @return void
     */
    protected function _extractActionCreateTokens()
    {
        // Vérifie que la création de liens et d'objets soit authorisée et que l'action soit demandée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitCurrency')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Extract action create tokens', Metrology::LOG_LEVEL_DEBUG); // Log

            /*
    		 *  ------------------------------------------------------------------------------------------
    		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
    		 *  ------------------------------------------------------------------------------------------
    		 */
            // Lit et nettoye le contenu de la variable GET.
            $argCreate = filter_has_var(INPUT_GET, self::DEFAULT_COMMAND_ACTION_CREATE_TOKENS);

            // Extraction du lien et stockage pour traitement.
            if ($argCreate !== false) {
                $this->_actionCreateTokens = true;
            }
            unset($argCreate);

            // Si on crée un nouveau sac de jetons.
            if ($this->_actionCreateTokens) {
                // Récupère la liste des propriétés.
                $instance = $this->_nebuleInstance->getCurrentTokenInstance();
                $propertiesList = $instance->getPropertiesList();
                unset($instance);

                foreach ($propertiesList['token'] as $name => $property) {
                    // Extrait une valeur.
                    if (isset($property['checkbox'])) {
                        $value = '';
                        $valueArray = filter_input(INPUT_POST, $property['shortname'], FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES | FILTER_FORCE_ARRAY);
                        foreach ($valueArray as $item) {
                            $value .= ' ' . trim($item);
                        }
                        $this->_actionCreateTokensParam[$name] = trim($value);
                        unset($value, $valueArray);
                    } else {
                        $this->_actionCreateTokensParam[$name] = trim(filter_input(INPUT_POST, $property['shortname'], FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES));
                    }
                    $this->_metrology->addLog('Extract action create tokens - t' . $property['key'] . ':' . $this->_actionCreateTokensParam[$name], Metrology::LOG_LEVEL_DEBUG); // Log

                    // Extrait si forcé.
                    if (isset($property['forceable'])) {
                        $this->_actionCreateTokensParam['Force' . $name] = filter_has_var(INPUT_POST, 'f' . $property['shortname']);
                        if ($this->_actionCreateTokensParam['Force' . $name]) {
                            $this->_metrology->addLog('Extract action create tokens - f' . $property['shortname'] . ':true', Metrology::LOG_LEVEL_DEBUG); // Log
                        }
                    }
                }

                // Extrait le nombre de jetons à générer.
                $this->_actionCreateTokensCount = (int)trim(filter_input(INPUT_POST, self::DEFAULT_COMMAND_ACTION_CREATE_TOKENS_COUNT, FILTER_SANITIZE_NUMBER_INT));
            }
        } else {
//			$this->_actionCreateTokensError = true;
            $this->_actionCreateTokensErrorMessage = 'Non autorisé.';
        }
    }

    protected $_actionCreateTokens = false;
    protected $_actionCreateTokensID = array();
    protected $_actionCreateTokensInstance = array();
    protected $_actionCreateTokensParam = array();
    protected $_actionCreateTokensCount = 1;
    protected $_actionCreateTokensError = false;
    protected $_actionCreateTokensErrorMessage = 'Initialisation de la création.';


    /**
     * Signe un lien.
     * @param Link $link
     * @param boolean $obfuscate
     * @return void
     * @todo
     *
     */
    protected function _actionSignLink(Link $link, $obfuscate = 'default')
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitUploadLink')
        ) {
            if ($this->_unlocked) {
                $this->_metrology->addLog('Action sign link', Metrology::LOG_LEVEL_DEBUG); // Log

                // On cache le lien ?
                if ($obfuscate !== false
                    && $obfuscate !== true
                ) {
                    $obfuscate = $this->_nebuleInstance->getOption('defaultObfuscateLinks');
                }
                //...

                // Signature du lien.
                $link->signWrite();
            } elseif ($this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                || $this->_nebuleInstance->getOption('permitPublicUploadLink')
            ) {
                $this->_metrology->addLog('Action sign link', Metrology::LOG_LEVEL_DEBUG); // Log

                // Affichage du lien.
                echo $this->_display->convertInlineIconFace('DEFAULT_ICON_ADDLNK') . $this->_display->convertInlineLinkFace($link);

                // Si signé, écriture du lien.
                if ($link->getSigned()) {
                    $link->write();
                }
            }
            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Ecrit un lien pré-signé.
     *
     * Cette fonction est appelée par la fonction specialActions().
     * Elle est utilisée par l'application upload et le module module_upload de l'application sylabe.
     * Le fonctioneement est identique dans ces deux usages même si l'affichage ne le montre pas.
     *
     * La fonction nécessite au minimum les droits :
     *   - permitWrite
     *   - permitWriteLink
     *   - permitUploadLink
     * L'activation de la fonction est ensuite conditionnée par une conbinaison d'autres droits ou facteurs.
     *
     * Si le droit permitPublicUploadCodeAuthoritiesLink est activé :
     *   les liens signés du maître du code sont acceptés ;
     *   les liens des autres entités sont ignorés avec seulement ce droit.
     *
     * Si le droit permitPublicUploadLink est activé :
     *   tous les liens signés sont acceptés ;
     *   les entités signataires doivent exister localement pour la vérification les signatures.
     *
     * Si l'entité en cours est déverrouillée, this->_unlocked :
     *   la réception de liens est prise comme une action légitime ;
     *   les liens signés de toutes les entités sont acceptés ;
     *   les liens non signés sont signés par l'entité en cours.
     * Si un lien est structurellement valide mais non signé, il est régénéré et signé par l'entité en cours.
     *
     * Les liens ne sont écris que si leurs signatures sont valides.
     *
     * @param Link $link
     * @return void
     */
    protected function _actionUploadLink(Link $link)
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitUploadLink')
            && ($this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                || $this->_nebuleInstance->getOption('permitPublicUploadLink')
                || $this->_unlocked
            )
            && is_a($link, 'Link')
            && $link->getVerified()
            && $link->getValid()
        ) {
            $this->_metrology->addLog('Action upload link', Metrology::LOG_LEVEL_DEBUG); // Log

            if ($link->getSigned()
                && (($link->getHashSigner_disabled() == $this->_nebuleInstance->getCodeAuthority()
                        && $this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                    )
                    || $this->_nebuleInstance->getOption('permitPublicUploadLink')
                    || $this->_unlocked
                )
            ) {
                $link->write();
                $this->_metrology->addLog('Action upload link - signed link ' . $link->getFullLink(), Metrology::LOG_LEVEL_NORMAL); // Log
            } elseif ($this->_unlocked) {
                $link = $this->_nebuleInstance->newLink(
                    '0_'
                    . $this->_nebuleInstance->getCurrentEntity() . '_'
                    . $link->getDate_disabled() . '_'
                    . $link->getAction_disabled() . '_'
                    . $link->getHashSource_disabled() . '_'
                    . $link->getHashTarget_disabled() . '_'
                    . $link->getHashMeta_disabled()
                );
                $link->signWrite();
                $this->_metrology->addLog('Action upload link - unsigned link ' . $link->getFullLink(), Metrology::LOG_LEVEL_NORMAL); // Log
            }

            // Affichage des actions.
            $this->_display->displayInlineLastAction();
        }
    }


    /**
     * Dissimule un lien.
     *
     * @return void
     */
    protected function _actionObfuscateLink()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && ($this->_nebuleInstance->getOption('permitPublicUploadLink')
                || $this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                || ($this->_nebuleInstance->getOption('permitUploadLink')
                    && $this->_unlocked
                )
            )
            && $this->_nebuleInstance->getOption('permitObfuscatedLink')
            && $link->getVerified()
            && $link->getValid()
            && $link->getSigned()
        ) {
            $this->_metrology->addLog('Action obfuscate link', Metrology::LOG_LEVEL_DEBUG); // Log

            // On dissimule le lien.
            $this->_actionObfuscateLinkInstance->obfuscateWrite();

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Supprime un objet.
     */
    protected function _actionDeleteObject()
    {
        // Vérifie que la création de liens et l'écriture d'objets soient authorisés.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action delete object', Metrology::LOG_LEVEL_DEBUG); // Log

            // Suppression de l'objet.
            if ($this->_actionDeleteObjectForce)
                $this->_actionDeleteObjectInstance->deleteForceObject();
            else
                $this->_actionDeleteObjectInstance->deleteObject();

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Protège un objet.
     */
    protected function _actionProtectObject()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action protect object', Metrology::LOG_LEVEL_DEBUG); // Log

            // Demande de protection de l'objet.
            $this->_actionProtectObjectInstance->setProtected();

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Déprotège un objet.
     */
    protected function _actionUnprotectObject()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action unprotect object', Metrology::LOG_LEVEL_DEBUG); // Log

            // Demande de protection de l'objet.
            $this->_actionUnprotectObjectInstance->setUnprotected();

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }

    /**
     * Partage la protection d'un objet pour une entité.
     */
    protected function _actionShareProtectObjectToEntity()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action share protect object to entity ' . $this->_actionShareProtectObjectToEntity, Metrology::LOG_LEVEL_DEBUG); // Log

            // Demande de protection de l'objet.
            $this->_nebuleInstance->getCurrentObjectInstance()->shareProtectionTo($this->_actionShareProtectObjectToEntity);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }

    /**
     * Partage la protection d'un objet pour un groupe ouvert.
     */
    protected function _actionShareProtectObjectToGroupOpened()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action share protect object to opened group', Metrology::LOG_LEVEL_DEBUG); // Log

            // Demande de protection de l'objet.
            $group = $this->_nebuleInstance->newGroup($this->_actionShareProtectObjectToGroupOpened);
            foreach ($group->getListMembersID('myself', null) as $id) {
                $this->_nebuleInstance->getCurrentObjectInstance()->shareProtectionTo($id);
            }
            unset($group, $id);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }

    /**
     * Partage la protection d'un objet pour un groupe fermé.
     */
    protected function _actionShareProtectObjectToGroupClosed()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action share protect object to closed group', Metrology::LOG_LEVEL_DEBUG); // Log

            // Demande de protection de l'objet.
            $group = $this->_nebuleInstance->newGroup($this->_actionShareProtectObjectToGroupClosed);
            foreach ($group->getListMembersID('myself', null) as $id) {
                $this->_nebuleInstance->getCurrentObjectInstance()->shareProtectionTo($id);
            }
            unset($group, $id);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }

    /**
     * Annule le partage de la protection d'un objet pour une entité.
     */
    protected function _actionCancelShareProtectObjectToEntity()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action cancel share protect object to entity', Metrology::LOG_LEVEL_DEBUG); // Log

            // Demande d'annulation de protection de l'objet.
            $this->_nebuleInstance->getCurrentObjectInstance()->cancelShareProtectionTo($this->_actionCancelShareProtectObjectToEntity);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Synchronise l'objet.
     */
    protected function _actionSynchronizeObject()
    {
        // Vérifie que la création d'objet soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitSynchronizeObject')
        ) {
            $this->_metrology->addLog('Action synchronize object', Metrology::LOG_LEVEL_DEBUG); // Log

            echo $this->_display->convertInlineIconFace('DEFAULT_ICON_SYNOBJ') . $this->_display->convertInlineObjectColor($this->_actionSynchronizeObjectInstance);

            // Synchronisation.
            $this->_actionSynchronizeObjectInstance->syncObject();

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Synchronise l'entité.
     */
    protected function _actionSynchronizeEntity()
    {
        // Vérifie que la création d'objet soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitSynchronizeObject')
            && $this->_nebuleInstance->getOption('permitSynchronizeLink')
        ) {
            $this->_metrology->addLog('Action synchronize entity', Metrology::LOG_LEVEL_DEBUG); // Log

            echo $this->_display->convertInlineIconFace('DEFAULT_ICON_SYNENT') . $this->_display->convertInlineObjectColor($this->_actionSynchronizeEntityInstance);

            // Synchronisation des liens (l'objet est forcément présent).
            $this->_actionSynchronizeEntityInstance->syncLinks();

            // Liste des liens l pour l'entité en source.
            $links = $this->_actionSynchronizeEntityInstance->readLinksFilterFull('', '', 'l', $this->_actionSynchronizeEntityInstance->getID(), '', '');
            // Synchronise l'objet cible.
            $object = null;
            foreach ($links as $link) {
                $object = $this->_nebuleInstance->newObject($link->getHashTarget());
                // Synchronise les liens (avant).
                $object->syncLinks();
                // Synchronise l'objet.
                $object->syncObject();
            }
            // Liste des liens l pour l'entité en cible.
            $links = $this->_actionSynchronizeEntityInstance->readLinksFilterFull('', '', 'l', '', $this->_actionSynchronizeEntityInstance->getID(), '');
            // Synchronise l'objet source.
            $object = null;
            foreach ($links as $link) {
                $object = $this->_nebuleInstance->newObject($link->getHashSource());
                // Synchronise les liens (avant).
                $object->syncLinks();
                // Synchronise l'objet.
                $object->syncObject();
            }
            unset($links, $link, $object);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Synchronise les liens de l'objet.
     */
    protected function _actionSynchronizeObjectLinks()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitSynchronizeLink')
        ) {
            $this->_metrology->addLog('Action synchronize object links', Metrology::LOG_LEVEL_DEBUG); // Log

            echo $this->_display->convertInlineIconFace('DEFAULT_ICON_SYNLNK') . $this->_display->convertInlineObjectColor($this->_actionSynchronizeObjectLinksInstance);

            // Synchronisation.
            $this->_actionSynchronizeObjectLinksInstance->syncLinks();

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Synchronise l'application. A revoir complètement ce qui est sync @todo
     */
    protected function _actionSynchronizeApplication()
    {
        // Vérifie que la création d'objet soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitSynchronizeObject')
            && $this->_nebuleInstance->getOption('permitSynchronizeLink')
            && $this->_nebuleInstance->getOption('permitSynchronizeApplication')
            && ($this->_nebuleInstance->getOption('permitPublicSynchronizeApplication')
                || $this->_unlocked()
            )
        ) {
            $this->_metrology->addLog('Action synchronize application', Metrology::LOG_LEVEL_DEBUG); // Log

            echo $this->_display->convertInlineIconFace('DEFAULT_ICON_SYNOBJ') . $this->_display->convertInlineObjectColor($this->_actionSynchronizeApplicationInstance);

            // Synchronisation des liens (l'objet est forcément présent).
            $this->_actionSynchronizeApplicationInstance->syncLinks();

            // Liste des liens l pour l'entité en source.
            $links = $this->_actionSynchronizeApplicationInstance->readLinksFilterFull('', '', 'l', $this->_actionSynchronizeApplicationInstance->getID(), '', '');
            // Synchronise l'objet cible.
            $object = null;
            foreach ($links as $link) {
                $object = $this->_nebuleInstance->newObject($link->getHashTarget());
                // Synchronise les liens (avant).
                $object->syncLinks();
                // Synchronise l'objet.
                $object->syncObject();
            }
            // Liste des liens l pour l'entité en cible.
            $links = $this->_actionSynchronizeApplicationInstance->readLinksFilterFull('', '', 'l', '', $this->_actionSynchronizeApplicationInstance->getID(), '');
            // Synchronise l'objet source.
            $object = null;
            foreach ($links as $link) {
                $object = $this->_nebuleInstance->newObject($link->getHashSource());
                // Synchronise les liens (avant).
                $object->syncLinks();
                // Synchronise l'objet.
                $object->syncObject();
            }
            unset($links, $link, $object);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Synchronise une entité externe depuis une URL.
     */
    protected function _actionSynchronizeNewEntity()
    {
        // Vérifie que la création d'objet soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitSynchronizeObject')
            && $this->_nebuleInstance->getOption('permitSynchronizeLink')
        ) {
            $this->_metrology->addLog('Action synchronize new entity', Metrology::LOG_LEVEL_DEBUG); // Log

            // Vérifie si l'objet est déjà présent.
            $present = $this->_io->checkObjectPresent($this->_actionSynchronizeNewEntityID);
            // Lecture de l'objet.
            $data = $this->_io->objectRead($this->_actionSynchronizeNewEntityID, Entity::ENTITY_MAX_SIZE, $this->_actionSynchronizeNewEntityURL);
            // Calcul de l'empreinte.
            $hash = hash($this->_nebuleInstance->getCrypto()->hashAlgorithmName(), $data);
            if ($hash != $this->_actionSynchronizeNewEntityID) {
                $this->_metrology->addLog('Action synchronize new entity - Hash error', Metrology::LOG_LEVEL_DEBUG); // Log
                unset($data);
                echo $this->_display->convertInlineIconFace('DEFAULT_ICON_SYNENT') .
                    $this->_display->convertInlineObjectColor($this->_actionSynchronizeNewEntityID) .
                    $this->_display->convertInlineIconFace('DEFAULT_ICON_IERR');
                $this->_actionSynchronizeNewEntityID = '';
                $this->_actionSynchronizeNewEntityURL = '';
                return false;
            }
            // Ecriture de l'objet.
            $this->_io->objectWrite($data);

            $this->_actionSynchronizeNewEntityInstance = $this->_nebuleInstance->newEntity($this->_actionSynchronizeNewEntityID);

            if (!$this->_actionSynchronizeNewEntityInstance->getTypeVerify) {
                $this->_metrology->addLog('Action synchronize new entity - Not entity', Metrology::LOG_LEVEL_DEBUG); // Log
                if (!$present)
                    $this->_actionSynchronizeNewEntityInstance->deleteObject();
            }

            echo $this->_display->convertInlineIconFace('DEFAULT_ICON_SYNENT') . $this->_display->convertInlineObjectColor($this->_actionSynchronizeNewEntityInstance);

            // Synchronisation des liens.
            $this->_actionSynchronizeNewEntityInstance->syncLinks();

            // Liste des liens l pour l'entité en source.
            $links = $this->_actionSynchronizeNewEntityInstance->readLinksFilterFull('', '', 'l', $hash, '', '');
            // Synchronise l'objet cible.
            $object = null;
            foreach ($links as $link) {
                $object = $this->_nebuleInstance->newObject($link->getHashTarget());
                // Synchronise les liens (avant).
                $object->syncLinks();
                // Synchronise l'objet.
                $object->syncObject();
            }
            // Liste des liens l pour l'entité en cible.
            $links = $this->_actionSynchronizeNewEntityInstance->readLinksFilterFull('', '', 'l', '', $hash, '');
            // Synchronise l'objet source.
            $object = null;
            foreach ($links as $link) {
                $object = $this->_nebuleInstance->newObject($link->getHashSource());
                // Synchronise les liens (avant).
                $object->syncLinks();
                // Synchronise l'objet.
                $object->syncObject();
            }
            unset($links, $link, $object);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Marque un objet.
     */
    protected function _actionMarkObject()
    {
        $this->_metrology->addLog('Action mark object', Metrology::LOG_LEVEL_DEBUG); // Log

        $this->_applicationInstance->setMarkObject($this->_actionMarkObject);

        // Affichage des actions.
        $this->_display->displayInlineAllActions();
    }


    /**
     * Supprime la marque d'un objet.
     */
    protected function _actionUnmarkObject()
    {
        $this->_metrology->addLog('Action unmark object', Metrology::LOG_LEVEL_DEBUG); // Log

        $this->_applicationInstance->setUnmarkObject($this->_actionUnmarkObject);

        // Affichage des actions.
        $this->_display->displayInlineAllActions();
    }


    /**
     * Supprime les marques de tous les objets.
     */
    protected function _actionUnmarkAllObjects()
    {
        $this->_metrology->addLog('Action unmark all objects', Metrology::LOG_LEVEL_DEBUG); // Log

        $this->_applicationInstance->setUnmarkAllObjects();

        // Affichage des actions.
        $this->_display->displayInlineAllActions();
    }


    /**
     * Transfert un fichier et le nebulise.
     *
     * @return void
     */
    protected function _actionUploadFile()
    {
        // Vérifie que la création d'objet soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action upload file', Metrology::LOG_LEVEL_DEBUG); // Log

            // Lit le contenu du fichier.
            $data = file_get_contents($_FILES[self::DEFAULT_COMMAND_ACTION_UPLOAD_FILE]['tmp_name']);

            // Ecrit le contenu dans l'objet.
            $instance = new Node($this->_nebuleInstance, '0', $data, $this->_actionUploadFileProtect);
            if ($instance === false) {
                $this->_metrology->addLog('Action _actionUploadFile cant create object instance', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionUploadFileError = true;
                $this->_actionUploadFileErrorMessage = "L'instance de l'objet n'a pas pu être créée.";
                return false;
            }

            // Lit l'ID.
            $id = $instance->getID();
            unset($data);
            if ($id == '0') {
                $this->_metrology->addLog('Action _actionUploadFile cant create object', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionUploadFileError = true;
                $this->_actionUploadFileErrorMessage = "L'objet n'a pas pu être créé.";
                return false;
            }
            $this->_actionUploadFileID = $id;

            // Définition de la date et le signataire.
            $date = date(DATE_ATOM);
            $signer = $this->_nebuleInstance->getCurrentEntity();

            // Création du type mime.
            $instance->setType($this->_actionUploadFileType);

            // Crée l'objet du nom.
            $instance->setName($this->_actionUploadFileName);

            // Crée l'objet de l'extension.
            $instance->setSuffix($this->_actionUploadFileExtension);

            // Si mise à jour de l'objet en cours.
            if ($this->_actionUploadFileUpdate) {
                // Crée le lien.
                $action = 'u';
                $source = $this->_applicationInstance->getCurrentObject();
                $target = $id;
                $meta = '0';
                $this->_createLink($signer, $date, $action, $source, $target, $meta, $this->_actionUploadFileObfuscateLinks);
            }

            unset($date, $signer, $source, $target, $meta, $link, $newLink, $textID, $instance);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Transfert un texte et le nebulise.
     */
    protected function _actionUploadText()
    {
        // Vérifie que la création d'objet soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action upload text', Metrology::LOG_LEVEL_DEBUG); // Log

            // Crée l'instance de l'objet.
            $instance = new Node($this->_nebuleInstance, '0', $this->_actionUploadTextContent, $this->_actionUploadTextProtect);
            if ($instance === false) {
                $this->_metrology->addLog('Action _actionUploadText cant create object instance', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionUploadFileError = true;
                $this->_actionUploadFileErrorMessage = "L'instance de l'objet n'a pas pu être créée.";
                return false;
            }

            // Lit l'ID.
            $id = $instance->getID();
            if ($id == '0') {
                $this->_metrology->addLog('Action _actionUploadText cant create object', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionUploadFileError = true;
                $this->_actionUploadFileErrorMessage = "L'objet n'a pas pu être créé.";
                return false;
            }
            $this->_actionUploadTextID = $id;

            // Affichage des actions.
            $this->_display->displayInlineAllActions();

            // Définition de la date et du signataire.
            //$signer	= $this->_nebuleInstance->getCurrentEntity();
            //$date = date(DATE_ATOM);

            // Création du type mime.
            $instance->setType($this->_actionUploadTextType);

            // Crée l'objet du nom.
            $instance->setName($this->_actionUploadTextName);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();

            unset($id, $instance);
        }
    }


    /**
     * Transfert un fichier de liens pré-signés et les ajoute.
     *
     * Cette fonction est appelée par la fonction specialActions().
     * Elle est utilisée par l'application upload et le module module_upload de l'application sylabe.
     * Le fonctioneement est identique dans ces deux usages même si l'affichage ne le montre pas.
     *
     * La fonction nécessite au minimum les droits :
     *   - permitWrite
     *   - permitWriteLink
     *   - permitUploadLink
     * L'activation de la fonction est ensuite conditionnée par une conbinaison d'autres droits ou facteurs.
     *
     * Si le droit permitPublicUploadCodeAuthoritiesLink est activé :
     *   les liens signés du maître du code sont acceptés ;
     *   les liens des autres entités sont ignorés avec seulement ce droit.
     *
     * Si le droit permitPublicUploadLink est activé :
     *   tous les liens signés sont acceptés ;
     *   les entités signataires doivent exister localement pour la vérification les signatures.
     *
     * Si l'entité en cours est déverrouillée, this->_unlocked :
     *   la réception de liens est prise comme une action légitime ;
     *   les liens signés de toutes les entités sont acceptés ;
     *   les liens non signés sont signés par l'entité en cours.
     * Si un lien est structurellement valide mais non signé, il est régénéré et signé par l'entité en cours.
     *
     * Les liens ne sont écris que si leurs signatures sont valides.
     *
     * @return void
     */
    protected function _actionUploadFileLinks()
    {
        // Vérifie que la création d'objet soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitUploadLink')
            && ($this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                || $this->_nebuleInstance->getOption('permitPublicUploadLink')
                || $this->_unlocked
            )
        ) {
            $this->_metrology->addLog('Action upload file signed links', Metrology::LOG_LEVEL_DEBUG); // Log

            // Ecrit les liens correctement signés.
            $updata = file($this->_actionUploadFileLinksPath);
            $nbLinks = 0;
            $nbLines = 0;
            foreach ($updata as $line) {
                if (substr($line, 0, 21) != 'nebule/liens/version/') {
                    $nbLines++;
                    $instance = $this->_nebuleInstance->newLink($line);
                    if ($instance->getVerified()
                        && $instance->getValid()
                    ) {
                        if ($instance->getSigned()
                            && (($instance->getHashSigner_disabled() == $this->_nebuleInstance->getCodeAuthority()
                                    && $this->_nebuleInstance->getOption('permitPublicUploadCodeAuthoritiesLink')
                                )
                                || $this->_nebuleInstance->getOption('permitPublicUploadLink')
                                || $this->_unlocked
                            )
                        ) {
                            $instance->write();
                            $nbLinks++;
                            $this->_metrology->addLog('Action upload file links - signed link ' . $instance->getFullLink(), Metrology::LOG_LEVEL_NORMAL); // Log
                        } elseif ($this->_unlocked) {
                            $instance = $this->_nebuleInstance->newLink(
                                '0_'
                                . $this->_nebuleInstance->getCurrentEntity() . '_'
                                . $instance->getDate_disabled() . '_'
                                . $instance->getAction_disabled() . '_'
                                . $instance->getHashSource_disabled() . '_'
                                . $instance->getHashTarget_disabled() . '_'
                                . $instance->getHashMeta_disabled()
                            );
                            $instance->signWrite();
                            $nbLinks++;
                            $this->_metrology->addLog('Action upload file links - unsigned link ' . $instance->getFullLink(), Metrology::LOG_LEVEL_NORMAL); // Log
                        }
                    }
                }
            }

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
            echo "\n<br />\nRead=$nbLines Valid=$nbLinks\n";
        }
    }


    /**
     * Crée une nouvelle entité.
     *
     * @return void
     */
    protected function _actionCreateEntity()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteEntity')
            && ($this->_unlocked
                || $this->_nebuleInstance->getOption('permitPublicCreateEntity')
            )
            && $this->_actionCreateEntity
            && !$this->_actionCreateEntityError
        ) {
            $this->_metrology->addLog('Action create entity', Metrology::LOG_LEVEL_DEBUG); // Log

            // Création de la nouvelle entité nebule.
            $instance = new Entity($this->_nebuleInstance, 'new');

            // Affichage des actions.
            $this->_display->displayInlineAllActions();

            if (is_a($instance, 'Entity') && $instance->getID() != '0') {
                $this->_actionCreateEntityError = false;

                // Enregistre l'instance créée.
                $this->_actionCreateEntityInstance = $instance;
                $this->_actionCreateEntityID = $instance->getID();
                unset($instance);

                // Modifie le mot de passe de clé privée.
                $this->_actionCreateEntityInstance->changePrivateKeyPassword($this->_actionCreateEntityPassword);

                // Affichage des actions.
                $this->_display->displayInlineAllActions();

                // Bascule temporairement sur la nouvelle entité.
                $this->_nebuleInstance->setTempCurrentEntity($this->_actionCreateEntityInstance);
                $this->_nebuleInstance->getCurrentEntityInstance()->setPrivateKeyPassword($this->_actionCreateEntityPassword);

                // Définition de la date et du signataire.
                $date = date(DATE_ATOM);
                $signer = $this->_actionCreateEntityID;

                // Si prénom et pas de nom, le prénom devient le nom.
                if ($this->_actionCreateEntityName == '' && $this->_actionCreateEntityFirstname != '') {
                    $this->_actionCreateEntityName = $this->_actionCreateEntityFirstname;
                    $this->_actionCreateEntityFirstname = '';
                }

                // Nomme l'entité.
                if ($this->_actionCreateEntityName != '') {
                    // Crée l'objet avec le texte.
                    $textID = $this->_nebuleInstance->createTextAsObject($this->_actionCreateEntityName); // Est fait avec l'entité courante, pas la nouvelle !!!
                    if ($textID !== false) {
                        // Crée le lien.
                        $action = 'l';
                        $source = $this->_actionCreateEntityID;
                        $target = $textID;
                        $meta = $this->_nebuleInstance->getCrypto()->hash('nebule/objet/nom');
                        $this->_createLink($signer, $date, $action, $source, $target, $meta, $this->_actionCreateEntityObfuscateLinks);
                    }
                }
                if ($this->_actionCreateEntityFirstname != '') {
                    // Crée l'objet avec le texte.
                    $textID = $this->_nebuleInstance->createTextAsObject($this->_actionCreateEntityFirstname);
                    if ($textID !== false) {
                        // Crée le lien.
                        $action = 'l';
                        $source = $this->_actionCreateEntityID;
                        $target = $textID;
                        $meta = $this->_nebuleInstance->getCrypto()->hash('nebule/objet/prenom');
                        $this->_createLink($signer, $date, $action, $source, $target, $meta, $this->_actionCreateEntityObfuscateLinks);
                    }
                }
                if ($this->_actionCreateEntityNikename != '') {
                    // Crée l'objet avec le texte.
                    $textID = $this->_nebuleInstance->createTextAsObject($this->_actionCreateEntityNikename);
                    if ($textID !== false) {
                        // Crée le lien.
                        $action = 'l';
                        $source = $this->_actionCreateEntityID;
                        $target = $textID;
                        $meta = $this->_nebuleInstance->getCrypto()->hash('nebule/objet/surnom');
                        $this->_createLink($signer, $date, $action, $source, $target, $meta, $this->_actionCreateEntityObfuscateLinks);
                    }
                }

                // Affichage des actions.
                $this->_display->displayInlineAllActions();

                if ($this->_actionCreateEntityPrefix != '') {
                    // Crée l'objet avec le texte.
                    $textID = $this->_nebuleInstance->createTextAsObject($this->_actionCreateEntityPrefix);
                    if ($textID !== false) {
                        // Crée le lien.
                        $action = 'l';
                        $source = $this->_actionCreateEntityID;
                        $target = $textID;
                        $meta = $this->_nebuleInstance->getCrypto()->hash('nebule/objet/prefix');
                        $this->_createLink($signer, $date, $action, $source, $target, $meta, $this->_actionCreateEntityObfuscateLinks);
                    }
                }
                if ($this->_actionCreateEntitySuffix != '') {
                    // Crée l'objet avec le texte.
                    $textID = $this->_nebuleInstance->createTextAsObject($this->_actionCreateEntitySuffix);
                    if ($textID !== false) {
                        // Crée le lien.
                        $action = 'l';
                        $source = $this->_actionCreateEntityID;
                        $target = $textID;
                        $meta = $this->_nebuleInstance->getCrypto()->hash('nebule/objet/suffix');
                        $this->_createLink($signer, $date, $action, $source, $target, $meta, $this->_actionCreateEntityObfuscateLinks);
                    }
                }
                if ($this->_actionCreateEntityType != '') {
                    // Crée l'objet avec le texte.
                    $textID = $this->_nebuleInstance->createTextAsObject($this->_actionCreateEntityType);
                    if ($textID !== false) {
                        // Crée le lien.
                        $action = 'l';
                        $source = $this->_actionCreateEntityID;
                        $target = $textID;
                        $meta = $this->_nebuleInstance->getCrypto()->hash('nebule/objet/entite/type');
                        $this->_createLink($signer, $date, $action, $source, $target, $meta, $this->_actionCreateEntityObfuscateLinks);
                    }
                }

                unset($date, $source, $target, $meta, $link, $newLink, $textID);

                // Restaure l'entité d'origine.
                $this->_nebuleInstance->unsetTempCurrentEntity();

                // Efface le cache pour recharger l'entité.
                $this->_nebuleInstance->unsetEntityCache($this->_actionCreateEntityID);

                // Recrée l'instance de l'objet.
                $this->_actionCreateEntityInstance = $this->_nebuleInstance->newEntity($this->_actionCreateEntityID);
            } else {
                // Si ce n'est pas bon.
                $this->_applicationInstance->getDisplayInstance()->displayInlineErrorFace();
                $this->_metrology->addLog('Action _actionCreateEntity cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionCreateEntityError = true;
                $this->_actionCreateEntityErrorMessage = 'Echec de la génération.';
            }

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionCreateEntity not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateEntityError = true;
            $this->_actionCreateEntityErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Crée un nouveau groupe.
     */
    protected function _actionCreateGroup()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
            && !$this->_actionCreateGroupError
        ) {
            $this->_metrology->addLog('Action create group', Metrology::LOG_LEVEL_DEBUG); // Log

            // Création du nouveau groupe.
            $instance = new Group($this->_nebuleInstance, 'new', $this->_actionCreateGroupClosed);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();

            if (is_a($instance, 'Group') && $instance->getID() != '0') {
                $this->_actionCreateGroupError = false;
                $instance->setName($this->_actionCreateGroupName);

                $this->_actionCreateGroupInstance = $instance;
                $this->_actionCreateGroupID = $instance->getID();
            } else {
                // Si ce n'est pas bon.
                $this->_applicationInstance->getDisplayInstance()->displayInlineErrorFace();
                $this->_metrology->addLog('Action _actionCreateGroup cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionCreateGroupError = true;
                $this->_actionCreateGroupErrorMessage = 'Echec de la génération.';
            }

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionCreateGroup not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateGroupError = true;
            $this->_actionCreateGroupErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Supprime un groupe.
     */
    protected function _actionDeleteGroup()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
            && !$this->_actionDeleteGroupError
        ) {
            $this->_metrology->addLog('Action delete group ' . $this->_actionDeleteGroupID, Metrology::LOG_LEVEL_DEBUG); // Log

            /**
             * Instance du groupe.
             * @var Group $instance
             */
            $instance = $this->_nebuleInstance->newGroup($this->_actionDeleteGroupID);

            // Vérification.
            if ($instance->getID() == '0'
                || !$instance->getIsGroup('all')
            ) {
                $this->_actionDeleteGroupError = false;
                $this->_actionDeleteGroupErrorMessage = 'Pas un groupe.';
                $this->_metrology->addLog('Action delete not a group', Metrology::LOG_LEVEL_DEBUG); // Log
                return;
            }

            // Suppression.
            if ($instance->getMarkClosed()) {
                $this->_metrology->addLog('Action delete group closed', Metrology::LOG_LEVEL_DEBUG); // Log
                $instance->unsetMarkClosed();
            }
            $instance->unsetGroup();

            // Vérification.
            if ($instance->getIsGroup('myself')) {
                // Si ce n'est pas bon.
                $this->_metrology->addLog('Action _actionDeleteGroup cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionDeleteGroupError = true;
                $this->_actionDeleteGroupErrorMessage = 'Echec de la génération.';
            }
            unset($instance);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionDeleteGroup not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionDeleteGroupError = true;
            $this->_actionDeleteGroupErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Ajoute l'objet courant à un groupe.
     *
     * @return void
     */
    protected function _actionAddToGroup()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action add to group ' . $this->_actionAddToGroup, Metrology::LOG_LEVEL_DEBUG); // Log
            $instanceGroupe = $this->_nebuleInstance->newGroup($this->_actionAddToGroup);
            $instanceGroupe->setMember($this->_nebuleInstance->getCurrentObjectInstance());
            unset($instanceGroupe);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Retire l'objet courant d'un groupe.
     *
     * @return void
     */
    protected function _actionRemoveFromGroup()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action remove from group ' . $this->_actionRemoveFromGroup, Metrology::LOG_LEVEL_DEBUG); // Log
            $instanceGroupe = $this->_nebuleInstance->newGroup($this->_actionRemoveFromGroup);
            $instanceGroupe->unsetMember($this->_nebuleInstance->getCurrentObjectInstance());
            unset($instanceGroupe);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Ajoute un objet au groupe courant.
     */
    protected function _actionAddItemToGroup()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action add item to group ' . $this->_actionAddItemToGroup, Metrology::LOG_LEVEL_DEBUG); // Log
            $this->_nebuleInstance->getCurrentGroupInstance()->setMember($this->_actionAddItemToGroup);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Retire un objet courant du groupe courant.
     */
    protected function _actionRemoveItemFromGroup()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteGroup')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action remove item from group ' . $this->_actionRemoveItemFromGroup, Metrology::LOG_LEVEL_DEBUG); // Log
            $this->_nebuleInstance->getCurrentGroupInstance()->unsetMember($this->_actionRemoveItemFromGroup);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Crée une nouvelle conversation.
     */
    protected function _actionCreateConversation()
    {
        // Vérifie que la création de conversation soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
            && !$this->_actionCreateConversationError
        ) {
            $this->_metrology->addLog('Action create conversation', Metrology::LOG_LEVEL_DEBUG); // Log

            // Création de la nouvelle conversation.
            $instance = new Conversation(
                $this->_nebuleInstance,
                'new',
                $this->_actionCreateConversationClosed,
                $this->_actionCreateConversationProtected,
                $this->_actionCreateConversationObfuscateLinks);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();

            if (is_a($instance, 'Conversation')
                && $instance->getID() != '0'
            ) {
                $this->_actionCreateConversationError = false;
                $instance->setName($this->_actionCreateConversationName);

                $this->_actionCreateConversationInstance = $instance;
                $this->_actionCreateConversationID = $instance->getID();
            } else {
                // Si ce n'est pas bon.
                $this->_applicationInstance->getDisplayInstance()->displayInlineErrorFace();
                $this->_metrology->addLog('Action _actionCreateConversation cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionCreateConversationError = true;
                $this->_actionCreateConversationErrorMessage = 'Echec de la génération.';
            }

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionCreateConversation not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateConversationError = true;
            $this->_actionCreateConversationErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Supprime un conversation.
     *
     * On fait d'abort la suppression de la conversation fermée puis si rappelé on fait la suppression de la conversation ouvert.
     * On ne fait pas les deux en même temps.
     */
    protected function _actionDeleteConversation()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
            && !$this->_actionDeleteConversationError
        ) {
            $this->_metrology->addLog('Action delete conversation ' . $this->_actionDeleteConversationID, Metrology::LOG_LEVEL_DEBUG); // Log

            // Suppression.
            $instance = $this->_nebuleInstance->newConversation($this->_actionDeleteConversationID);
            if (!is_a($instance, 'Conversation')
                || $instance->getID() == '0'
                || !$instance->getIsConversation('myself')
            ) {
                $this->_actionDeleteConversationError = false;
                $this->_actionDeleteConversationErrorMessage = 'Pas un conversation.';
                $this->_metrology->addLog('Action delete not a group', Metrology::LOG_LEVEL_DEBUG); // Log
                return;
            }
            if ($instance->getIsConversationClosed()) {
                $this->_metrology->addLog('Action delete conversation closed', Metrology::LOG_LEVEL_DEBUG); // Log
                $instance->setUnmarkConversationClosed();
                $test = $instance->getIsConversationClosed();
            } else {
                $this->_metrology->addLog('Action delete conversation', Metrology::LOG_LEVEL_DEBUG); // Log
                $instance->setUnmarkConversationOpened();
                $test = $instance->getIsConversationOpened();
            }

            // Vérification.
            if ($test) {
                // Si ce n'est pas bon.
                $this->_metrology->addLog('Action _actionDeleteConversation cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionDeleteConversationError = true;
                $this->_actionDeleteConversationErrorMessage = 'Echec de la génération.';
            }
            unset($instance, $test);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionDeleteConversation not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionDeleteConversationError = true;
            $this->_actionDeleteConversationErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Ajoute l'objet courant à un conversation.
     */
    protected function _actionAddMessageOnConversation()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action add message to conversation ' . $this->_actionAddMessageOnConversation, Metrology::LOG_LEVEL_DEBUG); // Log

            $instanceConversation = $this->_nebuleInstance->newConversation($this->_actionAddMessageOnConversation);
            $instanceConversation->setMember($this->_nebuleInstance->getCurrentObject(), false);
            unset($instanceConversation);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Retire l'objet courant d'un conversation.
     */
    protected function _actionRemoveMessageOnConversation()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action remove message to conversation ' . $this->_actionRemoveMessageOnConversation, Metrology::LOG_LEVEL_DEBUG); // Log

            $instanceConversation = $this->_nebuleInstance->newConversation($this->_actionRemoveMessageOnConversation);
            $instanceConversation->unsetMember($this->_nebuleInstance->getCurrentObject());
            unset($instanceConversation);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Ajoute une entité à la conversation courante.
     */
    protected function _actionAddMemberOnConversation()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action add member to conversation ' . $this->_actionAddMemberOnConversation, Metrology::LOG_LEVEL_DEBUG); // Log

            $instanceConversation = $this->_nebuleInstance->newConversation($this->_actionAddMemberOnConversation);
            $instanceConversation->setFollower($this->_nebuleInstance->getCurrentObject());
            unset($instanceConversation);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Retire une entité de la conversation courante.
     */
    protected function _actionRemoveMemberOnConversation()
    {
        // Vérifie que la création de liens soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
        ) {
            $this->_metrology->addLog('Action remove member to conversation ' . $this->_actionRemoveMemberOnConversation, Metrology::LOG_LEVEL_DEBUG); // Log

            $instanceConversation = $this->_nebuleInstance->newConversation($this->_actionRemoveMemberOnConversation);
            $instanceConversation->unsetFollower($this->_nebuleInstance->getCurrentObject());
            unset($instanceConversation);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        }
    }


    /**
     * Crée un nouveau message.
     * Se fait à partir d'un texte précédemment chargé via les fonctions uploadText.
     */
    protected function _actionCreateMessage()
    {
        // Vérifie que la création de message soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteConversation')
            && $this->_unlocked
            && !$this->_actionCreateMessageError
            && !$this->_actionUploadTextError
        ) {
            $id = $this->_actionUploadTextID;
            $this->_metrology->addLog('Action create message ' . $id, Metrology::LOG_LEVEL_DEBUG); // Log
            if ($this->_actionCreateMessageProtected) {
                $this->_metrology->addLog('Action create message protected', Metrology::LOG_LEVEL_DEBUG); // Log
            }
            if ($this->_actionCreateMessageObfuscateLinks) {
                $this->_metrology->addLog('Action create message with obfuscated links', Metrology::LOG_LEVEL_DEBUG); // Log
            }

            // Création de l'instance du message.
            $instanceMessage = $this->_nebuleInstance->newObject($id, $this->_actionCreateMessageProtected, $this->_actionCreateMessageObfuscateLinks);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();

            if (is_a($instanceMessage, 'Node')
                && $instanceMessage->getID() != '0'
            ) {
                $this->_actionCreateConversationError = false;

                $instanceConversation = $this->_nebuleInstance->getCurrentConversationInstance();
                $instanceConversation->setMember($id, $this->_actionCreateMessageObfuscateLinks);

                unset($instanceConversation);

                $this->_actionCreateMessageID = $id;
            } else {
                // Si ce n'est pas bon.
                $this->_applicationInstance->getDisplayInstance()->displayInlineErrorFace();
                $this->_metrology->addLog('Action _actionCreateMessage cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionCreateMessageError = true;
                $this->_actionCreateMessageErrorMessage = 'Echec de la génération.';
            }

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionCreateMessage not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateMessageError = true;
            $this->_actionCreateMessageErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Crée une nouvelle propriété pour un objet.
     */
    protected function _actionAddProperty()
    {
        // Vérifie que la création d'objet soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_unlocked
            && !$this->_actionAddPropertyError
        ) {
            $prop = $this->_actionAddProperty;
            $propID = $this->_nebuleInstance->getCrypto()->hash($prop);
            $this->_metrology->addLog('Action add property ' . $prop, Metrology::LOG_LEVEL_DEBUG); // Log
            $objectID = $this->_actionAddPropertyObject;
            $this->_metrology->addLog('Action add property for ' . $objectID, Metrology::LOG_LEVEL_DEBUG); // Log
            $value = $this->_actionAddPropertyValue;
            $valueID = $this->_nebuleInstance->getCrypto()->hash($value);
            $this->_metrology->addLog('Action add property value : ' . $value, Metrology::LOG_LEVEL_DEBUG); // Log
            $protected = $this->_actionAddPropertyProtected;
            if ($protected) {
                $this->_metrology->addLog('Action add property protected', Metrology::LOG_LEVEL_DEBUG); // Log
            }
            if ($this->_actionAddPropertyObfuscateLinks) {
                $this->_metrology->addLog('Action add property with obfuscated links', Metrology::LOG_LEVEL_DEBUG); // Log
            }

            // Création des objets si besoin.
            if (!$this->_nebuleInstance->getIO()->checkObjectPresent($propID)) {
                $this->_nebuleInstance->createTextAsObject($prop);
            }
            if (!$this->_nebuleInstance->getIO()->checkObjectPresent($valueID)) {
                $this->_nebuleInstance->createTextAsObject($value, $protected, $this->_actionAddPropertyObfuscateLinks);
            }

            // Création du lien.
            $date = date(DATE_ATOM);
            $signer = $this->_nebuleInstance->getCurrentEntity();
            $action = 'l';
            $source = $objectID;
            $target = $valueID;
            $meta = $propID;
            $this->_createLink($signer, $date, $action, $source, $target, $meta, $this->_actionAddPropertyObfuscateLinks);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionAddProperty not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionAddPropertyError = true;
            $this->_actionAddPropertyErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Crée une nouvelle monnaie.
     */
    protected function _actionCreateCurrency()
    {
        // Vérifie que la création de monnaie soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_unlocked
            && !$this->_actionCreateCurrencyError
        ) {
            $this->_metrology->addLog('Action create currency', Metrology::LOG_LEVEL_DEBUG); // Log

            // Création de la nouvelle monnaie.
            $instance = new Currency($this->_nebuleInstance, 'new', $this->_actionCreateCurrencyParam, false, false);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();

            if (is_a($instance, 'Currency')
                && $instance->getID() != '0'
            ) {
                $this->_actionCreateCurrencyError = false;

                $this->_actionCreateCurrencyInstance = $instance;
                $this->_actionCreateCurrencyID = $instance->getID();

                $this->_metrology->addLog('Action _actionCreateCurrency generated ID=' . $instance->getID(), Metrology::LOG_LEVEL_DEBUG); // Log
            } else {
                // Si ce n'est pas bon.
                $this->_applicationInstance->getDisplayInstance()->displayInlineErrorFace();
                $this->_metrology->addLog('Action _actionCreateCurrency cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionCreateCurrencyError = true;
                $this->_actionCreateCurrencyErrorMessage = 'Echec de la génération.';
            }

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionCreateCurrency not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateCurrencyError = true;
            $this->_actionCreateCurrencyErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Crée un nouveau sac de jetons.
     */
    protected function _actionCreateTokenPool()
    {
        // Vérifie que la création de sac de jetons soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_unlocked
            && !$this->_actionCreateTokenPoolError
        ) {
            $this->_metrology->addLog('Action create token pool', Metrology::LOG_LEVEL_DEBUG); // Log

            // Création du nouveau sac de jetons.
            $instance = new TokenPool($this->_nebuleInstance, 'new', $this->_actionCreateTokenPoolParam, false, false);

            // Affichage des actions.
            $this->_display->displayInlineAllActions();

            if (is_a($instance, 'TokenPool')
                && $instance->getID() != '0'
            ) {
                $this->_actionCreateTokenPoolError = false;

                $this->_actionCreateTokenPoolInstance = $instance;
                $this->_actionCreateTokenPoolID = $instance->getID();

                $this->_metrology->addLog('Action _actionCreateTokenPool generated ID=' . $instance->getID(), Metrology::LOG_LEVEL_DEBUG); // Log
            } else {
                // Si ce n'est pas bon.
                $this->_applicationInstance->getDisplayInstance()->displayInlineErrorFace();
                $this->_metrology->addLog('Action _actionCreateTokenPool cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                $this->_actionCreateTokenPoolError = true;
                $this->_actionCreateTokenPoolErrorMessage = 'Echec de la génération.';
            }

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionCreateTokenPool not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateTokenPoolError = true;
            $this->_actionCreateTokenPoolErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Crée un nouveau sac de jetons.
     */
    protected function _actionCreateTokens()
    {
        // Vérifie que la création de sac de jetons soit authorisée.
        if ($this->_nebuleInstance->getOption('permitWrite')
            && $this->_nebuleInstance->getOption('permitWriteObject')
            && $this->_nebuleInstance->getOption('permitWriteLink')
            && $this->_nebuleInstance->getOption('permitWriteCurrency')
            && $this->_nebuleInstance->getOption('permitCreateCurrency')
            && $this->_unlocked
            && !$this->_actionCreateTokensError
            && $this->_actionCreateTokensCount > 0
        ) {
            $this->_metrology->addLog('Action create tokens', Metrology::LOG_LEVEL_DEBUG); // Log

            $instance = $this->_nebuleInstance->getCurrentTokenInstance();
            for ($i = 0; $i < $this->_actionCreateTokensCount; $i++) {
                // Si pas le premier jeton, supprime le SID demandé de façon à ce qu'il soit généré aléatoirement.
                if ($i > 0) {
                    $this->_actionCreateTokensParam['TokenSerialID'] = '';
                }

                // Création du nouveau sac de jetons.
                $instance = new Token($this->_nebuleInstance, 'new', $this->_actionCreateTokensParam, false, false);

                if (is_a($instance, 'Token')
                    && $instance->getID() != '0'
                ) {
                    $this->_actionCreateTokensError = false;

                    $this->_actionCreateTokensInstance[$i] = $instance;
                    $this->_actionCreateTokensID[$i] = $instance->getID();

                    $this->_metrology->addLog('Action _actionCreateTokens generated ID=' . $instance->getID(), Metrology::LOG_LEVEL_DEBUG); // Log
                } else {
                    // Si ce n'est pas bon.
                    $this->_applicationInstance->getDisplayInstance()->displayInlineErrorFace();
                    $this->_metrology->addLog('Action _actionCreateTokens cant generate', Metrology::LOG_LEVEL_ERROR); // Log
                    $this->_actionCreateTokensError = true;
                    $this->_actionCreateTokensErrorMessage = 'Echec de la génération.';

                    // Quitte le processus de génération.
                    break;
                }
            }

            // Affichage des actions.
            $this->_display->displayInlineAllActions();
        } else {
            $this->_metrology->addLog('Action _actionCreateTokens not autorized', Metrology::LOG_LEVEL_ERROR); // Log
            $this->_actionCreateTokensError = true;
            $this->_actionCreateTokensErrorMessage = 'Non autorisé.';
        }
    }


    /**
     * Crée un lien.
     *
     * @return boolean
     */
    protected function _createLink($signer, $date, $action, $source, $target, $meta, $obfuscate = false)
    {
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);

        // Signe le lien.
        $newLink->sign($signer);

        // Si besoin, obfuscation du lien.
        if ($obfuscate
            && $this->_nebuleInstance->getOption('permitObfuscatedLink')
        ) {
            $newLink->obfuscate();
        }

        // Ecrit le lien.
        return $newLink->write();
    }
}


/**
 * Classe de référence des applications.
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
abstract class Applications
{
    const APPLICATION_NAME = 'undef';
    const APPLICATION_SURNAME = 'undef';
    const APPLICATION_AUTHOR = 'undef';
    const APPLICATION_VERSION = 'undef';
    const APPLICATION_LICENCE = 'undef';
    const APPLICATION_WEBSITE = 'undef';

    /* ---------- ---------- ---------- ---------- ----------
	 * Variables.
	 *
	 * Les valeurs par défaut sont indicatives. Ne pas les replacer.
	 * Les variables sont systématiquement recalculées.
	 */
    /**
     * Instance en cours (application).
     *
     * @var Applications
     */
    protected $_applicationInstance;

    /**
     * Instance de la librairie en cours.
     *
     * @var nebule
     */
    protected $_nebuleInstance;

    /**
     * Instance de la métrologie.
     *
     * @var Metrology
     */
    protected $_metrologyInstance;

    /**
     * Instance de l'affichage de l'application.
     *
     * @var Displays
     */
    protected $_displayInstance;

    /**
     * Instance des actions de l'application.
     *
     * @var Actions
     */
    protected $_actionInstance;

    /**
     * Instance de traduction linguistique de l'application.
     *
     * @var Traduction
     */
    protected $_traductionInstance;

    /**
     * Paramètre d'activation de la gestion des modules dans l'application et la traduction.
     *
     * Par défault les applications n'utilisent pas les modules.
     *
     * @var boolean
     */
    protected $_useModules = false;


    /**
     * Constructeur.
     *
     * @param nebule $nebuleInstance
     * @return void
     */
    public function __construct(nebule $nebuleInstance)
    {
        $this->_nebuleInstance = $nebuleInstance;
    }

    /**
     * Initialisation des variables et instances.
     *
     * @return void
     */
    public function initialisation()
    {
        global $applicationTraductionInstance, $applicationDisplayInstance, $applicationActionInstance;

        // S'auto-référence pour être capable de se transmettre aux objets.
        $this->_applicationInstance = $this;

        // Charge l'instance de métrology et de journalisation.
        $this->_metrologyInstance = $this->_nebuleInstance->getMetrologyInstance();

        // Retrouve tout le nécessaire au fonctionnement de l'application sauf les instances.
        $this->_findEnvironment();

        // Si c'est le téléchargement d'un objet ou de ses liens, on ne fait pas le chargement de l'affichage.
        if ($this->_findAskDownload()) {
            return;
        }

        // Récupère les instances.
        $this->_traductionInstance = $applicationTraductionInstance;
        $this->_displayInstance = $applicationDisplayInstance;
        $this->_actionInstance = $applicationActionInstance;

        // Charge les modules au besoin. Avant les initialisations.
        $this->_loadModules();
    }

    /**
     * Initialisation des variables et instances.
     * @return void
     * @todo à optimiser avec __wakeup et __sleep.
     *
     */
    public function initialisation2()
    {
        global $applicationTraductionInstance, $applicationDisplayInstance, $applicationActionInstance;

        // S'auto-référence pour être capable de se transmettre aux objets.
        $this->_applicationInstance = $this;

        // Charge l'instance de métrology et de journalisation.
        $this->_metrologyInstance = $this->_nebuleInstance->getMetrologyInstance();

        // Retrouve tout le nécessaire au fonctionnement de l'application sauf les instances.
        $this->_findEnvironment();

        // Si c'est le téléchargement d'un objet ou de ses liens, on ne fait pas le chargement de l'affichage.
        if ($this->_findAskDownload()) {
            return;
        }

        // Récupère les instances.
        $this->_traductionInstance = $applicationTraductionInstance;
        $this->_displayInstance = $applicationDisplayInstance;
        $this->_actionInstance = $applicationActionInstance;

        // Charge les modules au besoin. Avant les initialisations.
        $this->_loadModules();
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        global $applicationName;
        return $applicationName;
    }

    /**
     * Fonction de mise en sommeil.
     *
     * Vide par défaut, est remplacé par l'application.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return array();
    }

    /**
     * Fonction de réveil.
     *
     * Récupère l'instance de la librairie nebule.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $nebuleInstance;

        $this->_nebuleInstance = $nebuleInstance;
    }


    /**
     * Retourne le nom de la classe de l'application.
     *
     * @return string
     */
    public function getClassName()
    {
        global $applicationName;
        return $applicationName;
        //return static::class;
    }

    /**
     * Lit l'instance de la librairie nebule.
     *
     * @return nebule
     */
    public function getNebuleInstance()
    {
        return $this->_nebuleInstance;
    }

    /**
     * Lit l'instance d'affichage de l'application.
     *
     * @return Display
     */
    public function getDisplayInstance()
    {
        return $this->_displayInstance;
    }

    /**
     * Lit l'instance de traduction linguistique de l'application.
     *
     * @return Traduction
     */
    public function getTraductionInstance()
    {
        return $this->_traductionInstance;
    }

    /**
     * Lit l'instance de métrologie.
     *
     * @return Metrology
     */
    public function getMetrologyInstance()
    {
        return $this->_metrologyInstance;
    }

    /**
     * Lit l'instance des actions de l'application.
     *
     * @return Actions
     */
    public function getActionInstance()
    {
        return $this->_actionInstance;
    }

    /**
     * Retourne l'objet en cours d'utilisation.
     *
     * @return string
     */
    public function getCurrentObject()
    {
        return $this->_nebuleInstance->getCurrentObject();
    }

    /**
     * Retourne l'instance de l'objet en cours d'utilisation.
     *
     * @return Node
     */
    public function getCurrentObjectInstance()
    {
        return $this->_nebuleInstance->getCurrentObjectInstance();
    }

    /**
     * Retourne si les modules sont activé dans l'application.
     *
     * @return boolean
     */
    public function getUseModules()
    {
        return $this->_useModules;
    }


    /**
     * Recherche toutes les données nécessaires aux applications.
     *
     * @return void
     */
    protected function _findEnvironment()
    {
        $this->_findURL();
        $this->_findCurrentEntity();
    }

    /**
     * Le protocol de l'URL HTTP demandée.
     *
     * @var string
     */
    protected $_urlProtocol;
    /**
     * Le nom de serveur public de l'URL HTTP demandée.
     *
     * @var string
     */
    protected $_urlHost;
    /**
     * Le nom de fichier de l'URL HTTP demandée.
     *
     * @var string
     */
    protected $_urlBasename;
    /**
     * Le chemin de l'URL HTTP demandée.
     *
     * @var string
     */
    protected $_urlPath;
    /**
     * Le nom de serveur public de l'URL HTTP demandée.
     *
     * @var string
     */
    protected $_urlHostname;

    /**
     * Extrait l'URL de connexion au serveur.
     *
     * @return void
     */
    protected function _findURL()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        if (isset($_SERVER['HTTPS'])
            && $_SERVER['HTTPS']
        ) {
            $this->_urlProtocol = 'https';
        } else {
            $this->_urlProtocol = 'http';
        }
        //$this->_urlHost	= $_SERVER['HTTP_HOST'];
        $this->_urlHost = $this->_nebuleInstance->getOption('hostURL');
        $explodeBaseName = explode('/', $_SERVER['REQUEST_URI']);
        $this->_urlBasename = end($explodeBaseName);
        $this->_urlPath = substr($_SERVER['REQUEST_URI'], 0, strlen($_SERVER['REQUEST_URI']) - strlen($this->_urlBasename) - 1);
        $this->_urlHostname = $this->_urlProtocol . '://' . $this->_urlHost . $this->_urlPath;
    }

    /**
     * Retourne le protocol de l'URL HTTP demandée.
     *
     * @return string
     */
    public function getUrlProtocol()
    {
        return $this->_urlProtocol;
    }

    /**
     * Retourne le nom de serveur public de l'URL HTTP demandée.
     *
     * @return string
     */
    public function getUrlHost()
    {
        return $this->_urlHost;
    }

    /**
     * Retourne le chemin de l'URL HTTP demandée.
     *
     * @return string
     */
    public function getUrlBasename()
    {
        return $this->_urlBasename;
    }

    /**
     * Retourne le nom de serveur public de l'URL HTTP demandée.
     *
     * @return string
     */
    public function getUrlPath()
    {
        return $this->_urlPath;
    }

    /**
     * Extrait l'URL de connexion au serveur.
     *
     * @return string
     */
    public function getUrlHostname()
    {
        return $this->_urlHostname;
    }


    protected $_currentEntity, $_currentEntityInstance;

    /**
     * Recherche l'entité en cours d'utilisation.
     */
    protected function _findCurrentEntity()
    {
        $this->_metrologyInstance->addLog('Find current entity', Metrology::LOG_LEVEL_DEBUG); // Log
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
 		 *  ------------------------------------------------------------------------------------------
		 */
        $arg_ent = trim(filter_input(INPUT_GET, nebule::COMMAND_SELECT_ENTITY, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW)); // Lit et nettoye le contenu de la variable GET.
        if ($arg_ent != ''
            && strlen($arg_ent) >= nebule::NEBULE_MINIMUM_ID_SIZE
            && ctype_xdigit($arg_ent)
            && ($this->_nebuleInstance->getIO()->checkObjectPresent($arg_ent)
                || $this->_nebuleInstance->getIO()->checkLinkPresent($arg_ent)
            )
        ) // Si la variable est un objet avec ou sans liens.
        {
            // Ecrit l'objet dans la variable.
            $this->_currentEntity = $arg_ent;
            $this->_currentEntityInstance = $this->_nebuleInstance->newEntity($arg_ent);
            // Ecrit l'objet dans la session.
            $this->_nebuleInstance->setSessionStore('sylabeSelectedEntity', $arg_ent);
        } else {
            // Sinon vérifie si une valeur n'est pas mémorisée dans la session.
            $cache = $this->_nebuleInstance->getSessionStore('sylabeSelectedEntity');
            // Si il existe une variable de session pour l'objet en cours, la lit.
            if ($cache !== false && $cache != '') {
                $this->_currentEntity = $cache;
                $this->_currentEntityInstance = $this->_nebuleInstance->newEntity($cache);
            } else // Sinon selectionne l'entite courante par défaut.
            {
                $this->_currentEntity = $this->_nebuleInstance->getCurrentEntity();
                $this->_currentEntityInstance = $this->_nebuleInstance->newEntity($this->_nebuleInstance->getCurrentEntity());
                $this->_nebuleInstance->setSessionStore('sylabeSelectedEntity', $this->_nebuleInstance->getCurrentEntity());
            }
            unset($cache);
        }
        unset($arg_ent);
    }

    public function getCurrentEntity()
    {
        return $this->_currentEntity;
    }

    public function getCurrentEntityInstance()
    {
        return $this->_currentEntityInstance;
    }


    /**
     * Un téléchargement est demandé.
     *
     * @var boolean
     */
    protected $_askDownload = false;
    /**
     * ID de l'objet demandé au téléchargement.
     *
     * @var string
     */
    protected $_askDownloadObject = '';
    /**
     * ID de l'objet dont les liens sont demandés au téléchargement.
     *
     * @var string
     */
    protected $_askDownloadLinks = '';

    /**
     * Retourne si la requête web est un téléchargement d'objet ou de lien.
     * Des accélérations pruvent être prévues dans ce cas.
     *
     * @return boolean
     */
    public function askDownload()
    {
        return $this->_askDownload;
    }

    /**
     * Gestion des variables pour le téléchargement d'objets et de liens.
     *
     * @return boolean
     */
    protected function _findAskDownload()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // Pre-initialisation de variable $_askDownloadObject.
        // Lit et nettoye le contenu de la variable GET.
        $arg_dwlobj = filter_input(INPUT_GET, nebule::NEBULE_LOCAL_OBJECTS_FOLDER, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW);
        if (strlen($arg_dwlobj) > 0) {
            // Si la variable a une valeur correcte.
            if (trim($arg_dwlobj) != ''
                && ctype_xdigit($arg_dwlobj)
                && strlen(trim($arg_dwlobj)) > 0
            ) {
                $this->_askDownload = true;
                // Ecrit l'objet dans la variable.
                $this->_askDownloadObject = trim($arg_dwlobj);
                // Log
                $this->_metrologyInstance->addLog('Ask for download object ' . $arg_dwlobj, Metrology::LOG_LEVEL_NORMAL);
            }
        }
        unset($arg_dwlobj);
        // Pre-initialisation de variable $_askDownloadLinks.
        // Lit et nettoye le contenu de la variable GET.
        $arg_dwllnk = filter_input(INPUT_GET, nebule::NEBULE_LOCAL_LINKS_FOLDER, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW);
        if (strlen($arg_dwllnk) > 0) {
            // Si la variable a une valeur correcte.
            if (trim($arg_dwllnk) != ''
                && ctype_xdigit($arg_dwllnk)
                && strlen(trim($arg_dwllnk)) > 0
            ) {
                $this->_askDownload = true;
                // Ecrit l'objet dans la variable.
                $this->_askDownloadLinks = trim($arg_dwllnk);
                // Log
                $this->_metrologyInstance->addLog('Ask for download links ' . $arg_dwllnk, Metrology::LOG_LEVEL_NORMAL);
            }
        }
        return $this->_askDownload;
    }

    /**
     * Fonction de téléchargement d'objets ou de liens.
     * Le téléchargement se fait sous forme de fichier pour dé-nebulisation d'un objet
     *   ou affichage dans un navigateur.
     * C'est la seule façon de télécharger le contenu d'un objet protégé.
     *
     * @return void
     */
    protected function _download()
    {
        $err404 = false;
        if ($this->_askDownloadLinks != '') // Détermine si c'est un lien à télécharger.
        {
            if ($this->_nebuleInstance->getIO()->checkLinkPresent($this->_askDownloadLinks)) {
                $this->_metrologyInstance->addLog('Sending links ' . $this->_askDownloadLinks, Metrology::LOG_LEVEL_DEBUG); // Log
                // Flush des erreurs.
                ob_end_clean();
                // Transmission.
                header('Content-Description: File Transfer');
                header('Content-type: text/plain');
                header('Content-Disposition: attachment; filename="' . $this->_askDownloadLinks . '.neb.lnk"');
                header('Content-Transfer-Encoding: binary');
                header('Expires: 0');

                $this->_metrologyInstance->addLog('End sending links ' . $this->_askDownloadLinks, Metrology::LOG_LEVEL_DEBUG); // Log
            } else {
                $err404 = true;
                $this->_metrologyInstance->addLog('Error 404 sending links ' . $this->_askDownloadLinks, Metrology::LOG_LEVEL_ERROR); // Log
            }
        } else // Sinon c'est un objet à télécharger.
        {
            $instance = $this->_nebuleInstance->newObject($this->_askDownloadObject);
            $data = $instance->getContent(0);
            if ($data != null) {
                $this->_metrologyInstance->addLog('Sending object ' . $this->_askDownloadObject, Metrology::LOG_LEVEL_DEBUG); // Log
                // Calcul type mime, nom et suffixe de fichier pour l'utilisateur final.
                $downloadmime = $instance->getType('all');
                $downloadname = $instance->getName('all');
                $downloadsuffix = $instance->getSuffixName('all');
                if ($downloadsuffix != '') {
                    $downloadname .= '.' . $downloadsuffix;
                }
                // Flush des erreurs.
                ob_end_clean();
                // Transmission.
                header('Content-Description: File Transfer');
                header('Content-type: ' . $downloadmime);
                header('Content-Disposition: attachment; filename="' . $downloadname . '"');
                header('Content-Transfer-Encoding: binary');
                header('Expires: 0');
                echo $data;

                $this->_metrologyInstance->addLog('End sending object ' . $this->_askDownloadObject, Metrology::LOG_LEVEL_DEBUG); // Log
            } else {
                $err404 = true;
                $this->_metrologyInstance->addLog('Error 404 sending object ' . $this->_askDownloadObject, Metrology::LOG_LEVEL_ERROR); // Log
            }
        }

        if ($err404) {
            $this->_metrologyInstance->addLog('Sending error 404 ', Metrology::LOG_LEVEL_DEBUG); // Log
            // Transmission.
            ob_end_clean();
            ob_clean();
            header('HTTP/1.0 404 Not Found');
            echo "<h1>404 Not Found</h1>\nThe page that you have requested could not be found.";
        }
    }


    /**
     * Liste des noms des modules par défaut.
     * Cette liste est à fournir par l'application en cours.
     *
     * Ces modules ne sont pas des objets à part entière mais ils sont intégrés à l'objet de l'application.
     *
     * @var array of string
     */
    protected $_listDefaultModules = array();

    /**
     * Liste des noms des modules chargés.
     * Trié par ordre numérique d'arrivé.
     *
     * @var array of string
     */
    protected $_listModulesName = array();

    /**
     * Liste des instances des modules chargés.
     * Trié par noms de modules.
     *
     * @var array of Modules
     */
    protected $_listModulesInstance = array();

    /**
     * Liste des signataires des modules (RID).
     * Trié par noms de modules.
     * A 0 si le modules est chargé par défaut.
     *
     * @var array of string
     */
    protected $_listModulesSignerRID = array();

    /**
     * Liste des ID originaux (de référence) des modules chargés.
     * Trié par noms de modules.
     * A 0 si le modules est chargé par défaut.
     *
     * @var array of string
     */
    protected $_listModulesInitRID = array();

    /**
     * Liste des ID de référence finaux des modules chargés.
     * Trié par noms de modules.
     * A 0 si le modules est chargé par défaut.
     *
     * @var array of string
     */
    protected $_listModulesRID = array();

    /**
     * Liste des ID mis à jours des modules chargés.
     * Trié par noms de modules.
     * A 0 si le modules est chargé par défaut.
     *
     * @var array of string
     */
    protected $_listModulesID = array();

    /**
     * Liste la validité des modules chargés.
     * Trié par noms de modules.
     *
     * @var array of string
     */
    protected $_listModulesValid = array();

    /**
     * Liste l'activation des modules chargés.
     * Trié par noms de modules.
     *
     * @var array of string
     */
    protected $_listModulesEnabled = array();

    /**
     * Le module en cours d'utilisation.
     * Cette variable ne peut pas être initialisée avec l'instance de l'application
     *   parce qu'il faut l'instance Display qui n'est pas encore prête.
     *
     * @var Modules
     */
    protected $_currentModuleInstance = null;

    /**
     * Variable de suivi du chargement des modules pour éviter des doublons.
     *
     * @var boolean
     */
    protected $_loadModulesOK = false;

    /**
     * Chargement des modules.
     *
     * @return void
     */
    protected function _loadModules()
    {
        if ($this->_loadModulesOK) {
            return;
        }
        $this->_loadModulesOK = true;

        // Vérifie si les modules sont activés.
        if (!$this->_useModules) {
            $this->_metrologyInstance->addLog('Do not load modules', Metrology::LOG_LEVEL_DEBUG);
            return;
        }

        // Charge les modules.
        $this->_loadDefaultModules();
        $this->_findModulesRID();
        $this->_findModulesUpdateID();
        $this->_initModules();
    }

    /**
     * Charge et initialise les modules par défaut.
     *
     * @return void
     */
    protected function _loadDefaultModules()
    {
        // Vérifie si les modules sont activés.
        if (!$this->_useModules) {
            return;
        }

        $this->getMetrologyInstance()->addLog('Load default modules', Metrology::LOG_LEVEL_DEBUG); // Log

        foreach ($this->_listDefaultModules as $moduleName) {
            $this->getMetrologyInstance()->addTime();
            $this->getMetrologyInstance()->addLog('New ' . $moduleName, Metrology::LOG_LEVEL_DEBUG); // Log
            $instance = new $moduleName($this->_applicationInstance);
            $instance->initialisation();
            $this->_listModulesName[] = $moduleName;
            $this->_listModulesInstance[$moduleName] = $instance;
            $this->_listModulesInitRID[$moduleName] = '0';
            $this->_listModulesID[$moduleName] = '0';
            $this->_listModulesSignerRID[$moduleName] = '0';
            $this->_listModulesValid[$moduleName] = true;
        }
    }

    /**
     * Recherche les ID de référence des modules configurés.
     * Extrait la liste des modules depuis les liens de l'objet de référence.
     *
     * @return void
     */
    protected function _findModulesRID()
    {
        global $bootstrapApplicationStartID;

        // Vérifie si les modules sont activés.
        if (!$this->_useModules) {
            return;
        }

        $this->getMetrologyInstance()->addLog('Find option modules', Metrology::LOG_LEVEL_DEBUG); // Log

        // Extrait les modules référencés.
        $object = $this->_nebuleInstance->newObject($bootstrapApplicationStartID);
        $hashRef = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_INTERFACE_APP_MODULES);
        $links = $object->readLinksFilterFull('', '', 'f', $bootstrapApplicationStartID, '', $hashRef);

        // Lit les ID des modules.
        foreach ($links as $link) {
            // Filtre sur le signataire.
            $ok = false;
            $module = $link->getHashTarget();
            foreach ($this->_nebuleInstance->getLocalAuthorities() as $autority) {
                if ($link->getHashSigner() == $autority
                    && $module != '0'
                    && $this->_nebuleInstance->getIO()->checkLinkPresent($module)
                ) {
                    $ok = true;
                    break;
                }
            }
            if ($ok) {
                $this->getMetrologyInstance()->addLog('Find modules ' . $module, Metrology::LOG_LEVEL_DEBUG); // Log
                $this->_listModulesInitRID[$module] = $module;
                $this->_listModulesSignerRID[$module] = $link->getHashSigner();
            }
        }
    }

    /**
     * Recherche les mises à jours des modules à partir des ID de référence.
     * @return void
     * @todo
     *
     */
    protected function _findModulesUpdateID()
    {
        // Vérifie si les modules sont activés.
        if (!$this->_useModules) {
            return;
        }

        $this->getMetrologyInstance()->addLog('Find modules updates', Metrology::LOG_LEVEL_DEBUG); // Log

        // Recherche la mise à jour et vérifie les objets des modules avant de les charger.
        $listed = array();
        foreach ($this->_listModulesInitRID as $moduleID) {
            // Vérifie l'ID. Un module chargé par défaut est déjà chargé et à un ID = 0.
            if ($moduleID == '0'
                || $moduleID == ''
            ) {
                continue;
            }

            $moduleRID = $moduleID;

            $this->getMetrologyInstance()->addLog('Ask load module ' . $moduleID, Metrology::LOG_LEVEL_DEBUG);
            $okValid = false;
            $okActivated = false;
            $okNotListed = true;

            // Vérifie que l'objet n'est pas déjà appelé.
            foreach ($listed as $element) {
                if ($element == $moduleID) {
                    $this->getMetrologyInstance()->addLog('Module already listed ' . $moduleID, Metrology::LOG_LEVEL_DEBUG);
                    $okNotListed = false;
                }
            }

            $instanceModule = $this->_nebuleInstance->newObject($moduleID);
            $listed[$moduleID] = $moduleID;

            // Cherche une mise à jour.
            $updateModule = $moduleID;
            if ($okNotListed) {
                $updateModule = $instanceModule->getReferencedObjectID(nebule::REFERENCE_NEBULE_OBJET_INTERFACE_APP_MODULES, 'strict');
                $updateSigner = $instanceModule->getReferencedSignerID(nebule::REFERENCE_NEBULE_OBJET_INTERFACE_APP_MODULES, 'strict');
            }
            if ($updateModule != $moduleID
                && $updateModule != '0'
            ) {
                $instanceModule = $this->_nebuleInstance->newObject($updateModule);
                if ($instanceModule->getType('strict') == 'application/x-php'
                    && $this->_nebuleInstance->getIO()->checkObjectPresent($updateModule)
                ) {
                    $this->getMetrologyInstance()->addLog('Find module update ' . $updateModule, Metrology::LOG_LEVEL_DEBUG);
                    $okValid = true;
                    // Vérifie que l'objet n'est pas déjà appelé.
                    foreach ($listed as $element) {
                        if ($element == $updateModule) {
                            $this->getMetrologyInstance()->addLog('Module update already listed ' . $updateModule, Metrology::LOG_LEVEL_DEBUG);
                            $okNotListed = false;
                        }
                    }

                    $moduleID = $updateModule;
                    $listed[$updateModule] = $updateModule;
                } else {
                    $this->getMetrologyInstance()->addLog('Module updated type mime not valid ' . $moduleID, Metrology::LOG_LEVEL_ERROR);
                    $okValid = false;
                }
            }

            // Vérifie si le module est activé.
            $okActivated = $this->getIsModuleActivated($instanceModule);
            unset($instanceModule, $updateModule, $element);

            // @todo Vérifier le contenu.
            // A faire, DANGEREUX !!!

            // Enregirstre le module.
            if ($okValid
                && $okNotListed
            ) {
                // Recherche le nom du module.
                $name = $this->_getObjectClassName($moduleID);

                // Vérifie le nom.
                if ($name !== false
                    && $name != ''
                    && substr($name, 0, 6) == 'Module'
                ) {
                    // Charge le code php si le module est activé..
                    if ($okActivated || true) // @todo à revoir...
                    {
                        $this->getMetrologyInstance()->addLog('Load module ' . $moduleID, Metrology::LOG_LEVEL_DEBUG);
                        include('o/' . $moduleID);                // @todo A modifier, passer par IO.
                        $this->_listModulesEnabled[$name] = true;
                    }

                    // Enregistre le module.
                    $this->_listModulesID[$name] = $moduleID;
                    $this->_listModulesRID[$name] = $moduleRID;
                    $this->_listModulesValid[$name] = true;
                    $this->_listModulesSignerRID[$name] = $this->_listModulesSignerRID[$moduleRID];
                    $this->_listModulesSignerRID[$moduleID] = $updateSigner;
                    if ($this->_listModulesSignerRID[$moduleID] == '0') {
                        $this->_listModulesSignerRID[$moduleID] = $this->_listModulesSignerRID[$moduleRID];
                    }
                    $this->_listModulesName[] = $name;
                }
            } else {
                $this->_listModulesValid[$name] = false;
            }
            $this->getMetrologyInstance()->addLog('End load module ' . $moduleID, Metrology::LOG_LEVEL_DEBUG);
        }
    }

    /**
     * Recherche le nom de la classe dans un objet.
     *
     * @param string $id
     * @return boolean|string
     */
    protected function _getObjectClassName($id)
    {
        $name = false;
        $readValue = $this->_nebuleInstance->getIO()->objectRead($id);
        $startValue = strpos($readValue, 'class');
        $trimLine = substr($readValue, $startValue, 128);
        $arrayValue = explode(' ', $trimLine);
        if ($arrayValue[1] != null) {
            $name = $arrayValue[1];
        }
        return $name;
    }

    /**
     * Charge et initialise les modules.
     *
     * @return void
     */
    protected function _initModules()
    {
        // Vérifie si les modules sont activés.
        if (!$this->_useModules) {
            return;
        }

        $this->getMetrologyInstance()->addLog('Load option modules', Metrology::LOG_LEVEL_DEBUG); // Log

        // Liste toutes les classes module* et les charges une à une.
        $list = get_declared_classes();
        foreach ($list as $i => $class) {
            // Ne regarde que les classes qui sont des modules d'après le nom.
            if (substr($class, 0, 6) == 'Module'
                && $class != 'Modules'
            ) {
                $this->getMetrologyInstance()->addTime();
                $this->getMetrologyInstance()->addLog('New ' . $class, Metrology::LOG_LEVEL_DEBUG); // Log
                $instance = new $class($this->_applicationInstance);

                $this->_listModulesEnabled[$class] = false; // @todo à revoir...

                // Vérifie si c'est une dépendance de la classe Modules.
                if (is_a($instance, 'Modules')) {
                    $this->getMetrologyInstance()->addLog('Class ' . $class . ' is child of Modules', Metrology::LOG_LEVEL_DEBUG); // Log
                    $instance->initialisation();
                    $this->_listModulesInstance[$class] = $instance;
                    $this->_listModulesEnabled[$class] = true; // @todo à revoir...
                }
            }
        }

        $this->_metrologyInstance->addLog('Modules loaded', Metrology::LOG_LEVEL_DEBUG);
    }

    /**
     * Lit si le module est activé.
     * Ne pend en charge que les modules activables, c'est à dire non intégrés à l'application.
     *
     * @param Node $module
     * @return boolean
     */
    public function getIsModuleActivated($module)
    {
        $hashActivation = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_INTERFACE_APP_MOD_ACTIVE);

        // Liste les modules reconnues par une entité locale.
        $linksList = $module->readLinksFilterFull('', '', 'f', $module->getID(), $hashActivation, $module->getID());
        $link = null;
        foreach ($linksList as $link) {
            // Vérifie que le signataire est une entité locale.
            if ($this->_nebuleInstance->getIsLocalAuthority($link->getHashSigner())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Liste les noms des modules disponibles.
     *
     * @return array of string
     */
    public function getModulesListNames()
    {
        return $this->_listModulesName;
    }

    /**
     * Liste les instances des modules disponibles. Les noms sont ceux générés par getType().
     *
     * @return array of Modules
     */
    public function getModulesListInstances()
    {
        return $this->_listModulesInstance;
    }

    /**
     * Liste les ID des modules disponibles.
     *
     * @return array of string
     */
    public function getModulesListID()
    {
        return $this->_listModulesID;
    }

    /**
     * Liste les ID de référence des modules disponibles.
     *
     * @return array of string
     */
    public function getModulesListRID()
    {
        return $this->_listModulesRID;
    }

    /**
     * Liste les signataires des modules disponibles (RID).
     *
     * @return array of string
     */
    public function getModulesListSignersRID()
    {
        return $this->_listModulesSignerRID;
    }

    /**
     * Liste la validité des modules disponibles.
     *
     * @return array of string
     */
    public function getModulesListValid()
    {
        return $this->_listModulesValid;
    }

    /**
     * Liste l'activation des modules disponibles.
     *
     * @return array of string
     */
    public function getModulesListEnabled()
    {
        return $this->_listModulesEnabled;
    }

    /**
     * Vérifie si le module est chargé. Le module est recherché sur le nom de sa classe.
     * Si non truvé, retourne false.
     *
     * @param string $name
     * @return boolean
     */
    public function isModuleLoaded($name)
    {
        // Vérifie si les modules sont activés.
        if (!$this->_useModules) {
            return;
        }

        // Vérifie que c'est un module demandé.
        if ($name == ''
            || substr($name, 0, 6) != 'Module'
            || $name == 'Modules'
        ) {
            return false;
        }

        // Extrait la liste des classes.
        $classes = get_declared_classes();

        foreach ($classes as $class) {
            if ($name == $class) {
                return true;
            }
        }
        return false;
    }

    /**
     * Retourne le module en cours d'utilisation.
     * Si les modules ne sont pas utilisés, retourne false.
     *
     * @return Modules|boolean
     */
    public function getCurrentModuleInstance()
    {
        // Vérifie si les modules sont activés.
        if (!$this->_useModules) {
            return false;
        }

        // Vérifie si pas déjà recherché.
        if ($this->_currentModuleInstance != null
            && is_a($this->_currentModuleInstance, 'Modules')
        ) {
            return $this->_currentModuleInstance;
        }

        $result = false;
        foreach ($this->_listModulesInstance as $module) {
            if ($module->getCommandName() == $this->_displayInstance->getCurrentDisplayMode()) {
                $result = $module;
                break;
            }
        }
        return $result;
    }

    /**
     * Retourne le module demandé par le nom de sa classe.
     * Si non trouvé, retourne false.
     *
     * @param string $name
     * @return Modules|boolean
     */
    public function getModule($name)
    {
        // Vérifie si les modules sont activés.
        if (!$this->_useModules) {
            return false;
        }

        $result = false;
        // Vérifie que c'est un module demandé.
        if ($name == ''
            || substr($name, 0, 6) != 'Module'
            || $name == 'Modules'
        ) {
            return false;
        }

        // Extrait la liste des classes.
        $classes = get_declared_classes();

        foreach ($classes as $class) {
            if ($name == $class) {
                $result = $this->_listModulesInstance[$name];
                break;
            }
        }
        return $result;
    }


    /**
     * Routage.
     */
    public function router()
    {
        global $applicationTraductionInstance, $applicationDisplayInstance, $applicationActionInstance;

        $this->_metrologyInstance->addLog('Running application', Metrology::LOG_LEVEL_NORMAL); // Log

        if ($this->_askDownload) {
            $this->_download();
        } else {
            // Affichage.
            $this->_metrologyInstance->addLog('Running display', Metrology::LOG_LEVEL_DEBUG); // Log

            // Récupère les instances.
            $this->_traductionInstance = $applicationTraductionInstance;
            $this->_displayInstance = $applicationDisplayInstance;
            $this->_actionInstance = $applicationActionInstance;

            // Affichage !
            $this->_displayInstance->display();

            $this->_metrologyInstance->addLog('End display', Metrology::LOG_LEVEL_DEBUG); // Log
        }
    }



    /*
	 * Tests de sécurité génériques.
	 */
    /**
     * Etat général de la sécurité.
     * Si au moins un des états de sécurité change, l'état général prend la valeur la plus critique des états.
     *
     * @var string
     */
    protected $_checkSecurityAll = "OK";

    /**
     * Retourne l'état de sécurité général.
     *
     * @return string
     */
    public function getCheckSecurityAll()
    {
        return $this->_checkSecurityAll;
    }

    /**
     * Fait un état complet de la sécurité.
     *
     * Nécessite la métrologie et la traduction.
     *
     * @return void
     */
    public function checkSecurity()
    {
        $this->_checkSecurity();
    }

    /**
     * Fait un état complet de la sécurité.
     *
     * Nécessite la métrologie et la traduction.
     *
     * @return void
     */
    protected function _checkSecurity()
    {
        $this->_checkSecurityBootstrap();
        $this->_checkSecurityCryptoHash();
        $this->_checkSecurityCryptoSym();
        $this->_checkSecurityCryptoAsym();
        $this->_checkSecuritySign();
        $this->_checkSecurityURL();

        $this->_checkSecurityAll = 'OK';

        if ($this->_checkSecurityBootstrap == 'WARN'
            || $this->_checkSecurityCryptoHash == 'WARN'
            || $this->_checkSecurityCryptoSym == 'WARN'
            || $this->_checkSecurityCryptoAsym == 'WARN'
            || $this->_checkSecuritySign == 'WARN'
            || $this->_checkSecurityURL == 'WARN'
        ) {
            $this->_checkSecurityAll = 'WARN';
            $this->_metrologyInstance->addLog('General WARN', Metrology::LOG_LEVEL_ERROR); // Log
        }

        if ($this->_checkSecurityBootstrap == 'ERROR'
            || $this->_checkSecurityCryptoHash == 'ERROR'
            || $this->_checkSecurityCryptoSym == 'ERROR'
            || $this->_checkSecurityCryptoAsym == 'ERROR'
            || $this->_checkSecuritySign == 'ERROR'
            || $this->_checkSecurityURL == 'ERROR'
        ) {
            $this->_checkSecurityAll = 'ERROR';
            $this->_metrologyInstance->addLog('General ERROR', Metrology::LOG_LEVEL_ERROR); // Log
        }
    }

    // Test de consistance du bootstrap.

    /**
     * Etat de sécurité du bootstrap.
     *
     * @var string
     */
    protected $_checkSecurityBootstrap = "ERROR";
    /**
     * Message de l'état de sécurité du bootstrap.
     *
     * @var string
     */
    protected $_checkSecurityBootstrapMessage = ":::act_chk_errBootstrap";

    /**
     * Retourne l'état de sécurité du bootstrap.
     *
     * @return string
     */
    public function getCheckSecurityBootstrap()
    {
        return $this->_checkSecurityBootstrap;
    }

    /**
     * Retourne le message de l'état de sécurité du bootstrap.
     *
     * @return string
     */
    public function getCheckSecurityBootstrapMessage()
    {
        return $this->_checkSecurityBootstrapMessage;
    }

    /**
     * Recherche l'état de sécurité du bootstrap.
     *
     * @return void
     */
    protected function _checkSecurityBootstrap()
    {
        $this->_checkSecurityBootstrap = 'ERROR';
        $data = file_get_contents(nebule::NEBULE_BOOTSTRAP_FILE);
        $hash = $this->_nebuleInstance->getCrypto()->hash($data);

        // Recherche les liens de validation.
        $hashRef = $this->_nebuleInstance->getCrypto()->hash(nebule::REFERENCE_NEBULE_OBJET_INTERFACE_BOOTSTRAP);
        $object = $this->_nebuleInstance->newObject($hashRef);
        $links = $object->readLinksFilterFull('', '', 'f', $hashRef, $hash, $hashRef);

        // Trie sur les autorités locales.
        $ok = false;
        foreach ($links as $link) {
            foreach ($this->_nebuleInstance->getLocalAuthorities() as $autority) {
                if ($link->getHashSigner() == $autority) {
                    $ok = true;
                    break 2;
                }
            }
        }
        unset($data, $hash, $object, $links, $link);

        if ($ok) {
            $this->_checkSecurityBootstrap = 'OK';
            $this->_checkSecurityBootstrapMessage = "OK";
            $this->_metrologyInstance->addLog('SECURITY OK Bootstrap', Metrology::LOG_LEVEL_DEBUG); // Log
        }
        // Modification pour le mode rescue afin de permettre un déverrouillage sur un boostrap inconnu. Le mode rescue est dangereux. @todo bof...
        /*		if ( $this->_nebuleInstance->getModeRescue()
				&& ! $ok
			)
		{
			$this->_checkSecurityBootstrap = 'WARN';
			$this->_checkSecurityBootstrapMessage = ":::act_chk_errBootstrap";
			$this->_metrologyInstance->addLog('SECURITY WARN Bootstrap', Metrology::LOG_LEVEL_ERROR); // Log
		}*/
    }

    // Test de la crypto de prise d'empreinte.

    /**
     * Etat de sécurité des fonctions de prise d'empreinte cryptographique.
     *
     * @var string
     */
    protected $_checkSecurityCryptoHash = 'WARN';
    /**
     * Message de l'état de sécurité des fonctions de prise d'empreinte cryptographique.
     *
     * @var string
     */
    protected $_checkSecurityCryptoHashMessage = 'HASH Unchecked';

    /**
     * Retourne l'état de sécurité des fonctions de prise d'empreinte cryptographique.
     *
     * @return string
     */
    public function getCheckSecurityCryptoHash()
    {
        return $this->_checkSecurityCryptoHash;
    }

    /**
     * Retourne le message de l'état de sécurité des fonctions de prise d'empreinte cryptographique.
     *
     * @return string
     */
    public function getCheckSecurityCryptoHashMessage()
    {
        return $this->_checkSecurityCryptoHashMessage;
    }

    /**
     * Recherche l'état de sécurité des fonctions de prise d'empreinte cryptographique.
     *
     * @return void
     */
    protected function _checkSecurityCryptoHash()
    {
        $this->_checkSecurityCryptoHash = 'WARN';
        if ($this->_nebuleInstance->getCrypto()->checkHashFunction()) {
            $this->_checkSecurityCryptoHash = 'OK';
            $this->_checkSecurityCryptoHashMessage = 'OK';
            $this->_metrologyInstance->addLog('SECURITY OK Hash Crypto', Metrology::LOG_LEVEL_DEBUG); // Log
        } else {
            $this->_checkSecurityCryptoHash = 'ERROR';
            $this->_checkSecurityCryptoHashMessage = ':::act_chk_errCryptHash';
            $this->_metrologyInstance->addLog('SECURITY ERROR Hash Crypto', Metrology::LOG_LEVEL_ERROR); // Log
        }
    }

    // Test de la crypto symétrique.

    /**
     * Etat de sécurité des fonctions cryptographiques symétriques.
     *
     * @var string
     */
    protected $_checkSecurityCryptoSym = 'WARN';
    /**
     * Message de l'état de sécurité des fonctions cryptographiques symétriques.
     *
     * @var string
     */
    protected $_checkSecurityCryptoSymMessage = 'SYM Unchecked';

    /**
     * Retourne l'état de sécurité des fonctions cryptographiques symétriques.
     *
     * @return string
     */
    public function getCheckSecurityCryptoSym()
    {
        return $this->_checkSecurityCryptoSym;
    }

    /**
     * Retourne le message de l'état de sécurité des fonctions cryptographiques symétriques.
     *
     * @return string
     */
    public function getCheckSecurityCryptoSymMessage()
    {
        return $this->_checkSecurityCryptoSymMessage;
    }

    /**
     * Recherche l'état de sécurité des fonctions cryptographiques symétriques.
     *
     * @return void
     */
    protected function _checkSecurityCryptoSym()
    {
        $this->_checkSecurityCryptoSym = 'WARN';
        if ($this->_nebuleInstance->getCrypto()->checkSymetricFunction()) {
            $this->_checkSecurityCryptoSym = 'OK';
            $this->_checkSecurityCryptoSymMessage = 'OK';
            $this->_metrologyInstance->addLog('SECURITY OK Sym Crypto', Metrology::LOG_LEVEL_DEBUG); // Log
        } else {
            $this->_checkSecurityCryptoSym = 'ERROR';
            $this->_checkSecurityCryptoSymMessage = ':::act_chk_errCryptSym';
            $this->_metrologyInstance->addLog('SECURITY ERROR Sym Crypto', Metrology::LOG_LEVEL_ERROR); // Log
        }
    }

    // Test de la crypto asymétrique.

    /**
     * Etat de sécurité des fonctions cryptographiques asymétriques.
     *
     * @var string
     */
    protected $_checkSecurityCryptoAsym = 'WARN';
    /**
     * Message de l'état de sécurité des fonctions cryptographiques asymétriques.
     *
     * @var string
     */
    protected $_checkSecurityCryptoAsymMessage = 'ASYM Unchecked';

    /**
     * Retourne l'état de sécurité des fonctions cryptographiques asymétriques.
     *
     * @return string
     */
    public function getCheckSecurityCryptoAsym()
    {
        return $this->_checkSecurityCryptoAsym;
    }

    /**
     * Retourne le message de l'état de sécurité des fonctions cryptographiques asymétriques.
     *
     * @return string
     */
    public function getCheckSecurityCryptoAsymMessage()
    {
        return $this->_checkSecurityCryptoAsymMessage;
    }

    /**
     * Recherche l'état de sécurité des fonctions cryptographiques asymétriques.
     *
     * @return void
     */
    protected function _checkSecurityCryptoAsym()
    {
        $this->_checkSecurityCryptoAsym = 'WARN';
        if ($this->_nebuleInstance->getCrypto()->checkAsymetricFunction()) {
            $this->_checkSecurityCryptoAsym = 'OK';
            $this->_checkSecurityCryptoAsymMessage = 'OK';
            $this->_metrologyInstance->addLog('SECURITY OK Asym Crypto', Metrology::LOG_LEVEL_DEBUG); // Log
        } else {
            $this->_checkSecurityCryptoAsym = 'ERROR';
            $this->_checkSecurityCryptoAsymMessage = ':::act_chk_errCryptAsym';
            $this->_metrologyInstance->addLog('SECURITY ERROR Asym Crypto', Metrology::LOG_LEVEL_ERROR); // Log
        }
    }

    // Test de la signature.

    /**
     * Etat de sécurité des fonctions de signature.
     *
     * @var string
     */
    protected $_checkSecuritySign = 'WARN';
    /**
     * Message de l'état de sécurité des fonctions de signature.
     *
     * @var string
     */
    protected $_checkSecuritySignMessage = 'SIGN Unchecked';

    /**
     * Retourne l'état de sécurité des fonctions de signature.
     *
     * @return string
     */
    public function getCheckSecuritySign()
    {
        return $this->_checkSecuritySign;
    }

    /**
     * Retourne le message de l'état de sécurité des fonctions de signature.
     *
     * @return string
     */
    public function getCheckSecuritySignMessage()
    {
        return $this->_checkSecuritySignMessage;
    }

    /**
     * Recherche l'état de sécurité des fonctions de signature.
     *
     * @return void
     */
    protected function _checkSecuritySign()
    {
        $this->_checkSecuritySign = 'WARN';
        if (!$this->_nebuleInstance->getOption('permitCheckSignOnVerify')) {
            $this->_checkSecuritySign = 'WARN';
            $this->_checkSecuritySignMessage = ':::act_chk_warnSigns';
        } else {
            $validLink = '66c2dc6023d5a079a592231c06398617e3f7bacdad96624b8921081ab98b5c6edbda3629c1d99550351fd4f0623c0767ca7957d1f240b49a09a74470a2ad14efc0884765563ca575b3d453d1edc11ef1a0c3d16f332e9891224c95cc236f9f5b77199e91ccbff0577c05b214e998dc942e9114c6de11012c8abc4c32bb80735c1953d98772d9d583bae819fb9250cfba8154a13dc7999cf5007af42cc09dbe5f44ce2c00db3d35a143ad1f3dcf644457c35d752a464598eb2142f3ad24b9c2e090515641623e41734a243b28af2296b9b2171e87893f0b07f8bc4af7e1324349b7b4f18c388c559d18047be372634c9c3fa8f948fe844e88643be91191051c99.sha256_19762515dd804577f9fd8c005a7803ddee413f264319748e30aa2aedf318ca57_2013-03-18T22:43:15+0100_l_19762515dd804577f9fd8c005a7803ddee413f264319748e30aa2aedf318ca57_5d5b09f6dcb2d53a5fffc60c4ac0d55fabdf556069d6631545f42aa6e3500f2e_8e2adbda190535721fc8fceead980361e33523e97a9748aba95642f8310eb5ec';
            $invalidLink = '66c2dc6023d5a079a592231c06398617e3f7bacdad96624b8921081ab98b5c6edbda3629c1d99550351fd4f0623c0767ca7957d1f240b49a09e74470a2ad14efc0884765563ca575b3d453d1edc11ef1a0c3d16f332e9891224c95cc236f9f5b77199e91ccbff0577c05b214e998dc942e9114c6de11012c8abc4c32bb80735c1953d98772d9d583bae819fb9250cfba8154a13dc7999cf5007af42cc09dbe5f44ce2c00db3d35a143ad1f3dcf644457c35d752a464598eb2142f3ad24b9c2e090515641623e41734a243b28af2296b9b2171e87893f0b07f8bc4af7e1324349b7b4f18c388c559d18047be372634c9c3fa8f948fe844e88643be91191051c99.sha256_19762515dd804577f9fd8c005a7803ddee413f264319748e30aa2aedf318ca57_2013-03-18T22:43:15+0100_l_19762515dd804577f9fd8c005a7803ddee413f264319748e30aa2aedf318ca57_5d5b09f6dcb2d53a5fffc60c4ac0d55fabdf556069d6631545f42aa6e3500f2e_8e2adbda190535721fc8fceead980361e33523e97a9748aba95642f8310eb5ec';
            $instanceValidLink = $this->_nebuleInstance->newLink($validLink);
            $instanceInvalidLink = $this->_nebuleInstance->newLink($invalidLink);

            if ($instanceValidLink->getSigned() === false
                || $instanceInvalidLink->getSigned() === true
            ) {
                $this->_checkSecuritySign = 'ERROR';
                $this->_checkSecuritySignMessage = ':::act_chk_errSigns';
                $this->_metrologyInstance->addLog('SECURITY ERROR Sign', Metrology::LOG_LEVEL_ERROR); // Log
            } else {
                $this->_checkSecuritySign = 'OK';
                $this->_checkSecuritySignMessage = 'OK';
                $this->_metrologyInstance->addLog('SECURITY OK Sign', Metrology::LOG_LEVEL_DEBUG); // Log
            }
            unset($validLink, $instanceValidLink, $invalidLink, $instanceInvalidLink);
        }
    }

    // Test de l'URL.

    /**
     * Etat de sécurité de l'URL.
     *
     * @var string
     */
    protected $_checkSecurityURL = 'OK';
    /**
     * Message de l'état de sécurité de l'URL.
     *
     * @var string
     */
    protected $_checkSecurityURLMessage = 'OK';

    /**
     * Retourne l'état de sécurité de l'URL.
     *
     * @return string
     */
    public function getCheckSecurityURL()
    {
        return $this->_checkSecurityURL;
    }

    /**
     * Retourne le message de l'état de sécurité de l'URL.
     *
     * @return string
     */
    public function getCheckSecurityURLMessage()
    {
        return $this->_checkSecurityURLMessage;
    }

    /**
     * Recherche l'état de sécurité de l'URL.
     *
     * @return void
     */
    protected function _checkSecurityURL()
    {
        $this->_checkSecurityURL = 'OK';
        if ($this->_urlProtocol == 'http'
            && $this->_nebuleInstance->getOption('displayUnsecureURL')
        ) {
            $this->_checkSecurityURL = 'WARN';
            $this->_checkSecurityURLMessage = $this->_traductionInstance->getTraduction('Connexion non sécurisée')
                . '. ' . $this->_traductionInstance->getTraduction('Essayer plutôt')
                . ' <a href="https://' . $this->_urlHost . '/' . $this->_urlBasename . '">https://' . $this->_urlHost . '/</a>';
            $this->_metrologyInstance->addLog('SECURITY WARN URL', Metrology::LOG_LEVEL_ERROR); // Log
        } else {
            $this->_metrologyInstance->addLog('SECURITY OK URL', Metrology::LOG_LEVEL_DEBUG); // Log
        }
    }


    /**
     * Affiche la partie menu de la documentation.
     * Inclu les modules.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#oi">OA / Application</a>
            <ul>
                <li><a href="#oaf">OAF / Fonctionnement</a></li>
                <li><a href="#oan">OAN / Nommage</a></li>
                <li><a href="#oap">OAP / Protection</a></li>
                <li><a href="#oad">OAD / Dissimulation</a></li>
                <li><a href="#oal">OAL / Liens</a></li>
                <li><a href="#oac">OAC / Création</a></li>
                <li><a href="#oas">OAS / Stockage</a></li>
                <li><a href="#oat">OAT / Transfert</a></li>
                <li><a href="#oar">OAR / Réservation</a></li>
                <li><a href="#oai">OAI / Interface</a>
                    <ul>
                        <li><a href="#oain">OAIN / Nommage</a></li>
                        <li><a href="#oaip">OAIP / Protection</a></li>
                        <li><a href="#oaid">OAID / Dissimulation</a></li>
                        <li><a href="#oail">OAIL / Liens</a></li>
                        <li><a href="#oaic">OAIC / Création</a>
                            <ul>
                                <li><a href="#oaicr">OAICR / Référence</a>
                                <li><a href="#oaicc">OAICC / Code</a>
                                <li><a href="#oaice">OAICE / Enregistrement</a>
                            </ul>
                        </li>
                        <li><a href="#oaiu">OAIU / Mise à Jour</a></li>
                        <li><a href="#oais">OAIS / Stockage</a></li>
                        <li><a href="#oait">OAIT / Transfert</a></li>
                        <li><a href="#oair">OAIR / Réservation</a></li>
                        <li><a href="#oaig">OAIG / Applications d'Interfaçage Génériques</a>
                            <ul>
                                <li><a href="#oaigb">OAIGB / Nb - bootstrap</a></li>
                                <li><a href="#oaigs">OAIGS / Sy - sylabe</a></li>
                                <li><a href="#oaigk">OAIGK / Kl - klicty</a></li>
                                <li><a href="#oaigm">OAIGM / Me - messae</a></li>
                                <li><a href="#oaigo">OAIGO / No - option</a></li>
                                <li><a href="#oaigu">OAIGU / Nu - upload</a></li>
                                <li><a href="#oaigd">OAIGD / Nd - defolt</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <?php Modules::echoDocumentationTitles(); ?>

                <li><a href="#oaio">OAIO / Implémentation des Options</a></li>
                <li><a href="#oaia">OAIA / Implémentation des Actions</a></li>
            </ul>
        </li>

        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     * Inclu les modules.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h2 id="oa">OA / Application</h2>
        <p>A faire...</p>
        <p>Une application permet d'interagir avec les objets et liens.</p>
        <p>Un application qui ne fait que lire des objets et liens, ou retrasmettre des liens déjà signés, est dite
            passive. Si l'application à la capacité de générer des liens signés, donc avec une entité déverrouillée,
            alors elle est dite active.</p>
        <p>Si l'entité d'une instance d'application est par défaut et automatiquement déverrouillée, donc active, alors
            c'est aussi un robot. Le déverrouillage de cette entité peut cependant bénéficier de protections
            paticulières.</p>

        <h3 id="oaf">OAF / Fonctionnement</h3>
        <p>Dans la construction du code, il y a quatre niveaux. Chaque niveau de code est constitué d’un et un seul
            objet nebule ou fichier utilisé. Une seule application est utilisé à un instant donné mais il peut y avoir
            plusieurs modules utilisés par l’application. Les niveaux :</p>
        <ul>
            <li>le bootstrap, fichier ;</li>
            <li>la librairie en PHP orienté objet, objet ;</li>
            <li>une application au choix, objets ;</li>
            <li>des modules au choix, facultatifs, objets.</li>
        </ul>
        <p>Les applications sont toutes construites sur le même modèle et dépendent (extend) toutes des mêmes classes de
            l’application de référence dans la librairie nebule.</p>
        <p>Chaque application doit mettre en place les variables personnalisées :</p>
        <ul>
            <li>$applicationName</li>
            <li>$applicationSurname</li>
            <li>$applicationDescription</li>
            <li>$applicationVersion</li>
            <li>$applicationLicence</li>
            <li>$applicationAuthor</li>
            <li>$applicationWebsite</li>
        </ul>
        <p>Chaque application doit mettre en place les classes :</p>
        <ul>
            <li>Application</li>
            <li>Display</li>
            <li>Action</li>
            <li>Traduction</li>
        </ul>
        <p>Elles dépendent respectivement des classes de l’application de référence Applications, Displays, Actions et
            Traductions dans la librairie nebule.</p>

        <h3 id="oan">OAN / Nommage</h3>
        <p>A faire...</p>

        <h3 id="oap">OAP / Protection</h3>
        <p>A faire...</p>

        <h3 id="oad">OAD / Dissimulation</h3>
        <p>A faire...</p>

        <h3 id="oal">OAL / Liens</h3>
        <p>A faire...</p>

        <h3 id="oac">OAC / Création</h3>
        <p>A faire...</p>

        <h3 id="oas">OAS / Stockage</h3>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h3 id="oat">OAT / Transfert</h3>
        <p>A faire...</p>

        <h3 id="oar">OAR / Réservation</h3>
        <p>Les objets réservés spécifiquement pour les applications :</p>
        <ul>
            <li>nebule/objet/applications</li>
        </ul>

        <h3 id="oai">OAI / Interface</h3>
        <p>Une interface est un programme dédié aux interactions entre deux milieux différents.</p>
        <p>Une interface permet à une entité, c'est à dire un utilisateur ou un robot, d'interagir avec une application.
            Cela peut être vu comme une extension de l'application.</p>
        <p>A faire...</p>

        <p>Les applications développées dans le cadre de <i>nebule</i> :</p>
        <ul>
            <li><b>bootstrap</b> : le chargeur initial de la librairie et des applications, <a href="#oaigb">OAIGB</a>.
            </li>
            <li><b>sylabe</b> : l’application de référence des possibilités de nebule, <a href="#oaigs">OAIGS</a>, <a
                        href="http://blog.sylabe.org">blog.sylabe.org</a>.
            </li>
            <li><b>klicty</b> : l’application de partage d’objets à durée limitée, <a href="#oaigk">OAIGk</a>, <a
                        href="http://blog.klicty.org">blog.klicty.org</a>.
            </li>
            <li><b>messae</b> : l’application de gestion des conversations et messages, <a href="#oaigm">OAIGM</a>, <a
                        href="http://blog.messae.org">blog.messae.org</a>.
            </li>
            <li><b>option</b> : l’application de gestion des options, <a href="#oaigo">OAIGO</a>.</li>
            <li><b>upload</b> : l’application de chargement de mises à jours, <a href="#oaigu">OAIGU</a>.</li>
            <li><b>defolt</b> : l’application pour un affichage par défaut sans application interactive, <a
                        href="#oaigd">OAIGD</a>.
            </li>
        </ul>
        <div class="layout-main">
            <div class="layout-content">
                <div id="appslist">
                    <div class="apps" style="background:#000000;"><span class="appstitle">Nb</span><br/><span
                                class="appsname">break</span></div>
                    <div class="apps" style="background:#11dd11;"><span class="appstitle">Me</span><br/><span
                                class="appsname">messae</span></div>
                    <div class="apps" style="background:#212151;"><span class="appstitle">No</span><br/><span
                                class="appsname">option</span></div>
                    <div class="apps" style="background:#313131;"><span class="appstitle">Nd</span><br/><span
                                class="appsname">defolt</span></div>
                    <div class="apps" style="background:#ee8011;"><span class="appstitle">Kl</span><br/><span
                                class="appsname">klicty</span></div>
                    <div class="apps" style="background:#115131;"><span class="appstitle">Nu</span><br/><span
                                class="appsname">upload</span></div>
                    <div class="apps" style="background:#dd1111;"><span class="appstitle">Sy</span><br/><span
                                class="appsname">sylabe</span></div>
                    <div class="apps" style="background:#eed11f;"><span class="appstitle">Qa</span><br/><span
                                class="appsname">qantion</span></div>
                </div>
            </div>
        </div>

        <h4 id="oain">OAIN / Nommage</h4>
        <p>A faire...</p>

        <h4 id="oaip">OAIP / Protection</h4>
        <p>A faire...</p>

        <h4 id="oaid">OAID / Dissimulation</h4>
        <p>A faire...</p>

        <h4 id="oail">OAIL / Liens</h4>
        <p>A faire...</p>

        <h4 id="oaic">OAIC / Création</h4>
        <p>La création d'une application se passe en trois parties. Il faut créer un objet de référence de la nouvelle
            application. Il faut lui affecter un objet de code, objet de code qui sera mise à jour plus tard. Enfin il
            faut enregistrer l'application pour la rendre disponible.</p>
        <h4 id="oaicr">OAICR / Référence</h4>
        <p>Cette partie est à faire au début lorsque l’on veut rendre visible et utiliser la nouvelle application. Elle
            ne sera plus refaite par la suite. Le but est de permettre au <i>bootstrap</i> de retrouver l’application et
            de permettre à l’utilisateur de la sélectionner.</p>
        <div class="layout-main">
            <div class="layout-content">
                <div id="appslist">
                    <div class="apps" style="background:#dd1111;"><span class="appstitle">Sy</span><br/><span
                                class="appsname">sylabe</span></div>
                </div>
            </div>
        </div>
        <p>On définit un objet de référence, un objet qui sera en quelque sorte virtuel puisqu’il n’aura pas de contenu.
            Sa seule contrainte forte est que l’empreinte est exprimée en hexadécimal. Par convention, il est recommandé
            que la taille de l’empreinte des objets virtuels soit comprise en 129 et 191 bits. Cet objet de référence
            peut être généré aléatoirement ou au contraire avoir un contenu pré-déterminé, ou mixer les deux.</p>
        <p>Chaque application doit avoir un objet de référence qui lui est réservé. Utiliser l’objet de référence d’une
            autre application revient à tenter de mettre à jour l’application, non à en faire une nouvelle.</p>
        <p>Par exemple avec la commande : <code>openssl rand -hex 24</code></p>
        <p>Cela donne une valeur, notre objet de référence, qui ressemble à ça :</p>
        <code>e5ce3e9938247402722233e4698cda4adb44bb2e01aa0687</code>
        <p>Pour finir avec l’objet de référence, la couleur de l’application dépend de lui. Cette couleur étant
            constituée des 6 premiers caractères de l’empreinte de l’objet de référence, il est possible de choisir
            volontairement cette couleur.</p>
        <p>L’application doit avoir un nom et un préfixe. Ces deux propriétés sont utilisées par le bootstrap pour
            l’affichage des applications dans l’application de sélection des applications.</p>
        <p>Le nom est libre mais si il est trop grand il sera tronqué pour tenir dans le carré de l’application.</p>
        <p>Le préfixe doit faire 2 caractères. Si ce sont des lettres, systématiquement la première sera transformée en
            majuscule et la deuxième en minuscule.</p>
        <p>Par exemple :</p>
        <ul>
            <li>sylabe</li>
            <li>Sy</li>
        </ul>

        <p>Lorsque l’on a défini notre objet de référence et le nom de l’application, on crée les liens.</p>
        <p>Liste des liens à générer lors de la création d'une application interface.</p>
        <ul>
            <li>Le lien de hash :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de l'application</li>
                    <li>cible : hash du nom de l’algorithme de prise d’empreinte</li>
                    <li>méta : hash(‘nebule/objet/hash’)</li>
                </ul>
            </li>
            <li>Le lien de définition de type application :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de l'application</li>
                    <li>cible : hash(‘nebule/objet/interface/web/php/applications’)</li>
                    <li>méta : hash(‘nebule/objet/type’)</li>
                </ul>
            </li>
            <li>Le lien de nommage long de l'application :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de l'application</li>
                    <li>cible : hash(nom long de l'application)</li>
                    <li>méta : hash(‘nebule/objet/nom’)</li>
                </ul>
            </li>
            <li>Le lien de nommage court de l'application :
                <ul>
                    <li>Signature du lien</li>
                    <li>Identifiant du signataire</li>
                    <li>Horodatage</li>
                    <li>action : <code>l</code></li>
                    <li>source : ID de l'application</li>
                    <li>cible : hash(nom court de l'application)</li>
                    <li>méta : hash(‘nebule/objet/surnom’)</li>
                </ul>
            </li>
        </ul>
        <p>Pour que ces liens soient reconnus par le bootstrap, ils doivent tous être signés d’une autorité locale.</p>

        <h5 id="oaicc">OAICC / Code</h5>
        <p>La création de la base d’une application est simple, il suffit de copier le modèle d’application dans un
            nouveau fichier et dans un premier temps d’adapter les variables et la fonction d’affichage.</p>
        <p>Ensuite, ce fichier doit être nébulisé, c’est à dire transféré vers le serveur comme nouvel objet.</p>
        <p>Une fois nébulisé, l’objet peut être déclaré par un lien comme code pour l’objet de référence de
            l’application. Ainsi, l'objet référence point un code à exécuter.</p>
        <p>Le lien de pointage du code :</p>
        <ul>
            <li>Signature du lien</li>
            <li>Identifiant du signataire</li>
            <li>Horodatage</li>
            <li>action : <code>f</code></li>
            <li>source :</li>
            <li>cible :</li>
            <li>méta :</li>
        </ul>

        <p>Exemple de modèle d'application :</p>
        <pre>
&lt;?php
// ------------------------------------------------------------------------------------------
$applicationName		= 'Share';
$applicationSurname		= 'Share All';
$applicationDescription	= 'Web page for sharing all you want.';
$applicationVersion		= '020210410';
$applicationLicence		= 'GNU GPL 2021';
$applicationAuthor		= 'Me';
$applicationWebsite		= 'notme.nebule.org';
// ------------------------------------------------------------------------------------------



/*
 ------------------------------------------------------------------------------------------
 /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING ///
 ------------------------------------------------------------------------------------------

     .     [FR] Toute modification de ce code entrainera une modification de son empreinte
    / \           et entrainera donc automatiquement son invalidation !
   / V \   [EN] Any changes to this code will cause a chage in its footprint and therefore
  /__°__\         automatically result in its invalidation!
     N     [ES] Cualquier cambio en el código causarán un cambio en su presencia y por lo
     N            tanto lugar automáticamente a su anulación!
     N
     N                                                                       Projet nebule
 ----N-------------------------------------------------------------------------------------
 /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING /// WARNING ///
 ------------------------------------------------------------------------------------------
 */



/**
 * Classe Application
 * @author Me
 *
 * Le coeur de l'application.
 *
 */
class Application extends Applications
{
	/**
	 * Constructeur.
	 *
	 * @param nebule $nebuleInstance
	 * @return void
	 */
	public function __construct(nebule $nebuleInstance)
	{
		$this->_nebuleInstance = $nebuleInstance;
	}

	// Tout par défaut.
}



/**
 * Classe Display
 * @author Me
 */
class Display extends Displays
{
	const DEFAULT_LOGO_BOOTSTRAP = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaX
HeAAABMElEQVR42u3ZQWqDQBTG8Tdp6VjEda5gyBnEeIkcxZ20mRuVrt0MIrhKyB3chFoIhULBalfZhCy6kBmI/7dVnPHHm3E+VC
LyKjOuhcy8AAAAAAAAAAAAAAAAAAAAAJhjPU7xkHEcX3xMXim1894Bvl5+qrHZAwAAAAAAfH+KfI6thP8CLAEAyAJkAbIAewAAAA
AAAFmADgAAALIAWYAswB4AAAAAAEAWoAMAAIAsMGEVRbEyxmz/c29VVYckSd5czOtBRDYuBrLWfmitP+M4XoZh+Hzrnr7vf621+z
zPbdu2P3cFICJSluUpCIKvLMvWt67XdX1M0/Td1cs7B7h0wjAMp2sEl23vFeB6OWitn1y3vXeAy3KIoui767rOGNM0TXP2cprkJM
hBCAAAAJhx/QGiUnc0nJCIeAAAAABJRU5ErkJggg==';

	/**
	 * Constructeur.
	 *
	 * @param Applications $applicationInstance
	 * @return void
	 */
	public function __construct(Applications $applicationInstance)
	{
		$this->_applicationInstance = $applicationInstance;
	}



	/**
	 * Affichage de la page.
	 */
	public function display()
	{
		global $applicationVersion, $applicationLicence, $applicationWebsite,
				$applicationName, $applicationSurname, $applicationAuthor;
		?>
&lt;!DOCTYPE html>
&lt;html>
	&lt;body>
		Hello
	&lt;/body>
&lt;/html>
&lt;?php
	}
}



/**
 * Classe Action
 * @author Me
 */
class Action extends Actions
{
	const ACTION_APPLY_DELAY = 5;
	/**
	 * Constructeur.
	 *
	 * @param Applications $applicationInstance
	 * @return void
	 */
	public function __construct(Applications $applicationInstance)
	{
		$this->_applicationInstance = $applicationInstance;
	}



	/**
	 * Traitement des actions génériques.
	 */
	public function genericActions()
	{
		$this->_metrology->addLog('Generic actions', Metrology::LOG_LEVEL_DEBUG); // Log

		// Rien.

		$this->_metrology->addLog('Generic actions end', Metrology::LOG_LEVEL_DEBUG); // Log
	}



	/**
	 * Traitement des actions spéciales, qui peuvent être réalisées sans entité déverrouillée.
	 */
	public function specialActions()
	{
		$this->_metrology->addLog('Special actions', Metrology::LOG_LEVEL_DEBUG); // Log

		// Rien.

		$this->_metrology->addLog('Special actions end', Metrology::LOG_LEVEL_DEBUG); // Log
	}
}



/**
 * Classe Traduction
 * @author Me
 */
class Traduction extends Traductions
{
	/**
	 * Constructeur.
	 *
	 * @param Application $applicationInstance
	 * @return void
	 */
	public function __construct(Application $applicationInstance)
	{
		$this->_applicationInstance = $applicationInstance;
	}



	/**
	 * Initialisation de la table de traduction.
	 */
	protected function _initTable()
	{
		$this->_table['fr-fr']['::::INFO']='Information';
		$this->_table['en-en']['::::INFO']='Information';
		$this->_table['es-co']['::::INFO']='Information';
		$this->_table['fr-fr']['::::OK']='OK';
		$this->_table['en-en']['::::OK']='OK';
		$this->_table['es-co']['::::OK']='OK';
		$this->_table['fr-fr']['::::INFORMATION']='Message';
		$this->_table['en-en']['::::INFORMATION']='Message';
		$this->_table['es-co']['::::INFORMATION']='Mensaje';
		$this->_table['fr-fr']['::::WARN']='ATTENTION !';
		$this->_table['en-en']['::::WARN']='WARNING!';
		$this->_table['es-co']['::::WARN']='¡ADVERTENCIA!';
		$this->_table['fr-fr']['::::ERROR']='ERREUR !';
		$this->_table['en-en']['::::ERROR']='ERROR!';
		$this->_table['es-co']['::::ERROR']='¡ERROR!';

		$this->_table['fr-fr']['::::RESCUE']='Mode de sauvetage !';
		$this->_table['en-en']['::::RESCUE']='Rescue mode!';
		$this->_table['es-co']['::::RESCUE']='¡Modo de rescate!';
	}
}
</pre>

        <h5 id="oaice">OAICE / Enregistrement</h5>
        <p>Le lien d'enregistrement de l'application :</p>
        <ul>
            <li>Signature du lien</li>
            <li>Identifiant du signataire</li>
            <li>Horodatage</li>
            <li>action : <code>l</code></li>
            <li>source :</li>
            <li>cible :</li>
            <li>méta :</li>
        </ul>
        <p>A faire...</p>

        <h4 id="oaiu">OAIU / Mise à Jour</h4>
        <p>A faire...</p>

        <h4 id="oais">OAIS / Stockage</h4>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h4 id="oait">OAIT / Transfert</h4>
        <p>A faire...</p>

        <h4 id="oair">OAIR / Réservation</h4>
        <p>Les objets réservés spécifiquement pour les applications :</p>
        <ul>
            <li>nebule/objet/interface/web/php/bootstrap</li>
            <li>nebule/objet/interface/web/php/bibliotheque</li>
            <li>nebule/objet/interface/web/php/applications</li>
            <li>nebule/objet/interface/web/php/applications/direct</li>
            <li>nebule/objet/interface/web/php/applications/active</li>
        </ul>

        <h4 id="oaig">OAIG / Applications d'Interfaçage Génériques</h4>
        <p>Ces applications sont développées dans le cadre de <i>nebule</i> et sont librement mises à disposition (sous
            license).</p>
        <p>Le nom de ces applications est toujours en minuscule.</p>

        <h5 id="oaigb">OAIGB / Nb - bootstrap</h5>
        <p>A faire...</p>

        <h5 id="oaigs">OAIGS / Sy - sylabe</h5>
        <p>A faire...</p>

        <h5 id="oaigk">OAIGK / Kl - klicty</h5>
        <p>A faire...</p>

        <h5 id="oaigm">OAIGM / Me - messae</h5>
        <p>A faire...</p>

        <h5 id="oaigo">OAIGO / No - option</h5>
        <p>A faire...</p>

        <h5 id="oaigu">OAIGU / Nu - upload</h5>
        <p>A faire...</p>

        <h5 id="oaigd">OAIGD / Nd - defolt</h5>
        <p>A faire...</p>

        <?php Modules::echoDocumentationCore(); ?>

        <h4 id="oaio">OAIO / Implémentation des Options</h4>
        <p>A faire...</p>

        <h4 id="oaia">OAIA / Implémentation des Actions</h4>
        <p>A faire...</p>

        <?php
    }
}


/**
 * Classe Traductions
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
abstract class Traductions
{
    /* ---------- ---------- ---------- ---------- ----------
	 * Constantes.
	 *
	 * Leur modification change profondément le comportement de l'application.
	 *
	 * Si déclarées 'const' ou 'static' elles ne sont pas remplacée dans les classes enfants
	 *   lorsque l'on appelle des fonctions de la classe parente non écrite dans la classe enfant...
	 */
    /**
     * langue par défaut.
     *
     * @var string
     */
    protected $DEFAULT_LANGUAGE = 'en-en';

    /**
     * Commande de sélection de la langue.
     * @var string
     */
    const DEFAULT_COMMAND_LANGUAGE = 'lang';

    /**
     * Liste des languages supportés.
     *
     * @var array
     */
    protected $LANGUAGE_LIST = array('en-en');

    /**
     * Liste des icônes des languages supportés.
     *
     * @var array
     */
    protected $LANGUAGE_ICON_LIST = array('en-en' => '7796077f1b865951946dd40ab852f6f4d21e702e7c4f47bd5fa6cb9ce94a4c5f');


    /* ---------- ---------- ---------- ---------- ----------
	 * Variables.
	 *
	 * Les valeurs par défaut sont indicatives. Ne pas les replacer.
	 * Les variables sont systématiquement recalculées.
	 */
    /**
     * Paramètre d'activation de la gestion des modules.
     *
     * @var boolean
     */
    protected $_useModules = false;

    /**
     * L'instance de la librairie nebule.
     *
     * @var nebule
     */
    protected $_nebuleInstance;

    /**
     * L'instance de l'application.
     *
     * @var Applications
     */
    protected $_applicationInstance;

    /**
     * L'instance de la métrologie.
     *
     * @var Metrology
     */
    protected $_metrologyInstance;

    /**
     * Langue sélectionnée.
     *
     * @var string
     */
    protected $_currentLanguage;

    /**
     * Icône de la langue sélectionnée.
     *
     * @var string
     */
    protected $_currentLanguageIcon;

    /**
     * Langue par défaut.
     *
     * @var string
     */
    protected $_defaultLanguage;

    /**
     * Liste des langues disponibles.
     *
     * @var array of string
     */
    protected $_languageList = array();

    /**
     * Liste des icônes des langues disponibles.
     *
     * @var array of string
     */
    protected $_languageIconList = array();

    protected $_languageInstanceList = array();
    protected $_currentLanguageInstance;
    protected $_defaultLanguageInstance;


    /**
     * Constructeur.
     *
     * @param Application $applicationInstance
     * @return void
     */
    public function __construct(Application $applicationInstance)
    {
        $this->_applicationInstance = $applicationInstance;
    }

    /**
     * Initialisation des variables et instances interdépendantes.
     *
     * @return void
     */
    public function initialisation()
    {
        $this->_nebuleInstance = $this->_applicationInstance->getNebuleInstance();
        $this->_metrologyInstance = $this->_nebuleInstance->getMetrologyInstance();
        $this->_metrologyInstance->addLog('Load translates', Metrology::LOG_LEVEL_DEBUG); // Log
        // Détecte si les modules sont activés.
        if ($this->_applicationInstance->getUseModules()) {
            $this->_useModules = true;
        }

        // Recherche les languages.
        $this->_findDefaultLanguage();
        $this->_findLanguages();
        $this->_findCurrentLanguage();
        $this->_findIcons();
        $this->_findCurrentIcon();
        $this->_initTable();

        // Aucun affichage, aucune traduction, aucune action avant le retour de cette fonction.
        // Les instances interdépendantes doivent être synchronisées.
    }

    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return 'Traduction';
    }

    /**
     * Fonction de mise en sommeil.
     *
     * @return array:string
     */
    public function __sleep()
    {
        return array();
    }

    /**
     * Fonction de réveil.
     *
     * Récupère l'instance de la librairie nebule et de l'application.
     *
     * @return null
     */
    public function __wakeup()
    {
        global $applicationInstance;

        $this->_applicationInstance = $applicationInstance;
    }

    /**
     * Initialisation des variables et instances interdépendantes.
     * @return void
     * @todo à optimiser avec __wakeup et __sleep.
     *
     */
    public function initialisation2()
    {
        $this->_nebuleInstance = $this->_applicationInstance->getNebuleInstance();
        $this->_metrologyInstance = $this->_nebuleInstance->getMetrologyInstance();
        $this->_metrologyInstance->addLog('Load translates', Metrology::LOG_LEVEL_DEBUG); // Log
        // Détecte si les modules sont activés.
        if ($this->_applicationInstance->getUseModules()) {
            $this->_useModules = true;
        }

        // Recherche les languages.
        $this->_findDefaultLanguage();
        $this->_findLanguages();
        $this->_findCurrentLanguage();
        $this->_findIcons();
        $this->_findCurrentIcon();
        $this->_initTable();

        // Aucun affichage, aucune traduction, aucune action avant le retour de cette fonction.
        // Les instances interdépendantes doivent être synchronisées.
    }


    /**
     * Cherche la langue par défaut.
     *
     * @return void
     */
    protected function _findDefaultLanguage()
    {
        $this->_defaultLanguage = $this->DEFAULT_LANGUAGE;

        if ($this->_useModules) {
            foreach ($this->_languageInstanceList as $module) {
                if ($module->getCommandName() == $this->_defaultLanguage) {
                    $this->_defaultLanguageInstance = $module;
                }
            }
        }

        $this->_metrologyInstance->addLog('Find default language : ' . $this->_defaultLanguage, Metrology::LOG_LEVEL_DEBUG); // Log
    }


    /**
     * Cherche les langues disponibles.
     *
     * @return void
     */
    protected function _findLanguages()
    {
        if ($this->_useModules) {
            foreach ($this->_applicationInstance->getModulesListInstances() as $module) {
                if ($module->getType() == 'traduction') {
                    $this->_languageList[$module->getCommandName()] = $module->getCommandName();
                    $this->_languageInstanceList[$module->getCommandName()] = $module;

                    $this->_metrologyInstance->addLog('Find new language : ' . $module->getCommandName(), Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }
        } else {
            $this->_languageList = $this->LANGUAGE_LIST;
        }
    }


    /**
     * La langue d'affichage de l'interface.
     *
     * La recherche de la langue se fait en lisant la langue demandée dans l'URL,
     *   puis en la comparant aux modules de traductions présents.
     *
     * @return void
     */
    protected function _findCurrentLanguage()
    {
        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // Lit et nettoye le contenu de la variable GET.
        $arg_lang = filter_input(INPUT_GET, self::DEFAULT_COMMAND_LANGUAGE, FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW);

        // Test la forme.
        if ($arg_lang != ''
            && strlen($arg_lang) != 5
            && substr($arg_lang, 2, 1) != '-'
        ) {
            $arg_lang = '';
        }

        // Recherche un langage connu.
        $ok_lang = false;
        $lang_instance = '';
        foreach ($this->_languageList as $lang) {
            if ($arg_lang == $lang) {
                $ok_lang = true;
                if ($this->_useModules) {
                    $lang_instance = $this->_languageInstanceList[$lang];
                }
                break;
            }
        }

        // Si le langage est connu.
        if ($ok_lang) {
            $this->_currentLanguage = $arg_lang; // Ecrit le langage dans la variable.
            $this->_currentLanguageInstance = $lang_instance;
            // Ecrit le langage dans la session.
            $this->_nebuleInstance->setSessionStore($this->_applicationInstance->getClassName() . 'DisplayLanguage', $arg_lang);
        } else {
            $cache = $this->_nebuleInstance->getSessionStore($this->_applicationInstance->getClassName() . 'DisplayLanguage');
            // Si il existe une variable de session pour le mode d'affichage, la lit.
            if ($cache !== false
                && $cache != ''
            ) {
                $this->_currentLanguage = $cache;
                $this->_currentLanguageInstance = $this->_languageInstanceList[$cache];
            } else // Sinon active le langage par defaut.
            {
                $this->_currentLanguage = $this->_defaultLanguage;
                $this->_currentLanguageInstance = $this->_languageInstanceList[$this->_defaultLanguage];
                $this->_nebuleInstance->setSessionStore($this->_applicationInstance->getClassName() . 'DisplayLanguage', $this->_defaultLanguage);
            }
            unset($cache);
        }

        $this->_metrologyInstance->addLog('Find current language : ' . $this->_currentLanguage, Metrology::LOG_LEVEL_DEBUG); // Log
    }


    /**
     * Retourne la liste des langues.
     *
     * @return array of string
     */
    public function getLanguageList()
    {
        return $this->_languageList;
    }

    public function getDefaultLanguage()
    {
        return $this->_defaultLanguage;
    }

    public function getCurrentLanguage()
    {
        return $this->_currentLanguage;
    }

    public function getCurrentLanguageIcon()
    {
        return $this->_currentLanguageIcon;
    }

    public function getLanguageIcon($lang)
    {
        $result = $this->_languageIconList[$this->_currentLanguage];
        if (isset($this->_languageIconList[$lang])) {
            $result = $this->_languageIconList[$lang];
        }
        return $result;
    }

    public function getLanguageInstanceList()
    {
        return $this->_languageInstanceList;
    }

    public function getCurrentLanguageInstance()
    {
        return $this->_currentLanguageInstance;
    }

    public function getDefaultLanguageInstance()
    {
        return $this->_defaultLanguageInstance;
    }


    /**
     * La traduction de textes recherche une traduction pour le langage en cours.
     *
     * Sans module :
     * 1) Recherche le texte traduit dans le langage courant.
     * 2) Si aucune traduction n'est trouvée, retourne le texte traduit dans le langage par défaut.
     * 3) Si aucune traduction n'est trouvée, retourne le texte non traduit.
     *
     * Avec modules :
     * 1) Recherche le texte traduit le module de traduction pour le langage courant.
     * 2) Si pas trouvé, recherche dans le module utilisé à l'affichage pour le langage courant.
     * 3) Si pas trouvé, recherche dans le module de traduction pour le langage par défaut.
     * 4) Si pas trouvé, recherche dans le module utilisé à l'affichage pour le langage par défaut.
     * 5) Si pas trouvé, recherche dans tous les modules disponibles pour le langage courant.
     * 6) Si pas trouvé, recherche dans tous les modules disponibles pour le langage par défaut.
     * 7) Si pas trouvé, retourne le texte d'origine.
     *
     * Un module, s'il n'est pas dédié à la traduction, ne doit prendre en charge que la translation des textes
     *   qui le concerne. Mais il peut traduire ces textes dans plusieurs langues.
     *
     * Un texte qui commence par '<' est considéré comme une balise et n'est pas traduit.
     *
     * @param string $text
     * @return string
     */
    public function getTraduction($text, $lang = '')
    {
        $result = $text;

        // Sélectionne le language de traduction.
        if ($lang == '') {
            $lang = $this->_currentLanguage;
        }

        $this->_metrologyInstance->addLog('Get traduction ' . $lang . ' : "' . substr($text, 0, 250) . '"', Metrology::LOG_LEVEL_DEBUG); // Log

        // Si le texte est une balise, comme par '<', ne fait pas la traduction.
        if (substr($text, 0, 1) == '<') {
            return $result;
        }

        if (!$this->_useModules) // Si pas de modules.
        {
            if (isset($this->_table[$lang][$text])) {
                $result = $this->_table[$lang][$text];
            } elseif (isset($this->_table[$this->_defaultLanguage][$text])) {
                $result = $this->_table[$this->_defaultLanguage][$text];
            }
        } else // Si modules.
        {
            // 1) Appel le module de traduction avec la langue en cours.
            foreach ($this->_languageInstanceList as $module) {
                if ($module->getCommandName() == $lang) {
                    $result = $module->getTraduction($text, $lang);
                    $this->_metrologyInstance->addLog('Module 1 find traduction : "' . $result . '"', Metrology::LOG_LEVEL_DEBUG); // Log
                }
            }

            // 2) Si rien trouvé, appel le module d'affichage en cours avec la langue en cours.
            if ($result == ''
                || $result == $text
            ) {
                $result = $this->_applicationInstance->getCurrentModuleInstance()->getTraduction($text, $lang);
                $this->_metrologyInstance->addLog('Module 2 find traduction : "' . $result . '"', Metrology::LOG_LEVEL_DEBUG); // Log
            }

            // 3) Si rien trouvé, appel le module de traduction avec la langue par défaut.
            if (($result == ''
                    || $result == $text
                )
                && $lang != $this->_defaultLanguage
            ) {
                foreach ($this->_languageInstanceList as $module) {
                    if ($module->getCommandName() == $this->_defaultLanguage) {
                        $result = $module->getTraduction($text, $this->_defaultLanguage);
                        $this->_metrologyInstance->addLog('Module 3 find traduction : "' . $result . '"', Metrology::LOG_LEVEL_DEBUG); // Log
                    }
                }
            }

            // 4) Si rien trouvé, appel le module d'affichage en cours avec la langue par défaut.
            if ($result == ''
                || $result == $text
            ) {
                $result = $this->_applicationInstance->getCurrentModuleInstance()->getTraduction($text, $this->_defaultLanguage);
                $this->_metrologyInstance->addLog('Module 4 find traduction : "' . $result . '"', Metrology::LOG_LEVEL_DEBUG); // Log
            }

            // 5) Si rien trouvé, appel tous les modules avec la langue en cours.
            if ($result == ''
                || $result == $text
            ) {
                foreach ($this->_applicationInstance->getModulesListInstances() as $module) {
                    $result = $module->getTraduction($text, $lang);
                    $this->_metrologyInstance->addLog('Module 5 find traduction : "' . $result . '"', Metrology::LOG_LEVEL_DEBUG); // Log
                    if ($result != $text) {
                        break;
                    }
                }
            }

            // 6) Si rien trouvé, appel tous les modules avec la langue par défaut.
            if (($result == ''
                    || $result == $text
                )
                && $lang != $this->_defaultLanguage
            ) {
                foreach ($this->_applicationInstance->getModulesListInstances() as $module) {
                    $result = $module->getTraduction($text, $this->_defaultLanguage);
                    $this->_metrologyInstance->addLog('Module 6 find traduction : "' . $result . '"', Metrology::LOG_LEVEL_DEBUG); // Log
                    if ($result != $text) {
                        break;
                    }
                }
            }

            // 7) Par défaut si rien trouvé renvoie le texte originel.
            if ($result == '') {
                $result = $text;
            }
        }

        // Retourne le résultat.
        $this->_metrologyInstance->addLog('End find traduction : "' . $result . '"', Metrology::LOG_LEVEL_DEBUG); // Log
        return $result;
    }

    /**
     * Affiche un texte préalablement traduit.
     * Le texte peut se voir forcé sa couleur.
     * Certaines séquences peuvent être remplacées par des valeurs, les arguments.
     *
     * @param string $text
     * @param string $color
     * @param string $arg1
     * @param string $arg2
     * @param string $arg3
     * @param string $arg4
     * @param string $arg5
     * @param string $arg6
     * @param string $arg7
     * @param string $arg8
     * @param string $arg9
     * @return void
     */
    public function echoTraduction($text, $color = '', $arg1 = null, $arg2 = null, $arg3 = null, $arg4 = null, $arg5 = null, $arg6 = null, $arg7 = null, $arg8 = null, $arg9 = null)
    {
        if ($color != '') {
            echo "<font color=\"$color\">";
        }
        echo sprintf($this->getTraduction($text), $arg1, $arg2, $arg3, $arg4, $arg5, $arg6, $arg7, $arg8, $arg9);
        if ($color != '') {
            echo '</font>';
        }
    }

    protected function _findIcons()
    {
        if ($this->_useModules) {
            foreach ($this->_languageInstanceList as $module) {
                $this->_languageIconList[$module->getCommandName()] = $module->getLogo();
            }
        } else {
            $this->_languageIconList = $this->LANGUAGE_ICON_LIST;
        }
    }

    protected function _findCurrentIcon()
    {
        $this->_currentLanguageIcon = $this->_languageIconList[$this->_currentLanguage];
    }


    /**
     * Table des traductions.
     *
     * @var array
     */
    protected $_table = array();

    /**
     * Initialisation de la table de traduction.
     *
     * @return void
     */
    protected function _initTable()
    {
        $this->_table['fr-fr']['::Welcome'] = 'Bienvenue';
        $this->_table['en-en']['::Welcome'] = 'Welcome';
        $this->_table['es-co']['::Welcome'] = 'Bienvenido';
    }
}


/**
 * Classe Modules
 *
 * @author Projet nebule
 * @license GNU GPLv3
 * @copyright Projet nebule
 * @link www.nebule.org
 */
abstract class Modules
{
    /* ---------- ---------- ---------- ---------- ----------
	 * Constantes.
	 *
	 * Leur modification change profondément le comportement de l'application.
	 *
	 * Si déclarées 'const' ou 'static' elles ne sont pas remplacée dans les classes enfants
	 *   lorsque l'on appelle des fonctions de la classe parente non écrite dans la classe enfant...
	 */
    /**
     * Le type de module.
     * None : Le module est chargé mais n'est pas utilisé après.
     * Application : Le module est chargé puis appelé aux emplacements dédiés aux applications.
     *     Il est aussi utilisé pour les traductions qui le concerne.
     * Traduction : Le module est chargé puis utilisé pour toute traduction.
     *
     * @var string
     */
    protected $MODULE_TYPE = 'None'; // None | Application | Traduction

    /**
     * Le nom du module. Ce nom est généralement proche du nom de la classe.
     *
     * @var string
     */
    protected $MODULE_NAME = 'None';

    protected $MODULE_MENU_NAME = 'None';
    protected $MODULE_COMMAND_NAME = 'none';
    protected $MODULE_DEFAULT_VIEW = 'disp';
    protected $MODULE_DESCRIPTION = 'Description';
    protected $MODULE_VERSION = '020160925';
    protected $MODULE_DEVELOPPER = 'Projet nebule';
    protected $MODULE_LICENCE = '(c) GLPv3 sylabe 2013-2016';
    protected $MODULE_LOGO = '47e168b254f2dfd0a4414a0b96f853eed3df0315aecb8c9e8e505fa5d0df0e9c';
    protected $MODULE_HELP = 'Help';
    protected $MODULE_INTERFACE = '2.0';

    protected $MODULE_REGISTERED_VIEWS = array('disp');
    protected $MODULE_REGISTERED_ICONS = array();
    protected $MODULE_APP_TITLE_LIST = array();
    protected $MODULE_APP_ICON_LIST = array();
    protected $MODULE_APP_DESC_LIST = array();
    protected $MODULE_APP_VIEW_LIST = array();

    const DEFAULT_COMMAND_ACTION_DISPLAY_MODULE = 'name';


    /* ---------- ---------- ---------- ---------- ----------
	 * Variables.
	 *
	 * Les valeurs par défaut sont indicatives. Ne pas les replacer.
	 * Les variables sont systématiquement recalculées.
	 */
    /**
     * Instance de l'application.
     *
     * @var Applications
     */
    protected $_applicationInstance;

    /**
     * Instance de la librairie nebule.
     *
     * @var nebule
     */
    protected $_nebuleInstance;

    /**
     * Instance de la classe d'affichage.
     *
     * @var Displays
     */
    protected $_display;

    /**
     * Instance de la classe de traduction.
     *
     * @var Traductions
     */
    protected $_traduction;

    /**
     * Etat de verrouillage de l'entité en cours.
     *
     * @var boolean
     */
    protected $_unlocked;

    /**
     * Table des traductions spécifiques au module.
     *
     * @var array of string
     */
    protected $_table = array();


    /**
     * Constructeur.
     *
     * @param Applications $applicationInstance
     * @return void
     */
    public function __construct(Applications $applicationInstance)
    {
        $this->_applicationInstance = $applicationInstance;
    }

    /**
     * Configuration spécifique au module.
     *
     * @return void
     */
    public function initialisation()
    {
        $this->_nebuleInstance = $this->_applicationInstance->getNebuleInstance();
        $this->_display = $this->_applicationInstance->getDisplayInstance();
        $this->_traduction = $this->_applicationInstance->getTraductionInstance();
        $this->_unlocked = $this->_nebuleInstance->getCurrentEntityUnlocked();
        $this->_initTable();
    }


    /**
     * Fonction de suppression de l'instance.
     *
     * @return boolean
     */
    public function __destruct()
    {
        return true;
    }

    /**
     * Donne le texte par défaut lorsque l'instance est utilisée comme texte.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->MODULE_NAME;
    }

    public function getClassName()
    {
        return static::class;
    }

    public function getType()
    {
        return strtolower($this->MODULE_TYPE);
    }

    public function getName()
    {
        return $this->MODULE_NAME;
    }

    public function getMenuName()
    {
        return $this->MODULE_MENU_NAME;
    }

    public function getRegisteredViews()
    {
        return $this->MODULE_REGISTERED_VIEWS;
    }

    public function getCommandName()
    {
        return $this->MODULE_COMMAND_NAME;
    }

    public function getDefaultView()
    {
        return $this->MODULE_DEFAULT_VIEW;
    }

    public function getDescription()
    {
        return $this->MODULE_DESCRIPTION;
    }

    public function getVersion()
    {
        return $this->MODULE_VERSION;
    }

    public function getDevelopper()
    {
        return $this->MODULE_DEVELOPPER;
    }

    public function getLicence()
    {
        return $this->MODULE_LICENCE;
    }

    public function getLogo()
    {
        return $this->MODULE_LOGO;
    }

    public function getHelp()
    {
        return $this->MODULE_HELP;
    }

    public function getInterface()
    {
        return $this->MODULE_INTERFACE;
    }

    // Gestion de la présence dans le menu des applications.
    public function getAppTitleList()
    {
        return $this->MODULE_APP_TITLE_LIST;
    }

    public function getAppIconList()
    {
        return $this->MODULE_APP_ICON_LIST;
    }

    public function getAppDescList()
    {
        return $this->MODULE_APP_DESC_LIST;
    }

    public function getAppViewList()
    {
        return $this->MODULE_APP_VIEW_LIST;
    }


    /**
     * Ajout de fonctionnalités à des points d'ancrage.
     *
     * @param string $hookName
     * @return array
     */
    public function getHookList($hookName, $object = 'none')
    {
        $hookArray = array();
        return $hookArray;
    }


    /**
     * Affichage principale.
     *
     * @return void
     */
    public function display()
    {
        // N'affiche rien par défaut.
    }

    /**
     * Affichage en ligne comme élément inseré dans une page web.
     *
     * @return void
     */
    public function displayInline()
    {
        // N'affiche rien par défaut.
    }

    /**
     * Cache de la lecture de la commande d'action d'affichage du module.
     *
     * @var string
     */
    private $_commandActionDisplayModuleCache = null;

    /**
     * Extrait en vue d'un affichage dans le module un texte/objet à afficher.
     *
     * @return void
     */
    public function getExtractCommandDisplayModule()
    {
        $return = '';

        if ($this->_commandActionDisplayModuleCache != null) {
            return $this->_commandActionDisplayModuleCache;
        }

        /*
		 *  ------------------------------------------------------------------------------------------
		 *  DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER DANGER
		 *  ------------------------------------------------------------------------------------------
		 */
        // Vérifie que l'on est en vue affichage de module.
        if ($this->_display->getCurrentDisplayView() == $this->MODULE_REGISTERED_VIEWS[1]) {
            // Lit et nettoye le contenu de la variable GET.
            $arg = trim(filter_input(INPUT_GET, self::DEFAULT_COMMAND_ACTION_DISPLAY_MODULE, FILTER_SANITIZE_STRING));

            // Ecriture des variables.
            if ($arg != '') {
                $return = $arg;
            }

            unset($arg);
        }

        // Mise en cache.
        $this->_commandActionDisplayModuleCache = $return;

        return $return;
    }

    /**
     * Affichage de surcharges CSS.
     *
     * @return void
     */
    public function getCSS()
    {
        echo '<style type="text/css">' . "\n";
        $this->headerStyle();
        echo '</style>' . "\n";
    }

    /**
     * Affichage de surcharges CSS.
     *
     * Obsolète !!!
     *
     * @return void
     */
    public function headerStyle()
    {
        // N'affiche rien par défaut.
    }

    /**
     * Affichage de surcharges de java script.
     *
     * @return void
     */
    public function headerScript()
    {
        // N'affiche rien par défaut.
    }

    /**
     * Action principale.
     *
     * @return void
     */
    public function action()
    {
        // Ne fait rien par défaut.
    }

    /**
     * Traduction.
     *
     * Si besoin, extrait la langue de destination.
     *
     * Si aucune traduction n'est trouvée dans la langue demandée, retourne le texte d'origine.
     *
     * @param string $text
     * @param string $lang
     * @return string
     */
    public function getTraduction($text, $lang = '')
    {
        $result = $text;
        if ($this->_traduction == null) {
            $this->_traduction = $this->_applicationInstance->getTraductionInstance();
        }

        if ($lang == '') {
            $lang = $this->_traduction->getCurrentLanguage();
        }

        if (isset($this->_table[$lang][$text])) {
            $result = $this->_table[$lang][$text];
        }
        return $result;
    }

    /**
     * Traduction interne à la classe.
     *
     * @param string $text
     * @return string
     */
    protected function _traduction($text, $lang = '')
    {
        return $this->_traduction->getTraduction($text, $lang);
    }

    /**
     * Affichage du texte traduit, interne à la classe.
     *
     * @param string $text
     * @return void
     */
    protected function _echoTraduction($text)
    {
        $this->_traduction->echoTraduction($text);
    }


    /**
     * Créer un lien.
     *
     * @param string $signer
     * @param string $date
     * @param string $action
     * @param string $source
     * @param string $target
     * @param string $meta
     * @param boolean $obfuscate
     * @return void
     */
    protected function _createLink($signer, $date, $action, $source, $target, $meta, $obfuscate = false)
    {
        // Génère le lien.
        $link = '0_' . $signer . '_' . $date . '_' . $action . '_' . $source . '_' . $target . '_' . $meta;
        $newLink = new Link($this->_nebuleInstance, $link);

        // Signe le lien.
        $newLink->sign($signer);

        // Si besoin, obfuscation du lien.
        if ($obfuscate) {
            $link->obfuscate();
        }

        // Ecrit le lien.
        $newLink->write();
    }


    /**
     * Initialisation de la table de traduction.
     *
     * @return void
     */
    protected function _initTable()
    {
        $this->_table['fr-fr']['::nebule:modules::ModuleName'] = 'Module des modules';
        $this->_table['en-en']['::nebule:modules::ModuleName'] = 'Module of modules';
        $this->_table['es-co']['::nebule:modules::ModuleName'] = 'Module of modules';
        $this->_table['fr-fr']['::nebule:modules::MenuName'] = 'Modules';
        $this->_table['en-en']['::nebule:modules::MenuName'] = 'Modules';
        $this->_table['es-co']['::nebule:modules::MenuName'] = 'Modules';
        $this->_table['fr-fr']['::nebule:modules::ModuleDescription'] = 'Module de gestion des modules.';
        $this->_table['en-en']['::nebule:modules::ModuleDescription'] = 'Module to manage modules.';
        $this->_table['es-co']['::nebule:modules::ModuleDescription'] = 'Module to manage modules.';
        $this->_table['fr-fr']['::nebule:modules::ModuleHelp'] = 'Cette application permet de voir les modules détectés par sylabe.';
        $this->_table['en-en']['::nebule:modules::ModuleHelp'] = 'This application permit to see modules detected by sylabe.';
        $this->_table['es-co']['::nebule:modules::ModuleHelp'] = 'This application permit to see modules detected by sylabe.';

        $this->_table['fr-fr']['::nebule:modules::AppTitle1'] = 'Modules';
        $this->_table['en-en']['::nebule:modules::AppTitle1'] = 'Modules';
        $this->_table['es-co']['::nebule:modules::AppTitle1'] = 'Modules';
        $this->_table['fr-fr']['::nebule:modules::AppDesc1'] = 'Module de gestion des modules.';
        $this->_table['en-en']['::nebule:modules::AppDesc1'] = 'Manage modules.';
        $this->_table['es-co']['::nebule:modules::AppDesc1'] = 'Manage modules.';
    }


    /**
     * Affiche la partie menu de la documentation.
     * Inclu dans les applications.
     *
     * @return void
     */
    public function echoDocumentationTitles()
    {
        ?>

        <li><a href="#oam">OAM / Module</a>
            <ul>
                <li><a href="#oamn">OAMN / Nommage</a></li>
                <li><a href="#oamp">OAMP / Protection</a></li>
                <li><a href="#oamd">OAMD / Dissimulation</a></li>
                <li><a href="#oaml">OAML / Liens</a></li>
                <li><a href="#oamc">OAMC / Création</a></li>
                <li><a href="#oamu">OAMU / Mise à Jour</a></li>
                <li><a href="#oams">OAMS / Stockage</a></li>
                <li><a href="#oamt">OAMT / Transfert</a></li>
                <li><a href="#oamr">OAMR / Réservation</a></li>
            </ul>
        </li>

        <?php
    }

    /**
     * Affiche la partie texte de la documentation.
     * Inclu dans les applications.
     *
     * @return void
     */
    public function echoDocumentationCore()
    {
        ?>

        <h3 id="oam">OAM / Module</h3>
        <p>A faire...</p>

        <h4 id="oamn">OAMN / Nommage</h4>
        <p>A faire...</p>

        <h4 id="oamp">OAMP / Protection</h4>
        <p>A faire...</p>

        <h4 id="oamd">OAMD / Dissimulation</h4>
        <p>A faire...</p>

        <h4 id="oaml">OAML / Liens</h4>
        <p>A faire...</p>

        <h4 id="oamc">OAMC / Création</h4>
        <p>Liste des liens à générer lors de la création d'un module.</p>
        <p>A faire...</p>

        <h4 id="oamu">OAMU / Mise à Jour</h4>
        <p>A faire...</p>

        <h4 id="oams">OAMS / Stockage</h4>
        <p>Voir <a href="#oos">OOS</a>, pas de particularité de stockage.</p>

        <h4 id="oamt">OAMT / Transfert</h4>
        <p>A faire...</p>

        <h4 id="oamr">OAMR / Réservation</h4>
        <p>Les objets réservés spécifiquement pour les modules d'applications :</p>
        <ul>
            <li>nebule/objet/interface/web/php/applications/modules</li>
            <li>nebule/objet/interface/web/php/applications/modules/active</li>
        </ul>

        <?php
    }
}
